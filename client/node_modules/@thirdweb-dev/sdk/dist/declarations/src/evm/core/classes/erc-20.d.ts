import type { Address } from "../../schema/shared/Address";
import type { AddressOrEns } from "../../schema/shared/AddressOrEnsSchema";
import type { ClaimOptions } from "../../types/claim-conditions/claim-conditions";
import type { CurrencyValue } from "../../types/currency";
import type { Amount, Currency } from "../../types/currency";
import type { BaseERC20, BaseSignatureMintERC20, BaseDropERC20 } from "../../types/eips";
import type { DetectableFeature } from "../interfaces/DetectableFeature";
import { UpdateableNetwork } from "../interfaces/contract";
import type { NetworkInput } from "../types";
import type { ContractWrapper } from "./contract-wrapper";
import { Transaction } from "./transactions";
import type { TokenERC20, DropERC20, IMintableERC20, IBurnableERC20, IMulticall } from "@thirdweb-dev/contracts-js";
import { ThirdwebStorage } from "@thirdweb-dev/storage";
import { ethers, BigNumber, BigNumberish } from "ethers";
import type { TokenInitializer } from "../../contracts";
import { PayloadToSign20, SignedPayload20 } from "../../schema/contracts/common/signature";
import { ContractRoles } from "./contract-roles";
import { DropClaimConditions } from "./drop-claim-conditions";
/**
 * Standard ERC20 Token functions
 * @remarks Basic functionality for a ERC20 contract that handles all unit transformation for you.
 * @example
 * ```javascript
 * const contract = await sdk.getContract("{{contract_address}}");
 * await contract.erc20.transfer(walletAddress, amount);
 * ```
 * @public
 */
export declare class Erc20<T extends TokenERC20 | DropERC20 | BaseERC20 = BaseERC20 | BaseSignatureMintERC20> implements UpdateableNetwork, DetectableFeature {
    featureName: "ERC20";
    /**
     * Mint tokens
     */
    private mintable;
    private burnable;
    private droppable;
    private signatureMintable;
    protected contractWrapper: ContractWrapper<T>;
    protected storage: ThirdwebStorage;
    private _chainId;
    get chainId(): number;
    constructor(contractWrapper: ContractWrapper<T>, storage: ThirdwebStorage, chainId: number);
    /**
     * @internal
     */
    onNetworkUpdated(network: NetworkInput): void;
    /**
     * @internal
     */
    getAddress(): Address;
    /**
     * Get the token metadata
     * @remarks name, symbol, etc...
     * @example
     * ```javascript
     * const token = await contract.erc20.get();
     * ```
     * @returns The token metadata
     * @twfeature ERC20
     */
    get(): Promise<Currency>;
    /**
     * Get token balance for the currently connected wallet
     *
     * @remarks Get a wallets token balance.
     *
     * @example
     * ```javascript
     * const balance = await contract.erc20.balance();
     * ```
     *
     * @returns The balance of a specific wallet.
     * @twfeature ERC20
     */
    balance(): Promise<CurrencyValue>;
    /**
     * Get token balance for a specific wallet
     *
     * @remarks Get a wallets token balance.
     *
     * @example
     * ```javascript
     * const walletAddress = "{{wallet_address}}";
     * const balance = await contract.erc20.balanceOf(walletAddress);
     * ```
     *
     * @returns The balance of a specific wallet.
     * @twfeature ERC20
     */
    balanceOf(address: AddressOrEns): Promise<CurrencyValue>;
    /**
     * Get the total supply for this token
     * @remarks Get how much supply has been minted
     * @example
     * ```javascript
     * const balance = await contract.erc20.totalSupply();
     * ```
     * @twfeature ERC20
     */
    totalSupply(): Promise<CurrencyValue>;
    /**
     * Get token allowance
     *
     * @remarks Get the allowance of a 'spender' wallet over the connected wallet's funds - the allowance of a different address for a token is the amount of tokens that the `spender` wallet is allowed to spend on behalf of the connected wallet.
     *
     * @example
     * ```javascript
     * // Address of the wallet to check token allowance
     * const spenderAddress = "0x...";
     * const allowance = await contract.erc20.allowance(spenderAddress);
     * ```
     *
     * @returns The allowance of one wallet over anothers funds.
     * @twfeature ERC20
     */
    allowance(spender: AddressOrEns): Promise<CurrencyValue>;
    /**
     * Get token allowance of a specific wallet
     *
     * @remarks Get the allowance of one wallet over another wallet's funds - the allowance of a different address for a token is the amount of tokens that the wallet is allowed to spend on behalf of the specified wallet.
     *
     * @example
     * ```javascript
     * // Address of the wallet who owns the funds
     * const owner = "{{wallet_address}}";
     * // Address of the wallet to check token allowance
     * const spender = "0x...";
     * const allowance = await contract.erc20.allowanceOf(owner, spender);
     * ```
     *
     * @returns The allowance of one wallet over anothers funds.
     * @twfeature ERC20
     */
    allowanceOf(owner: AddressOrEns, spender: AddressOrEns): Promise<CurrencyValue>;
    /**
     * Transfer tokens
     *
     * @remarks Transfer tokens from the connected wallet to another wallet.
     *
     * @example
     * ```javascript
     * // Address of the wallet you want to send the tokens to
     * const toAddress = "0x...";
     * // The amount of tokens you want to send
     * const amount = 0.1;
     * await contract.erc20.transfer(toAddress, amount);
     * ```
     * @twfeature ERC20
     */
    transfer: {
        (to: string, amount: string | number): Promise<Omit<{
            receipt: ethers.providers.TransactionReceipt;
            data: () => Promise<unknown>;
        }, "data">>;
        prepare: (to: string, amount: string | number) => Promise<Transaction<Omit<{
            receipt: ethers.providers.TransactionReceipt;
            data: () => Promise<unknown>;
        }, "data">>>;
    };
    /**
     * Transfer tokens from a specific address
     *
     * @remarks Transfer tokens from one wallet to another
     *
     * @example
     * ```javascript
     * // Address of the wallet sending the tokens
     * const fromAddress = "{{wallet_address}}";
     * // Address of the wallet you want to send the tokens to
     * const toAddress = "0x...";
     * // The number of tokens you want to send
     * const amount = 1.2
     * // Note that the connected wallet must have approval to transfer the tokens of the fromAddress
     * await contract.erc20.transferFrom(fromAddress, toAddress, amount);
     * ```
     * @twfeature ERC20
     */
    transferFrom: {
        (from: string, to: string, amount: string | number): Promise<Omit<{
            receipt: ethers.providers.TransactionReceipt;
            data: () => Promise<unknown>;
        }, "data">>;
        prepare: (from: string, to: string, amount: string | number) => Promise<Transaction<Omit<{
            receipt: ethers.providers.TransactionReceipt;
            data: () => Promise<unknown>;
        }, "data">>>;
    };
    /**
     * Set token allowance
     * @remarks Allows the specified `spender` wallet to transfer the given `amount` of tokens to another wallet
     * @example
     * ```javascript
     * // Address of the wallet to allow transfers from
     * const spenderAddress = "0x...";
     * // The number of tokens to give as allowance
     * const amount = 100
     * await contract.erc20.setAllowance(spenderAddress, amount);
     * ```
     * @twfeature ERC20
     */
    setAllowance: {
        (spender: string, amount: string | number): Promise<Omit<{
            receipt: ethers.providers.TransactionReceipt;
            data: () => Promise<unknown>;
        }, "data">>;
        prepare: (spender: string, amount: string | number) => Promise<Transaction<Omit<{
            receipt: ethers.providers.TransactionReceipt;
            data: () => Promise<unknown>;
        }, "data">>>;
    };
    /**
     * Transfer tokens to many wallets
     *
     * @remarks Mint tokens from the connected wallet to many wallets
     *
     * @example
     * ```javascript
     * // Data of the tokens you want to mint
     * const data = [
     *   {
     *     toAddress: "{{wallet_address}}", // Address to mint tokens to
     *     amount: 100, // How many tokens to mint to specified address
     *   },
     *  {
     *    toAddress: "0x...",
     *    amount: 100,
     *  }
     * ]
     *
     * await contract.erc20.transferBatch(data);
     * ```
     */
    transferBatch: {
        (args: {
            amount: string | number;
            toAddress: string;
        }[]): Promise<Omit<{
            receipt: ethers.providers.TransactionReceipt;
            data: () => Promise<unknown>;
        }, "data">>;
        prepare: (args: {
            amount: string | number;
            toAddress: string;
        }[]) => Promise<Transaction<Omit<{
            receipt: ethers.providers.TransactionReceipt;
            data: () => Promise<unknown>;
        }, "data">>>;
    };
    /**
     * Mint tokens
     *
     * @remarks Mint tokens to the connected wallet.
     *
     * @example
     * ```javascript
     * const amount = "1.5"; // The amount of this token you want to mint
     * await contract.erc20.mint(amount);
     * ```
     * @twfeature ERC20Mintable
     */
    mint: {
        (amount: string | number): Promise<Omit<{
            receipt: ethers.providers.TransactionReceipt;
            data: () => Promise<unknown>;
        }, "data">>;
        prepare: (amount: string | number) => Promise<Transaction<Omit<{
            receipt: ethers.providers.TransactionReceipt;
            data: () => Promise<unknown>;
        }, "data">>>;
    };
    /**
     * Mint tokens to a specific wallet
     *
     * @remarks Mint tokens to a specified address.
     *
     * @example
     * ```javascript
     * const toAddress = "{{wallet_address}}"; // Address of the wallet you want to mint the tokens to
     * const amount = "1.5"; // The amount of this token you want to mint
     * await contract.erc20.mintTo(toAddress, amount);
     * ```
     * @twfeature ERC20Mintable
     */
    mintTo: {
        (receiver: string, amount: string | number): Promise<Omit<{
            receipt: ethers.providers.TransactionReceipt;
            data: () => Promise<unknown>;
        }, "data">>;
        prepare: (receiver: string, amount: string | number) => Promise<Transaction<Omit<{
            receipt: ethers.providers.TransactionReceipt;
            data: () => Promise<unknown>;
        }, "data">>>;
    };
    /**
     * Construct a mint transaction without executing it
     * @remarks This is useful for estimating the gas cost of a mint transaction, overriding transaction options and having fine grained control over the transaction execution.
     * @param receiver - Address you want to send the token to
     * @param amount - The amount of tokens you want to mint
     *
     * @deprecated Use `contract.erc20.mint.prepare(...args)` instead
     * @twfeature ERC20Mintable
     */
    getMintTransaction(receiver: AddressOrEns, amount: Amount): Promise<Transaction>;
    /**
     * Mint tokens to many wallets
     *
     * @remarks Mint tokens to many wallets in one transaction.
     *
     * @example
     * ```javascript
     * // Data of the tokens you want to mint
     * const data = [
     *   {
     *     toAddress: "{{wallet_address}}", // Address to mint tokens to
     *     amount: 0.2, // How many tokens to mint to specified address
     *   },
     *  {
     *    toAddress: "0x...",
     *    amount: 1.4,
     *  }
     * ]
     *
     * await contract.mintBatchTo(data);
     * ```
     * @twfeature ERC20BatchMintable
     */
    mintBatchTo: {
        (args: {
            amount: string | number;
            toAddress: string;
        }[]): Promise<Omit<{
            receipt: ethers.providers.TransactionReceipt;
            data: () => Promise<unknown>;
        }, "data">>;
        prepare: (args: {
            amount: string | number;
            toAddress: string;
        }[]) => Promise<Transaction<Omit<{
            receipt: ethers.providers.TransactionReceipt;
            data: () => Promise<unknown>;
        }, "data">>>;
    };
    /**
     * Burn tokens
     *
     * @remarks Burn tokens held by the connected wallet
     *
     * @example
     * ```javascript
     * // The amount of this token you want to burn
     * const amount = 1.2;
     *
     * await contract.erc20.burn(amount);
     * ```
     * @twfeature ERC20Burnable
     */
    burn: {
        (amount: string | number): Promise<Omit<{
            receipt: ethers.providers.TransactionReceipt;
            data: () => Promise<unknown>;
        }, "data">>;
        prepare: (amount: string | number) => Promise<Transaction<Omit<{
            receipt: ethers.providers.TransactionReceipt;
            data: () => Promise<unknown>;
        }, "data">>>;
    };
    /**
     * Burn tokens from a specific wallet
     *
     * @remarks Burn tokens held by the specified wallet
     *
     * @example
     * ```javascript
     * // Address of the wallet sending the tokens
     * const holderAddress = "{{wallet_address}}";
     *
     * // The amount of this token you want to burn
     * const amount = 1.2;
     *
     * await contract.erc20.burnFrom(holderAddress, amount);
     * ```
     * @twfeature ERC20Burnable
     */
    burnFrom: {
        (holder: string, amount: string | number): Promise<Omit<{
            receipt: ethers.providers.TransactionReceipt;
            data: () => Promise<unknown>;
        }, "data">>;
        prepare: (holder: string, amount: string | number) => Promise<Transaction<Omit<{
            receipt: ethers.providers.TransactionReceipt;
            data: () => Promise<unknown>;
        }, "data">>>;
    };
    /**
     * Claim tokens
     *
     * @remarks Let the specified wallet claim Tokens.
     *
     * @example
     * ```javascript
     * const address = "{{wallet_address}}"; // address of the wallet you want to claim the NFTs
     * const quantity = 42.69; // how many tokens you want to claim
     *
     * const tx = await contract.erc20.claim(address, quantity);
     * const receipt = tx.receipt; // the transaction receipt
     * ```
     *
     * @param destinationAddress - Address you want to send the token to
     * @param amount - Quantity of the tokens you want to claim
     * @param checkERC20Allowance - Optional, check if the wallet has enough ERC20 allowance to claim the tokens, and if not, approve the transfer
     * @param claimData
     * @returns - The transaction receipt
     * @twfeature ERC20ClaimPhasesV2 | ERC20ClaimPhasesV1 | ERC20ClaimConditionsV2 | ERC20ClaimConditionsV1
     */
    claim: {
        (amount: string | number, options?: ClaimOptions | undefined): Promise<Omit<{
            receipt: ethers.providers.TransactionReceipt;
            data: () => Promise<unknown>;
        }, "data">>;
        prepare: (amount: string | number, options?: ClaimOptions | undefined) => Promise<Transaction<Omit<{
            receipt: ethers.providers.TransactionReceipt;
            data: () => Promise<unknown>;
        }, "data">>>;
    };
    /**
     * Claim tokens to a specific wallet
     *
     * @remarks Let the specified wallet claim Tokens.
     *
     * @example
     * ```javascript
     * const address = "{{wallet_address}}"; // address of the wallet you want to claim the NFTs
     * const quantity = 42.69; // how many tokens you want to claim
     *
     * const tx = await contract.erc20.claim(address, quantity);
     * const receipt = tx.receipt; // the transaction receipt
     * ```
     *
     * @param destinationAddress - Address you want to send the token to
     * @param amount - Quantity of the tokens you want to claim
     * @param checkERC20Allowance - Optional, check if the wallet has enough ERC20 allowance to claim the tokens, and if not, approve the transfer
     * @param claimData
     * @returns - The transaction receipt
     * @twfeature ERC20ClaimPhasesV2 | ERC20ClaimPhasesV1 | ERC20ClaimConditionsV2 | ERC20ClaimConditionsV1
     */
    claimTo: {
        (destinationAddress: string, amount: string | number, options?: ClaimOptions | undefined): Promise<Omit<{
            receipt: ethers.providers.TransactionReceipt;
            data: () => Promise<unknown>;
        }, "data">>;
        prepare: (destinationAddress: string, amount: string | number, options?: ClaimOptions | undefined) => Promise<Transaction<Omit<{
            receipt: ethers.providers.TransactionReceipt;
            data: () => Promise<unknown>;
        }, "data">>>;
    };
    /**
     * Configure claim conditions
     * @remarks Define who can claim NFTs in the collection, when and how many.
     * @example
     * ```javascript
     * const presaleStartTime = new Date();
     * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
     * const claimConditions = [
     *   {
     *     startTime: presaleStartTime, // start the presale now
     *     maxClaimableSupply: 2, // limit how many mints for this presale
     *     price: 0.01, // presale price
     *     snapshot: ['0x...', '0x...'], // limit minting to only certain addresses
     *   },
     *   {
     *     startTime: publicSaleStartTime, // 24h after presale, start public sale
     *     price: 0.08, // public sale price
     *   }
     * ]);
     * await contract.erc20.claimConditions.set(claimConditions);
     * ```
     * @twfeature ERC20ClaimPhasesV2 | ERC20ClaimPhasesV1 | ERC20ClaimConditionsV2 | ERC20ClaimConditionsV1
     */
    get claimConditions(): DropClaimConditions<BaseDropERC20>;
    /**
     * Mint with signature
     * @remarks Generate dynamic tokens with your own signature, and let others mint them using that signature.
     * @example
     * ```javascript
     * // see how to craft a payload to sign in the `contract.erc20.signature.generate()` documentation
     * const signedPayload = contract.erc20.signature().generate(payload);
     *
     * // now the payload can be used to mint tokens
     * const tx = contract.erc20.signature.mint(signedPayload);
     * ```
     * @twfeature ERC20SignatureMintable
     */
    get signature(): Erc20SignatureMintable;
    /** ******************************
     * PRIVATE FUNCTIONS
     *******************************/
    /**
     * returns the wei amount from a token amount
     * @internal
     * @param amount
     */
    normalizeAmount(amount: Amount): Promise<BigNumber>;
    /**
     * @internal
     */
    getValue(value: BigNumberish): Promise<CurrencyValue>;
    private detectErc20Mintable;
    private detectErc20Burnable;
    private detectErc20Droppable;
    private detectErc20SignatureMintable;
}
export declare class Erc20Burnable implements DetectableFeature {
    featureName: "ERC20Burnable";
    private erc20;
    private contractWrapper;
    constructor(erc20: Erc20, contractWrapper: ContractWrapper<IBurnableERC20>);
    /**
     * Burn Tokens
     *
     * @remarks Burn tokens held by the connected wallet
     *
     * @example
     * ```javascript
     * // The amount of this token you want to burn
     * const amount = 1.2;
     *
     * await contract.token.burn.tokens(amount);
     * ```
     */
    tokens: {
        (amount: string | number): Promise<Omit<{
            receipt: ethers.providers.TransactionReceipt;
            data: () => Promise<unknown>;
        }, "data">>;
        prepare: (amount: string | number) => Promise<Transaction<Omit<{
            receipt: ethers.providers.TransactionReceipt;
            data: () => Promise<unknown>;
        }, "data">>>;
    };
    /**
     * Burn Tokens
     *
     * @remarks Burn tokens held by the specified wallet
     *
     * @example
     * ```javascript
     * // Address of the wallet sending the tokens
     * const holderAddress = "{{wallet_address}}";
     *
     * // The amount of this token you want to burn
     * const amount = 1.2;
     *
     * await contract.token.burn.from(holderAddress, amount);
     * ```
     */
    from: {
        (holder: string, amount: string | number): Promise<Omit<{
            receipt: ethers.providers.TransactionReceipt;
            data: () => Promise<unknown>;
        }, "data">>;
        prepare: (holder: string, amount: string | number) => Promise<Transaction<Omit<{
            receipt: ethers.providers.TransactionReceipt;
            data: () => Promise<unknown>;
        }, "data">>>;
    };
}
/**
 * Configure and claim ERC20 tokens
 * @remarks Manage claim phases and claim ERC20 tokens that have been lazily minted.
 * @example
 * ```javascript
 * const contract = await sdk.getContract("{{contract_address}}");
 * await contract.token.drop.claim.to("0x...", quantity);
 * ```
 */
export declare class Erc20Droppable {
    /**
     * Configure claim conditions
     * @remarks Define who can claim NFTs in the collection, when and how many.
     * @example
     * ```javascript
     * const presaleStartTime = new Date();
     * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
     * const claimConditions = [
     *   {
     *     startTime: presaleStartTime, // start the presale now
     *     maxClaimableSupply: 2, // limit how many mints for this presale
     *     price: 0.01, // presale price
     *     snapshot: ['0x...', '0x...'], // limit minting to only certain addresses
     *   },
     *   {
     *     startTime: publicSaleStartTime, // 24h after presale, start public sale
     *     price: 0.08, // public sale price
     *   }
     * ]);
     * await contract.nft.drop.claim.conditions.set(claimConditions);
     * ```
     */
    claim: Erc20ClaimableWithConditions;
    private contractWrapper;
    private erc20;
    private storage;
    constructor(erc20: Erc20, contractWrapper: ContractWrapper<BaseDropERC20>, storage: ThirdwebStorage);
}
/**
 * Mint ERC20 Tokens
 * @remarks Token minting functionality that handles unit parsing for you.
 * @example
 * ```javascript
 * const contract = await sdk.getContract("{{contract_address}}");
 * await contract.nft.mint.to(walletAddress, nftMetadata);
 * ```
 * @public
 */
export declare class Erc20Mintable implements DetectableFeature {
    featureName: "ERC20Mintable";
    private contractWrapper;
    private erc20;
    /**
     * Batch mint Tokens to many addresses
     */
    batch: Erc20BatchMintable | undefined;
    constructor(erc20: Erc20, contractWrapper: ContractWrapper<IMintableERC20>);
    /**
     * Mint Tokens
     *
     * @remarks Mint tokens to a specified address.
     *
     * @example
     * ```javascript
     * const toAddress = "{{wallet_address}}"; // Address of the wallet you want to mint the tokens to
     * const amount = "1.5"; // The amount of this token you want to mint
     * await contract.token.mint.to(toAddress, amount);
     * ```
     */
    to: {
        (to: string, amount: string | number): Promise<Omit<{
            receipt: ethers.providers.TransactionReceipt;
            data: () => Promise<unknown>;
        }, "data">>;
        prepare: (to: string, amount: string | number) => Promise<Transaction<Omit<{
            receipt: ethers.providers.TransactionReceipt;
            data: () => Promise<unknown>;
        }, "data">>>;
    };
    /**
     * @deprecated Use `contract.erc20.mint.prepare(...args)` instead
     */
    getMintTransaction(to: AddressOrEns, amount: Amount): Promise<Transaction>;
    private detectErc20BatchMintable;
}
/**
 * Enables generating ERC20 Tokens with rules and an associated signature, which can then be minted by anyone securely
 * @public
 */
export declare class Erc20SignatureMintable implements DetectableFeature {
    featureName: "ERC20SignatureMintable";
    private contractWrapper;
    private roles;
    constructor(contractWrapper: ContractWrapper<TokenERC20>, roles?: ContractRoles<TokenERC20, (typeof TokenInitializer.roles)[number]>);
    /**
     * Mint tokens from a signature
     *
     * @remarks Mint a certain amount of tokens from a previously generated signature.
     *
     * @example
     * ```javascript
     * // see how to craft a payload to sign in the `generate()` documentation
     * const signedPayload = contract.erc20.signature.generate(payload);
     *
     * // Use the signed payload to mint the tokens
     * const tx = contract.erc20.signature.mint(signedPayload);
     * ```
     * @param signedPayload - the previously generated payload and signature with {@link Erc20SignatureMintable.generate}
     * @twfeature ERC20SignatureMintable
     */
    mint: {
        (signedPayload: SignedPayload20): Promise<Omit<{
            receipt: ethers.providers.TransactionReceipt;
            data: () => Promise<unknown>;
        }, "data">>;
        prepare: (signedPayload: SignedPayload20) => Promise<Transaction<Omit<{
            receipt: ethers.providers.TransactionReceipt;
            data: () => Promise<unknown>;
        }, "data">>>;
    };
    /**
     * Mint any number of generated tokens signatures at once
     * @remarks Mint multiple token signatures in one transaction. Note that this is only possible for free mints (cannot batch mints with a price attached to it for security reasons)
     * @param signedPayloads - the array of signed payloads to mint
     * @twfeature ERC20SignatureMintable
     */
    mintBatch: {
        (signedPayloads: SignedPayload20[]): Promise<Omit<{
            receipt: ethers.providers.TransactionReceipt;
            data: () => Promise<unknown>;
        }, "data">>;
        prepare: (signedPayloads: SignedPayload20[]) => Promise<Transaction<Omit<{
            receipt: ethers.providers.TransactionReceipt;
            data: () => Promise<unknown>;
        }, "data">>>;
    };
    /**
     * Verify that a payload is correctly signed
     * @param signedPayload - the payload to verify
     * @twfeature ERC20SignatureMintable
     *
     * ```javascript
     * const startTime = new Date();
     * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
     * const payload = {
     *   quantity: 4.2, // The quantity of tokens to be minted
     *   to: {{wallet_address}}, // Who will receive the tokens
     *   price: 0.5, // the price to pay for minting those tokens
     *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with
     *   mintStartTime: startTime, // can mint anytime from now
     *   mintEndTime: endTime, // to 24h from now,
     *   primarySaleRecipient: "0x...", // custom sale recipient for this token mint
     * };
     *
     * const signedPayload = await contract.erc20.signature.generate(payload);
     * // Now you can verify if the signed payload is valid
     * const isValid = await contract.erc20.signature.verify(signedPayload);
     * ```
     */
    verify(signedPayload: SignedPayload20): Promise<boolean>;
    /**
     * Generate a signature that can be used to mint a certain amount of tokens
     *
     * @remarks Takes in a quantity of tokens, some conditions for how it can be minted and signs it with your private key. The generated signature can then be used to mint those tokens using the exact payload and signature generated.
     *
     * @example
     * ```javascript
     * const startTime = new Date();
     * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
     * const payload = {
     *   quantity: 4.2, // The quantity of tokens to be minted
     *   to: {{wallet_address}}, // Who will receive the tokens
     *   price: 0.5, // the price to pay for minting those tokens
     *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with
     *   mintStartTime: startTime, // can mint anytime from now
     *   mintEndTime: endTime, // to 24h from now,
     *   primarySaleRecipient: "0x...", // custom sale recipient for this token mint
     * };
     *
     * const signedPayload = await contract.erc20.signature.generate(payload);
     * // now anyone can use these to mint the NFT using `contract.erc20.signature.mint(signedPayload)`
     * ```
     * @param mintRequest - the payload to sign
     * @returns the signed payload and the corresponding signature
     * @twfeature ERC20SignatureMintable
     */
    generate(mintRequest: PayloadToSign20): Promise<SignedPayload20>;
    /**
     * Generate a batch of signatures that can be used to mint many token signatures.
     *
     * @remarks See {@link Erc20SignatureMintable.generate}
     *
     * @param payloadsToSign - the payloads to sign
     * @returns an array of payloads and signatures
     * @twfeature ERC20SignatureMintable
     */
    generateBatch(payloadsToSign: PayloadToSign20[]): Promise<SignedPayload20[]>;
    /** ******************************
     * PRIVATE FUNCTIONS
     *******************************/
    /**
     * Maps a payload to the format expected by the contract
     *
     * @internal
     *
     * @param mintRequest - The payload to map.
     * @returns - The mapped payload.
     */
    private mapPayloadToContractStruct;
}
/**
 * Configure and claim ERC20 tokens
 * @remarks Manage claim phases and claim ERC20 tokens that have been lazily minted.
 * @example
 * ```javascript
 * const contract = await sdk.getContract("{{contract_address}}");
 * await contract.token.drop.claim.to("0x...", quantity);
 * ```
 */
export declare class Erc20ClaimableWithConditions implements DetectableFeature {
    featureName: "ERC20ClaimConditionsV2";
    /**
     * Configure claim conditions
     * @remarks Define who can claim NFTs in the collection, when and how many.
     * @example
     * ```javascript
     * const presaleStartTime = new Date();
     * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
     * const claimConditions = [
     *   {
     *     startTime: presaleStartTime, // start the presale now
     *     maxClaimableSupply: 2, // limit how many mints for this presale
     *     price: 0.01, // presale price
     *     snapshot: ['0x...', '0x...'], // limit minting to only certain addresses
     *   },
     *   {
     *     startTime: publicSaleStartTime, // 24h after presale, start public sale
     *     price: 0.08, // public sale price
     *   }
     * ]);
     * await contract.token.drop.claim.conditions.set(claimConditions);
     * ```
     */
    conditions: DropClaimConditions<BaseDropERC20>;
    private contractWrapper;
    private erc20;
    private storage;
    constructor(erc20: Erc20, contractWrapper: ContractWrapper<BaseDropERC20>, storage: ThirdwebStorage);
    /**
     * Claim a certain amount of tokens to a specific Wallet
     *
     * @remarks Let the specified wallet claim Tokens.
     *
     * @example
     * ```javascript
     * const address = "{{wallet_address}}"; // address of the wallet you want to claim the NFTs
     * const quantity = 42.69; // how many tokens you want to claim
     *
     * const tx = await contract.token.drop.claim.to(address, quantity);
     * const receipt = tx.receipt; // the transaction receipt
     * ```
     *
     * @param destinationAddress - Address you want to send the token to
     * @param amount - Quantity of the tokens you want to claim
     * @param checkERC20Allowance - Optional, check if the wallet has enough ERC20 allowance to claim the tokens, and if not, approve the transfer
     * @param claimData
     * @returns - The transaction receipt
     */
    to: {
        (destinationAddress: string, amount: string | number, options?: ClaimOptions | undefined): Promise<Omit<{
            receipt: ethers.providers.TransactionReceipt;
            data: () => Promise<unknown>;
        }, "data">>;
        prepare: (destinationAddress: string, amount: string | number, options?: ClaimOptions | undefined) => Promise<Transaction<Omit<{
            receipt: ethers.providers.TransactionReceipt;
            data: () => Promise<unknown>;
        }, "data">>>;
    };
}
/**
 * Mint Many ERC20 Tokens at once
 * @remarks Token batch minting functionality that handles unit parsing for you.
 * @example
 * ```javascript
 * const contract = await sdk.getContract("{{contract_address}}");
 * await contract.token.mint.batch.to(walletAddress, [nftMetadata1, nftMetadata2, ...]);
 * ```
 * @public
 */
export declare class Erc20BatchMintable implements DetectableFeature {
    featureName: "ERC20BatchMintable";
    private contractWrapper;
    private erc20;
    constructor(erc20: Erc20, contractWrapper: ContractWrapper<IMintableERC20 & IMulticall>);
    /**
     * Mint Tokens To Many Wallets
     *
     * @remarks Mint tokens to many wallets in one transaction.
     *
     * @example
     * ```javascript
     * // Data of the tokens you want to mint
     * const data = [
     *   {
     *     toAddress: "{{wallet_address}}", // Address to mint tokens to
     *     amount: 0.2, // How many tokens to mint to specified address
     *   },
     *  {
     *    toAddress: "0x...",
     *    amount: 1.4,
     *  }
     * ]
     *
     * await contract.token.mint.batch(data);
     * ```
     */
    to: {
        (args: {
            amount: string | number;
            toAddress: string;
        }[]): Promise<Omit<{
            receipt: ethers.providers.TransactionReceipt;
            data: () => Promise<unknown>;
        }, "data">>;
        prepare: (args: {
            amount: string | number;
            toAddress: string;
        }[]) => Promise<Transaction<Omit<{
            receipt: ethers.providers.TransactionReceipt;
            data: () => Promise<unknown>;
        }, "data">>>;
    };
}
//# sourceMappingURL=erc-20.d.ts.map