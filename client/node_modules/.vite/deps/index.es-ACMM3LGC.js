import {
  HttpConnection,
  esm_default
} from "./chunk-JMERBMA5.js";
import {
  IEvents,
  RELAY_JSONRPC,
  encodeIss,
  esm_exports,
  generateKeyPair,
  init_esm,
  require_browser,
  require_browser2,
  require_chacha20poly1305,
  require_cjs,
  require_cjs2,
  require_hkdf,
  require_lodash,
  require_random,
  require_sha256,
  require_x25519,
  signJWT
} from "./chunk-BENPVMCZ.js";
import "./chunk-BL5AGTOU.js";
import {
  IJsonRpcProvider,
  JsonRpcProvider,
  detect,
  esm_exports as esm_exports2,
  formatJsonRpcError,
  formatJsonRpcRequest,
  formatJsonRpcResult,
  init_es,
  init_esm as init_esm2,
  init_esm3,
  isJsonRpcError,
  isJsonRpcRequest,
  isJsonRpcResponse,
  isJsonRpcResult,
  isLocalhostUrl,
  isWsUrl,
  parseConnectionError,
  require_cjs as require_cjs3,
  require_cjs2 as require_cjs4,
  require_decode_uri_component,
  require_filter_obj,
  require_split_on_first,
  require_strict_uri_encode,
  require_tslib,
  safeJsonParse,
  safeJsonStringify
} from "./chunk-SXM3NUOY.js";
import "./chunk-CY63Z6PF.js";
import {
  require_events
} from "./chunk-L4L7HN5R.js";
import {
  concat,
  fromString,
  toString
} from "./chunk-XUXNDKXO.js";
import "./chunk-KSBPR6CT.js";
import "./chunk-XLOOGUEN.js";
import "./chunk-2O4376VB.js";
import {
  global,
  import_process,
  init_shim
} from "./chunk-ZGMFR26H.js";
import {
  __commonJS,
  __toCommonJS,
  __toESM
} from "./chunk-IKJM6GHQ.js";

// node_modules/@walletconnect/ethereum-provider/node_modules/query-string/index.js
var require_query_string = __commonJS({
  "node_modules/@walletconnect/ethereum-provider/node_modules/query-string/index.js"(exports) {
    "use strict";
    init_shim();
    var strictUriEncode = require_strict_uri_encode();
    var decodeComponent = require_decode_uri_component();
    var splitOnFirst = require_split_on_first();
    var filterObject = require_filter_obj();
    var isNullOrUndefined = (value) => value === null || value === void 0;
    var encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case "index":
          return (key) => (result, value) => {
            const index = result.length;
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), "[", index, "]"].join("")];
            }
            return [
              ...result,
              [encode(key, options), "[", encode(index, options), "]=", encode(value, options)].join("")
            ];
          };
        case "bracket":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), "[]"].join("")];
            }
            return [...result, [encode(key, options), "[]=", encode(value, options)].join("")];
          };
        case "colon-list-separator":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), ":list="].join("")];
            }
            return [...result, [encode(key, options), ":list=", encode(value, options)].join("")];
          };
        case "comma":
        case "separator":
        case "bracket-separator": {
          const keyValueSep = options.arrayFormat === "bracket-separator" ? "[]=" : "=";
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            value = value === null ? "" : value;
            if (result.length === 0) {
              return [[encode(key, options), keyValueSep, encode(value, options)].join("")];
            }
            return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
          };
        }
        default:
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, encode(key, options)];
            }
            return [...result, [encode(key, options), "=", encode(value, options)].join("")];
          };
      }
    }
    function parserForArrayFormat(options) {
      let result;
      switch (options.arrayFormat) {
        case "index":
          return (key, value, accumulator) => {
            result = /\[(\d*)\]$/.exec(key);
            key = key.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = {};
            }
            accumulator[key][result[1]] = value;
          };
        case "bracket":
          return (key, value, accumulator) => {
            result = /(\[\])$/.exec(key);
            key = key.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "colon-list-separator":
          return (key, value, accumulator) => {
            result = /(:list)$/.exec(key);
            key = key.replace(/:list$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "comma":
        case "separator":
          return (key, value, accumulator) => {
            const isArray = typeof value === "string" && value.includes(options.arrayFormatSeparator);
            const isEncodedArray = typeof value === "string" && !isArray && decode(value, options).includes(options.arrayFormatSeparator);
            value = isEncodedArray ? decode(value, options) : value;
            const newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item) => decode(item, options)) : value === null ? value : decode(value, options);
            accumulator[key] = newValue;
          };
        case "bracket-separator":
          return (key, value, accumulator) => {
            const isArray = /(\[\])$/.test(key);
            key = key.replace(/\[\]$/, "");
            if (!isArray) {
              accumulator[key] = value ? decode(value, options) : value;
              return;
            }
            const arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map((item) => decode(item, options));
            if (accumulator[key] === void 0) {
              accumulator[key] = arrayValue;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], arrayValue);
          };
        default:
          return (key, value, accumulator) => {
            if (accumulator[key] === void 0) {
              accumulator[key] = value;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
      }
    }
    function validateArrayFormatSeparator(value) {
      if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
      }
    }
    function encode(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
      }
      return value;
    }
    function decode(value, options) {
      if (options.decode) {
        return decodeComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }
      if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort((a3, b4) => Number(a3) - Number(b4)).map((key) => input[key]);
      }
      return input;
    }
    function removeHash(input) {
      const hashStart = input.indexOf("#");
      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }
      return input;
    }
    function getHash(url) {
      let hash = "";
      const hashStart = url.indexOf("#");
      if (hashStart !== -1) {
        hash = url.slice(hashStart);
      }
      return hash;
    }
    function extract(input) {
      input = removeHash(input);
      const queryStart = input.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return input.slice(queryStart + 1);
    }
    function parseValue(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        value = value.toLowerCase() === "true";
      }
      return value;
    }
    function parse4(query, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const formatter = parserForArrayFormat(options);
      const ret = /* @__PURE__ */ Object.create(null);
      if (typeof query !== "string") {
        return ret;
      }
      query = query.trim().replace(/^[?#&]/, "");
      if (!query) {
        return ret;
      }
      for (const param of query.split("&")) {
        if (param === "") {
          continue;
        }
        let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
        value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options.arrayFormat) ? value : decode(value, options);
        formatter(decode(key, options), value, ret);
      }
      for (const key of Object.keys(ret)) {
        const value = ret[key];
        if (typeof value === "object" && value !== null) {
          for (const k3 of Object.keys(value)) {
            value[k3] = parseValue(value[k3], options);
          }
        } else {
          ret[key] = parseValue(value, options);
        }
      }
      if (options.sort === false) {
        return ret;
      }
      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
        const value = ret[key];
        if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
          result[key] = keysSorter(value);
        } else {
          result[key] = value;
        }
        return result;
      }, /* @__PURE__ */ Object.create(null));
    }
    exports.extract = extract;
    exports.parse = parse4;
    exports.stringify = (object, options) => {
      if (!object) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const shouldFilter = (key) => options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === "";
      const formatter = encoderForArrayFormat(options);
      const objectCopy = {};
      for (const key of Object.keys(object)) {
        if (!shouldFilter(key)) {
          objectCopy[key] = object[key];
        }
      }
      const keys = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys.sort(options.sort);
      }
      return keys.map((key) => {
        const value = object[key];
        if (value === void 0) {
          return "";
        }
        if (value === null) {
          return encode(key, options);
        }
        if (Array.isArray(value)) {
          if (value.length === 0 && options.arrayFormat === "bracket-separator") {
            return encode(key, options) + "[]";
          }
          return value.reduce(formatter(key), []).join("&");
        }
        return encode(key, options) + "=" + encode(value, options);
      }).filter((x5) => x5.length > 0).join("&");
    };
    exports.parseUrl = (url, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url_, hash] = splitOnFirst(url, "#");
      return Object.assign(
        {
          url: url_.split("?")[0] || "",
          query: parse4(extract(url), options)
        },
        options && options.parseFragmentIdentifier && hash ? { fragmentIdentifier: decode(hash, options) } : {}
      );
    };
    exports.stringifyUrl = (object, options) => {
      options = Object.assign({
        encode: true,
        strict: true,
        [encodeFragmentIdentifier]: true
      }, options);
      const url = removeHash(object.url).split("?")[0] || "";
      const queryFromUrl = exports.extract(object.url);
      const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
      const query = Object.assign(parsedQueryFromUrl, object.query);
      let queryString = exports.stringify(query, options);
      if (queryString) {
        queryString = `?${queryString}`;
      }
      let hash = getHash(object.url);
      if (object.fragmentIdentifier) {
        hash = `#${options[encodeFragmentIdentifier] ? encode(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;
      }
      return `${url}${queryString}${hash}`;
    };
    exports.pick = (input, filter, options) => {
      options = Object.assign({
        parseFragmentIdentifier: true,
        [encodeFragmentIdentifier]: false
      }, options);
      const { url, query, fragmentIdentifier } = exports.parseUrl(input, options);
      return exports.stringifyUrl({
        url,
        query: filterObject(query, filter),
        fragmentIdentifier
      }, options);
    };
    exports.exclude = (input, filter, options) => {
      const exclusionFilter = Array.isArray(filter) ? (key) => !filter.includes(key) : (key, value) => !filter(key, value);
      return exports.pick(input, exclusionFilter, options);
    };
  }
});

// node_modules/@walletconnect/sign-client/node_modules/@walletconnect/heartbeat/dist/cjs/types/heartbeat.js
var require_heartbeat = __commonJS({
  "node_modules/@walletconnect/sign-client/node_modules/@walletconnect/heartbeat/dist/cjs/types/heartbeat.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IHeartBeat = void 0;
    var events_1 = (init_esm(), __toCommonJS(esm_exports));
    var IHeartBeat = class extends events_1.IEvents {
      constructor(opts) {
        super();
      }
    };
    exports.IHeartBeat = IHeartBeat;
  }
});

// node_modules/@walletconnect/sign-client/node_modules/@walletconnect/heartbeat/dist/cjs/types/index.js
var require_types = __commonJS({
  "node_modules/@walletconnect/sign-client/node_modules/@walletconnect/heartbeat/dist/cjs/types/index.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_heartbeat(), exports);
  }
});

// node_modules/@walletconnect/sign-client/node_modules/@walletconnect/heartbeat/dist/cjs/constants/heartbeat.js
var require_heartbeat2 = __commonJS({
  "node_modules/@walletconnect/sign-client/node_modules/@walletconnect/heartbeat/dist/cjs/constants/heartbeat.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HEARTBEAT_EVENTS = exports.HEARTBEAT_INTERVAL = void 0;
    var time_1 = require_cjs();
    exports.HEARTBEAT_INTERVAL = time_1.FIVE_SECONDS;
    exports.HEARTBEAT_EVENTS = {
      pulse: "heartbeat_pulse"
    };
  }
});

// node_modules/@walletconnect/sign-client/node_modules/@walletconnect/heartbeat/dist/cjs/constants/index.js
var require_constants = __commonJS({
  "node_modules/@walletconnect/sign-client/node_modules/@walletconnect/heartbeat/dist/cjs/constants/index.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_heartbeat2(), exports);
  }
});

// node_modules/@walletconnect/sign-client/node_modules/@walletconnect/heartbeat/dist/cjs/heartbeat.js
var require_heartbeat3 = __commonJS({
  "node_modules/@walletconnect/sign-client/node_modules/@walletconnect/heartbeat/dist/cjs/heartbeat.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HeartBeat = void 0;
    var tslib_1 = require_tslib();
    var events_1 = require_events();
    var time_1 = require_cjs();
    var types_1 = require_types();
    var constants_1 = require_constants();
    var HeartBeat = class extends types_1.IHeartBeat {
      constructor(opts) {
        super(opts);
        this.events = new events_1.EventEmitter();
        this.interval = constants_1.HEARTBEAT_INTERVAL;
        this.interval = (opts === null || opts === void 0 ? void 0 : opts.interval) || constants_1.HEARTBEAT_INTERVAL;
      }
      static init(opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const heartbeat = new HeartBeat(opts);
          yield heartbeat.init();
          return heartbeat;
        });
      }
      init() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          yield this.initialize();
        });
      }
      stop() {
        clearInterval(this.intervalRef);
      }
      on(event, listener) {
        this.events.on(event, listener);
      }
      once(event, listener) {
        this.events.once(event, listener);
      }
      off(event, listener) {
        this.events.off(event, listener);
      }
      removeListener(event, listener) {
        this.events.removeListener(event, listener);
      }
      initialize() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          this.intervalRef = setInterval(() => this.pulse(), time_1.toMiliseconds(this.interval));
        });
      }
      pulse() {
        this.events.emit(constants_1.HEARTBEAT_EVENTS.pulse);
      }
    };
    exports.HeartBeat = HeartBeat;
  }
});

// node_modules/@walletconnect/sign-client/node_modules/@walletconnect/heartbeat/dist/cjs/index.js
var require_cjs5 = __commonJS({
  "node_modules/@walletconnect/sign-client/node_modules/@walletconnect/heartbeat/dist/cjs/index.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_heartbeat3(), exports);
    tslib_1.__exportStar(require_types(), exports);
    tslib_1.__exportStar(require_constants(), exports);
  }
});

// node_modules/@walletconnect/sign-client/node_modules/query-string/index.js
var require_query_string2 = __commonJS({
  "node_modules/@walletconnect/sign-client/node_modules/query-string/index.js"(exports) {
    "use strict";
    init_shim();
    var strictUriEncode = require_strict_uri_encode();
    var decodeComponent = require_decode_uri_component();
    var splitOnFirst = require_split_on_first();
    var filterObject = require_filter_obj();
    var isNullOrUndefined = (value) => value === null || value === void 0;
    var encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case "index":
          return (key) => (result, value) => {
            const index = result.length;
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), "[", index, "]"].join("")];
            }
            return [
              ...result,
              [encode(key, options), "[", encode(index, options), "]=", encode(value, options)].join("")
            ];
          };
        case "bracket":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), "[]"].join("")];
            }
            return [...result, [encode(key, options), "[]=", encode(value, options)].join("")];
          };
        case "colon-list-separator":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), ":list="].join("")];
            }
            return [...result, [encode(key, options), ":list=", encode(value, options)].join("")];
          };
        case "comma":
        case "separator":
        case "bracket-separator": {
          const keyValueSep = options.arrayFormat === "bracket-separator" ? "[]=" : "=";
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            value = value === null ? "" : value;
            if (result.length === 0) {
              return [[encode(key, options), keyValueSep, encode(value, options)].join("")];
            }
            return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
          };
        }
        default:
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, encode(key, options)];
            }
            return [...result, [encode(key, options), "=", encode(value, options)].join("")];
          };
      }
    }
    function parserForArrayFormat(options) {
      let result;
      switch (options.arrayFormat) {
        case "index":
          return (key, value, accumulator) => {
            result = /\[(\d*)\]$/.exec(key);
            key = key.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = {};
            }
            accumulator[key][result[1]] = value;
          };
        case "bracket":
          return (key, value, accumulator) => {
            result = /(\[\])$/.exec(key);
            key = key.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "colon-list-separator":
          return (key, value, accumulator) => {
            result = /(:list)$/.exec(key);
            key = key.replace(/:list$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "comma":
        case "separator":
          return (key, value, accumulator) => {
            const isArray = typeof value === "string" && value.includes(options.arrayFormatSeparator);
            const isEncodedArray = typeof value === "string" && !isArray && decode(value, options).includes(options.arrayFormatSeparator);
            value = isEncodedArray ? decode(value, options) : value;
            const newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item) => decode(item, options)) : value === null ? value : decode(value, options);
            accumulator[key] = newValue;
          };
        case "bracket-separator":
          return (key, value, accumulator) => {
            const isArray = /(\[\])$/.test(key);
            key = key.replace(/\[\]$/, "");
            if (!isArray) {
              accumulator[key] = value ? decode(value, options) : value;
              return;
            }
            const arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map((item) => decode(item, options));
            if (accumulator[key] === void 0) {
              accumulator[key] = arrayValue;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], arrayValue);
          };
        default:
          return (key, value, accumulator) => {
            if (accumulator[key] === void 0) {
              accumulator[key] = value;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
      }
    }
    function validateArrayFormatSeparator(value) {
      if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
      }
    }
    function encode(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
      }
      return value;
    }
    function decode(value, options) {
      if (options.decode) {
        return decodeComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }
      if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort((a3, b4) => Number(a3) - Number(b4)).map((key) => input[key]);
      }
      return input;
    }
    function removeHash(input) {
      const hashStart = input.indexOf("#");
      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }
      return input;
    }
    function getHash(url) {
      let hash = "";
      const hashStart = url.indexOf("#");
      if (hashStart !== -1) {
        hash = url.slice(hashStart);
      }
      return hash;
    }
    function extract(input) {
      input = removeHash(input);
      const queryStart = input.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return input.slice(queryStart + 1);
    }
    function parseValue(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        value = value.toLowerCase() === "true";
      }
      return value;
    }
    function parse4(query, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const formatter = parserForArrayFormat(options);
      const ret = /* @__PURE__ */ Object.create(null);
      if (typeof query !== "string") {
        return ret;
      }
      query = query.trim().replace(/^[?#&]/, "");
      if (!query) {
        return ret;
      }
      for (const param of query.split("&")) {
        if (param === "") {
          continue;
        }
        let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
        value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options.arrayFormat) ? value : decode(value, options);
        formatter(decode(key, options), value, ret);
      }
      for (const key of Object.keys(ret)) {
        const value = ret[key];
        if (typeof value === "object" && value !== null) {
          for (const k3 of Object.keys(value)) {
            value[k3] = parseValue(value[k3], options);
          }
        } else {
          ret[key] = parseValue(value, options);
        }
      }
      if (options.sort === false) {
        return ret;
      }
      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
        const value = ret[key];
        if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
          result[key] = keysSorter(value);
        } else {
          result[key] = value;
        }
        return result;
      }, /* @__PURE__ */ Object.create(null));
    }
    exports.extract = extract;
    exports.parse = parse4;
    exports.stringify = (object, options) => {
      if (!object) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const shouldFilter = (key) => options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === "";
      const formatter = encoderForArrayFormat(options);
      const objectCopy = {};
      for (const key of Object.keys(object)) {
        if (!shouldFilter(key)) {
          objectCopy[key] = object[key];
        }
      }
      const keys = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys.sort(options.sort);
      }
      return keys.map((key) => {
        const value = object[key];
        if (value === void 0) {
          return "";
        }
        if (value === null) {
          return encode(key, options);
        }
        if (Array.isArray(value)) {
          if (value.length === 0 && options.arrayFormat === "bracket-separator") {
            return encode(key, options) + "[]";
          }
          return value.reduce(formatter(key), []).join("&");
        }
        return encode(key, options) + "=" + encode(value, options);
      }).filter((x5) => x5.length > 0).join("&");
    };
    exports.parseUrl = (url, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url_, hash] = splitOnFirst(url, "#");
      return Object.assign(
        {
          url: url_.split("?")[0] || "",
          query: parse4(extract(url), options)
        },
        options && options.parseFragmentIdentifier && hash ? { fragmentIdentifier: decode(hash, options) } : {}
      );
    };
    exports.stringifyUrl = (object, options) => {
      options = Object.assign({
        encode: true,
        strict: true,
        [encodeFragmentIdentifier]: true
      }, options);
      const url = removeHash(object.url).split("?")[0] || "";
      const queryFromUrl = exports.extract(object.url);
      const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
      const query = Object.assign(parsedQueryFromUrl, object.query);
      let queryString = exports.stringify(query, options);
      if (queryString) {
        queryString = `?${queryString}`;
      }
      let hash = getHash(object.url);
      if (object.fragmentIdentifier) {
        hash = `#${options[encodeFragmentIdentifier] ? encode(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;
      }
      return `${url}${queryString}${hash}`;
    };
    exports.pick = (input, filter, options) => {
      options = Object.assign({
        parseFragmentIdentifier: true,
        [encodeFragmentIdentifier]: false
      }, options);
      const { url, query, fragmentIdentifier } = exports.parseUrl(input, options);
      return exports.stringifyUrl({
        url,
        query: filterObject(query, filter),
        fragmentIdentifier
      }, options);
    };
    exports.exclude = (input, filter, options) => {
      const exclusionFilter = Array.isArray(filter) ? (key) => !filter.includes(key) : (key, value) => !filter(key, value);
      return exports.pick(input, exclusionFilter, options);
    };
  }
});

// node_modules/@walletconnect/sign-client/node_modules/ws/browser.js
var require_browser3 = __commonJS({
  "node_modules/@walletconnect/sign-client/node_modules/ws/browser.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// node_modules/@walletconnect/universal-provider/node_modules/query-string/index.js
var require_query_string3 = __commonJS({
  "node_modules/@walletconnect/universal-provider/node_modules/query-string/index.js"(exports) {
    "use strict";
    init_shim();
    var strictUriEncode = require_strict_uri_encode();
    var decodeComponent = require_decode_uri_component();
    var splitOnFirst = require_split_on_first();
    var filterObject = require_filter_obj();
    var isNullOrUndefined = (value) => value === null || value === void 0;
    var encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case "index":
          return (key) => (result, value) => {
            const index = result.length;
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), "[", index, "]"].join("")];
            }
            return [
              ...result,
              [encode(key, options), "[", encode(index, options), "]=", encode(value, options)].join("")
            ];
          };
        case "bracket":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), "[]"].join("")];
            }
            return [...result, [encode(key, options), "[]=", encode(value, options)].join("")];
          };
        case "colon-list-separator":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), ":list="].join("")];
            }
            return [...result, [encode(key, options), ":list=", encode(value, options)].join("")];
          };
        case "comma":
        case "separator":
        case "bracket-separator": {
          const keyValueSep = options.arrayFormat === "bracket-separator" ? "[]=" : "=";
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            value = value === null ? "" : value;
            if (result.length === 0) {
              return [[encode(key, options), keyValueSep, encode(value, options)].join("")];
            }
            return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
          };
        }
        default:
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, encode(key, options)];
            }
            return [...result, [encode(key, options), "=", encode(value, options)].join("")];
          };
      }
    }
    function parserForArrayFormat(options) {
      let result;
      switch (options.arrayFormat) {
        case "index":
          return (key, value, accumulator) => {
            result = /\[(\d*)\]$/.exec(key);
            key = key.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = {};
            }
            accumulator[key][result[1]] = value;
          };
        case "bracket":
          return (key, value, accumulator) => {
            result = /(\[\])$/.exec(key);
            key = key.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "colon-list-separator":
          return (key, value, accumulator) => {
            result = /(:list)$/.exec(key);
            key = key.replace(/:list$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "comma":
        case "separator":
          return (key, value, accumulator) => {
            const isArray = typeof value === "string" && value.includes(options.arrayFormatSeparator);
            const isEncodedArray = typeof value === "string" && !isArray && decode(value, options).includes(options.arrayFormatSeparator);
            value = isEncodedArray ? decode(value, options) : value;
            const newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item) => decode(item, options)) : value === null ? value : decode(value, options);
            accumulator[key] = newValue;
          };
        case "bracket-separator":
          return (key, value, accumulator) => {
            const isArray = /(\[\])$/.test(key);
            key = key.replace(/\[\]$/, "");
            if (!isArray) {
              accumulator[key] = value ? decode(value, options) : value;
              return;
            }
            const arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map((item) => decode(item, options));
            if (accumulator[key] === void 0) {
              accumulator[key] = arrayValue;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], arrayValue);
          };
        default:
          return (key, value, accumulator) => {
            if (accumulator[key] === void 0) {
              accumulator[key] = value;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
      }
    }
    function validateArrayFormatSeparator(value) {
      if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
      }
    }
    function encode(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
      }
      return value;
    }
    function decode(value, options) {
      if (options.decode) {
        return decodeComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }
      if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort((a3, b4) => Number(a3) - Number(b4)).map((key) => input[key]);
      }
      return input;
    }
    function removeHash(input) {
      const hashStart = input.indexOf("#");
      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }
      return input;
    }
    function getHash(url) {
      let hash = "";
      const hashStart = url.indexOf("#");
      if (hashStart !== -1) {
        hash = url.slice(hashStart);
      }
      return hash;
    }
    function extract(input) {
      input = removeHash(input);
      const queryStart = input.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return input.slice(queryStart + 1);
    }
    function parseValue(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        value = value.toLowerCase() === "true";
      }
      return value;
    }
    function parse4(query, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const formatter = parserForArrayFormat(options);
      const ret = /* @__PURE__ */ Object.create(null);
      if (typeof query !== "string") {
        return ret;
      }
      query = query.trim().replace(/^[?#&]/, "");
      if (!query) {
        return ret;
      }
      for (const param of query.split("&")) {
        if (param === "") {
          continue;
        }
        let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
        value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options.arrayFormat) ? value : decode(value, options);
        formatter(decode(key, options), value, ret);
      }
      for (const key of Object.keys(ret)) {
        const value = ret[key];
        if (typeof value === "object" && value !== null) {
          for (const k3 of Object.keys(value)) {
            value[k3] = parseValue(value[k3], options);
          }
        } else {
          ret[key] = parseValue(value, options);
        }
      }
      if (options.sort === false) {
        return ret;
      }
      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
        const value = ret[key];
        if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
          result[key] = keysSorter(value);
        } else {
          result[key] = value;
        }
        return result;
      }, /* @__PURE__ */ Object.create(null));
    }
    exports.extract = extract;
    exports.parse = parse4;
    exports.stringify = (object, options) => {
      if (!object) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const shouldFilter = (key) => options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === "";
      const formatter = encoderForArrayFormat(options);
      const objectCopy = {};
      for (const key of Object.keys(object)) {
        if (!shouldFilter(key)) {
          objectCopy[key] = object[key];
        }
      }
      const keys = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys.sort(options.sort);
      }
      return keys.map((key) => {
        const value = object[key];
        if (value === void 0) {
          return "";
        }
        if (value === null) {
          return encode(key, options);
        }
        if (Array.isArray(value)) {
          if (value.length === 0 && options.arrayFormat === "bracket-separator") {
            return encode(key, options) + "[]";
          }
          return value.reduce(formatter(key), []).join("&");
        }
        return encode(key, options) + "=" + encode(value, options);
      }).filter((x5) => x5.length > 0).join("&");
    };
    exports.parseUrl = (url, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url_, hash] = splitOnFirst(url, "#");
      return Object.assign(
        {
          url: url_.split("?")[0] || "",
          query: parse4(extract(url), options)
        },
        options && options.parseFragmentIdentifier && hash ? { fragmentIdentifier: decode(hash, options) } : {}
      );
    };
    exports.stringifyUrl = (object, options) => {
      options = Object.assign({
        encode: true,
        strict: true,
        [encodeFragmentIdentifier]: true
      }, options);
      const url = removeHash(object.url).split("?")[0] || "";
      const queryFromUrl = exports.extract(object.url);
      const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
      const query = Object.assign(parsedQueryFromUrl, object.query);
      let queryString = exports.stringify(query, options);
      if (queryString) {
        queryString = `?${queryString}`;
      }
      let hash = getHash(object.url);
      if (object.fragmentIdentifier) {
        hash = `#${options[encodeFragmentIdentifier] ? encode(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;
      }
      return `${url}${queryString}${hash}`;
    };
    exports.pick = (input, filter, options) => {
      options = Object.assign({
        parseFragmentIdentifier: true,
        [encodeFragmentIdentifier]: false
      }, options);
      const { url, query, fragmentIdentifier } = exports.parseUrl(input, options);
      return exports.stringifyUrl({
        url,
        query: filterObject(query, filter),
        fragmentIdentifier
      }, options);
    };
    exports.exclude = (input, filter, options) => {
      const exclusionFilter = Array.isArray(filter) ? (key) => !filter.includes(key) : (key, value) => !filter(key, value);
      return exports.pick(input, exclusionFilter, options);
    };
  }
});

// node_modules/@walletconnect/ethereum-provider/dist/index.es.js
init_shim();
var import_events8 = __toESM(require_events());

// node_modules/@walletconnect/ethereum-provider/node_modules/@walletconnect/utils/dist/index.es.js
init_shim();
var import_chacha20poly1305 = __toESM(require_chacha20poly1305());
var import_hkdf = __toESM(require_hkdf());
var import_random = __toESM(require_random());
var import_sha256 = __toESM(require_sha256());
var ue = __toESM(require_x25519());
init_es();
var import_time = __toESM(require_cjs());
var import_window_getters = __toESM(require_cjs3());
var import_window_metadata = __toESM(require_cjs4());
var $ = __toESM(require_query_string());
function bn(e, n2 = []) {
  const t = [];
  return Object.keys(e).forEach((r) => {
    if (n2.length && !n2.includes(r))
      return;
    const o2 = e[r];
    t.push(...o2.accounts);
  }), t;
}
var St = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
function R(e, n2) {
  const { message: t, code: r } = St[e];
  return { message: n2 ? `${t} ${n2}` : t, code: r };
}
function C(e, n2) {
  return Array.isArray(e) ? typeof n2 < "u" && e.length ? e.every(n2) : true : false;
}

// node_modules/@walletconnect/universal-provider/dist/index.es.js
init_shim();
var import_pino3 = __toESM(require_browser2());

// node_modules/@walletconnect/sign-client/dist/index.es.js
init_shim();
var import_pino2 = __toESM(require_browser2());

// node_modules/@walletconnect/sign-client/node_modules/@walletconnect/core/dist/index.es.js
init_shim();
var import_events5 = __toESM(require_events());
var import_pino = __toESM(require_browser2());
var import_keyvaluestorage = __toESM(require_browser());
var import_heartbeat = __toESM(require_cjs5());
var import_logger = __toESM(require_cjs2());

// node_modules/@walletconnect/sign-client/node_modules/@walletconnect/types/dist/index.es.js
init_shim();
init_esm();
var import_events2 = __toESM(require_events());
var n = class extends IEvents {
  constructor(s) {
    super(), this.opts = s, this.protocol = "wc", this.version = 2;
  }
};
var h = class extends IEvents {
  constructor(s, t) {
    super(), this.core = s, this.logger = t, this.records = /* @__PURE__ */ new Map();
  }
};
var a = class {
  constructor(s, t) {
    this.logger = s, this.core = t;
  }
};
var u = class extends IEvents {
  constructor(s, t) {
    super(), this.relayer = s, this.logger = t;
  }
};
var g = class extends IEvents {
  constructor(s) {
    super();
  }
};
var p = class {
  constructor(s, t, o2, S2) {
    this.core = s, this.logger = t, this.name = o2;
  }
};
var x = class extends IEvents {
  constructor(s, t) {
    super(), this.relayer = s, this.logger = t;
  }
};
var E = class extends IEvents {
  constructor(s, t) {
    super(), this.core = s, this.logger = t;
  }
};
var y = class {
  constructor(s) {
    this.opts = s, this.protocol = "wc", this.version = 2;
  }
};
var C2 = class {
  constructor(s) {
    this.client = s;
  }
};

// node_modules/@walletconnect/sign-client/node_modules/@walletconnect/core/dist/index.es.js
init_esm2();

// node_modules/@walletconnect/sign-client/node_modules/@walletconnect/utils/dist/index.es.js
init_shim();
var import_chacha20poly13052 = __toESM(require_chacha20poly1305());
var import_hkdf2 = __toESM(require_hkdf());
var import_random2 = __toESM(require_random());
var import_sha2562 = __toESM(require_sha256());
var ue2 = __toESM(require_x25519());
init_es();
var import_time2 = __toESM(require_cjs());
var import_window_getters2 = __toESM(require_cjs3());
var import_window_metadata2 = __toESM(require_cjs4());
var $2 = __toESM(require_query_string2());
function V(e, n2) {
  return e.includes(":") ? [e] : n2.chains || [];
}
var G = "base10";
var f = "base16";
var K = "base64pad";
var k = "utf8";
var Y = 0;
var U = 1;
var Tn = 0;
var Oe = 1;
var W = 12;
var J = 32;
function Rn() {
  const e = ue2.generateKeyPair();
  return { privateKey: toString(e.secretKey, f), publicKey: toString(e.publicKey, f) };
}
function An() {
  const e = (0, import_random2.randomBytes)(J);
  return toString(e, f);
}
function Un(e, n2) {
  const t = ue2.sharedKey(fromString(e, f), fromString(n2, f)), r = new import_hkdf2.HKDF(import_sha2562.SHA256, t).expand(J);
  return toString(r, f);
}
function _n(e) {
  const n2 = (0, import_sha2562.hash)(fromString(e, f));
  return toString(n2, f);
}
function wn(e) {
  const n2 = (0, import_sha2562.hash)(fromString(e, k));
  return toString(n2, f);
}
function Se(e) {
  return fromString(`${e}`, G);
}
function j(e) {
  return Number(toString(e, G));
}
function jn(e) {
  const n2 = Se(typeof e.type < "u" ? e.type : Y);
  if (j(n2) === U && typeof e.senderPublicKey > "u")
    throw new Error("Missing sender public key for type 1 envelope");
  const t = typeof e.senderPublicKey < "u" ? fromString(e.senderPublicKey, f) : void 0, r = typeof e.iv < "u" ? fromString(e.iv, f) : (0, import_random2.randomBytes)(W), o2 = new import_chacha20poly13052.ChaCha20Poly1305(fromString(e.symKey, f)).seal(r, fromString(e.message, k));
  return Ie({ type: n2, sealed: o2, iv: r, senderPublicKey: t });
}
function Cn(e) {
  const n2 = new import_chacha20poly13052.ChaCha20Poly1305(fromString(e.symKey, f)), { sealed: t, iv: r } = Q(e.encoded), o2 = n2.open(r, t);
  if (o2 === null)
    throw new Error("Failed to decrypt");
  return toString(o2, k);
}
function Ie(e) {
  if (j(e.type) === U) {
    if (typeof e.senderPublicKey > "u")
      throw new Error("Missing sender public key for type 1 envelope");
    return toString(concat([e.type, e.senderPublicKey, e.iv, e.sealed]), K);
  }
  return toString(concat([e.type, e.iv, e.sealed]), K);
}
function Q(e) {
  const n2 = fromString(e, K), t = n2.slice(Tn, Oe), r = Oe;
  if (j(t) === U) {
    const d = r + J, l = d + W, i2 = n2.slice(r, d), u5 = n2.slice(d, l), a3 = n2.slice(l);
    return { type: t, sealed: a3, iv: u5, senderPublicKey: i2 };
  }
  const o2 = r + W, s = n2.slice(r, o2), c2 = n2.slice(o2);
  return { type: t, sealed: c2, iv: s };
}
function $n(e, n2) {
  const t = Q(e);
  return Pe({ type: j(t.type), senderPublicKey: typeof t.senderPublicKey < "u" ? toString(t.senderPublicKey, f) : void 0, receiverPublicKey: n2 == null ? void 0 : n2.receiverPublicKey });
}
function Pe(e) {
  const n2 = (e == null ? void 0 : e.type) || Y;
  if (n2 === U) {
    if (typeof (e == null ? void 0 : e.senderPublicKey) > "u")
      throw new Error("missing sender public key");
    if (typeof (e == null ? void 0 : e.receiverPublicKey) > "u")
      throw new Error("missing receiver public key");
  }
  return { type: n2, senderPublicKey: e == null ? void 0 : e.senderPublicKey, receiverPublicKey: e == null ? void 0 : e.receiverPublicKey };
}
function Dn(e) {
  return e.type === U && typeof e.senderPublicKey == "string" && typeof e.receiverPublicKey == "string";
}
var Vn = Object.defineProperty;
var Te = Object.getOwnPropertySymbols;
var Mn = Object.prototype.hasOwnProperty;
var Kn = Object.prototype.propertyIsEnumerable;
var Re = (e, n2, t) => n2 in e ? Vn(e, n2, { enumerable: true, configurable: true, writable: true, value: t }) : e[n2] = t;
var Ae = (e, n2) => {
  for (var t in n2 || (n2 = {}))
    Mn.call(n2, t) && Re(e, t, n2[t]);
  if (Te)
    for (var t of Te(n2))
      Kn.call(n2, t) && Re(e, t, n2[t]);
  return e;
};
var Ue = "ReactNative";
var _ = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" };
var we = "js";
function X() {
  return typeof import_process.default < "u" && typeof import_process.default.versions < "u" && typeof import_process.default.versions.node < "u";
}
function je() {
  return !(0, import_window_getters2.getDocument)() && !!(0, import_window_getters2.getNavigator)() && navigator.product === Ue;
}
function Ce() {
  return !X() && !!(0, import_window_getters2.getNavigator)();
}
function ee() {
  return je() ? _.reactNative : X() ? _.node : Ce() ? _.browser : _.unknown;
}
function $e(e, n2) {
  let t = $2.parse(e);
  return t = Ae(Ae({}, t), n2), e = $2.stringify(t), e;
}
function xn() {
  return (0, import_window_metadata2.getWindowMetadata)() || { name: "", description: "", url: "", icons: [""] };
}
function De() {
  const e = detect();
  if (e === null)
    return "unknown";
  const n2 = e.os ? e.os.replace(" ", "").toLowerCase() : "unknown";
  return e.type === "browser" ? [n2, e.name, e.version].join("-") : [n2, e.version].join("-");
}
function Ve() {
  var e;
  const n2 = ee();
  return n2 === _.browser ? [n2, ((e = (0, import_window_getters2.getLocation)()) == null ? void 0 : e.host) || "unknown"].join(":") : n2;
}
function Me(e, n2, t) {
  const r = De(), o2 = Ve();
  return [[e, n2].join("-"), [we, t].join("-"), r, o2].join("/");
}
function Hn({ protocol: e, version: n2, relayUrl: t, sdkVersion: r, auth: o2, projectId: s, useOnCloseEvent: c2 }) {
  const d = t.split("?"), l = Me(e, n2, r), i2 = { auth: o2, ua: l, projectId: s, useOnCloseEvent: c2 || void 0 }, u5 = $e(d[1] || "", i2);
  return d[0] + "?" + u5;
}
function b(e, n2) {
  return e.filter((t) => n2.includes(t)).length === e.length;
}
function Gn(e) {
  return Object.fromEntries(e.entries());
}
function Yn(e) {
  return new Map(Object.entries(e));
}
function Zn(e = import_time2.FIVE_MINUTES, n2) {
  const t = (0, import_time2.toMiliseconds)(e || import_time2.FIVE_MINUTES);
  let r, o2, s;
  return { resolve: (c2) => {
    s && r && (clearTimeout(s), r(c2));
  }, reject: (c2) => {
    s && o2 && (clearTimeout(s), o2(c2));
  }, done: () => new Promise((c2, d) => {
    s = setTimeout(() => {
      d(new Error(n2));
    }, t), r = c2, o2 = d;
  }) };
}
function Xn(e, n2, t) {
  return new Promise(async (r, o2) => {
    const s = setTimeout(() => o2(new Error(t)), n2);
    try {
      const c2 = await e;
      r(c2);
    } catch (c2) {
      o2(c2);
    }
    clearTimeout(s);
  });
}
function ne(e, n2) {
  if (typeof n2 == "string" && n2.startsWith(`${e}:`))
    return n2;
  if (e.toLowerCase() === "topic") {
    if (typeof n2 != "string")
      throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${n2}`;
  } else if (e.toLowerCase() === "id") {
    if (typeof n2 != "number")
      throw new Error('Value must be "number" for expirer target type: id');
    return `id:${n2}`;
  }
  throw new Error(`Unknown expirer target type: ${e}`);
}
function et(e) {
  return ne("topic", e);
}
function nt(e) {
  return ne("id", e);
}
function tt(e) {
  const [n2, t] = e.split(":"), r = { id: void 0, topic: void 0 };
  if (n2 === "topic" && typeof t == "string")
    r.topic = t;
  else if (n2 === "id" && Number.isInteger(Number(t)))
    r.id = Number(t);
  else
    throw new Error(`Invalid target, expected id:number or topic:string, got ${n2}:${t}`);
  return r;
}
function rt(e, n2) {
  return (0, import_time2.fromMiliseconds)((n2 || Date.now()) + (0, import_time2.toMiliseconds)(e));
}
function ot(e) {
  return Date.now() >= (0, import_time2.toMiliseconds)(e);
}
function st(e, n2) {
  return `${e}${n2 ? `:${n2}` : ""}`;
}
var xe = "irn";
function it(e) {
  return (e == null ? void 0 : e.relay) || { protocol: xe };
}
function ct(e) {
  const n2 = RELAY_JSONRPC[e];
  if (typeof n2 > "u")
    throw new Error(`Relay Protocol not supported: ${e}`);
  return n2;
}
var at = Object.defineProperty;
var Fe = Object.getOwnPropertySymbols;
var ut = Object.prototype.hasOwnProperty;
var dt = Object.prototype.propertyIsEnumerable;
var He = (e, n2, t) => n2 in e ? at(e, n2, { enumerable: true, configurable: true, writable: true, value: t }) : e[n2] = t;
var lt = (e, n2) => {
  for (var t in n2 || (n2 = {}))
    ut.call(n2, t) && He(e, t, n2[t]);
  if (Fe)
    for (var t of Fe(n2))
      dt.call(n2, t) && He(e, t, n2[t]);
  return e;
};
function qe(e, n2 = "-") {
  const t = {}, r = "relay" + n2;
  return Object.keys(e).forEach((o2) => {
    if (o2.startsWith(r)) {
      const s = o2.replace(r, ""), c2 = e[o2];
      t[s] = c2;
    }
  }), t;
}
function ft(e) {
  const n2 = e.indexOf(":"), t = e.indexOf("?") !== -1 ? e.indexOf("?") : void 0, r = e.substring(0, n2), o2 = e.substring(n2 + 1, t).split("@"), s = typeof t < "u" ? e.substring(t) : "", c2 = $2.parse(s);
  return { protocol: r, topic: o2[0], version: parseInt(o2[1], 10), symKey: c2.symKey, relay: qe(c2) };
}
function ze(e, n2 = "-") {
  const t = "relay", r = {};
  return Object.keys(e).forEach((o2) => {
    const s = t + n2 + o2;
    e[o2] && (r[s] = e[o2]);
  }), r;
}
function pt(e) {
  return `${e.protocol}:${e.topic}@${e.version}?` + $2.stringify(lt({ symKey: e.symKey }, ze(e.relay)));
}
function T(e) {
  const n2 = [];
  return e.forEach((t) => {
    const [r, o2] = t.split(":");
    n2.push(`${r}:${o2}`);
  }), n2;
}
function Ye(e) {
  const n2 = [];
  return Object.values(e).forEach((t) => {
    n2.push(...T(t.accounts));
  }), n2;
}
function We(e, n2) {
  const t = [];
  return Object.values(e).forEach((r) => {
    T(r.accounts).includes(n2) && t.push(...r.methods);
  }), t;
}
function Je(e, n2) {
  const t = [];
  return Object.values(e).forEach((r) => {
    T(r.accounts).includes(n2) && t.push(...r.events);
  }), t;
}
function bt(e, n2) {
  const t = on(e, n2);
  if (t)
    throw new Error(t.message);
  const r = {};
  for (const [o2, s] of Object.entries(e))
    r[o2] = { methods: s.methods, events: s.events, chains: s.accounts.map((c2) => `${c2.split(":")[0]}:${c2.split(":")[1]}`) };
  return r;
}
var St2 = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
var It = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function N(e, n2) {
  const { message: t, code: r } = It[e];
  return { message: n2 ? `${t} ${n2}` : t, code: r };
}
function R2(e, n2) {
  const { message: t, code: r } = St2[e];
  return { message: n2 ? `${t} ${n2}` : t, code: r };
}
function C3(e, n2) {
  return Array.isArray(e) ? typeof n2 < "u" && e.length ? e.every(n2) : true : false;
}
function x2(e) {
  return Object.getPrototypeOf(e) === Object.prototype && Object.keys(e).length;
}
function S(e) {
  return typeof e > "u";
}
function m(e, n2) {
  return n2 && S(e) ? true : typeof e == "string" && Boolean(e.trim().length);
}
function F(e, n2) {
  return n2 && S(e) ? true : typeof e == "number" && !isNaN(e);
}
function Pt(e, n2) {
  const { requiredNamespaces: t } = n2, r = Object.keys(e.namespaces), o2 = Object.keys(t);
  let s = true;
  return b(o2, r) ? (r.forEach((c2) => {
    const { accounts: d, methods: l, events: i2 } = e.namespaces[c2], u5 = T(d), a3 = t[c2];
    (!b(V(c2, a3), u5) || !b(a3.methods, l) || !b(a3.events, i2)) && (s = false);
  }), s) : false;
}
function H(e) {
  return m(e, false) && e.includes(":") ? e.split(":").length === 2 : false;
}
function Ze(e) {
  if (m(e, false) && e.includes(":")) {
    const n2 = e.split(":");
    if (n2.length === 3) {
      const t = n2[0] + ":" + n2[1];
      return !!n2[2] && H(t);
    }
  }
  return false;
}
function Tt(e) {
  if (m(e, false))
    try {
      return typeof new URL(e) < "u";
    } catch {
      return false;
    }
  return false;
}
function Rt(e) {
  var n2;
  return (n2 = e == null ? void 0 : e.proposer) == null ? void 0 : n2.publicKey;
}
function At(e) {
  return e == null ? void 0 : e.topic;
}
function Ut(e, n2) {
  let t = null;
  return m(e == null ? void 0 : e.publicKey, false) || (t = N("MISSING_OR_INVALID", `${n2} controller public key should be a string`)), t;
}
function oe(e) {
  let n2 = true;
  return C3(e) ? e.length && (n2 = e.every((t) => m(t, false))) : n2 = false, n2;
}
function Xe(e, n2, t) {
  let r = null;
  return C3(n2) ? n2.forEach((o2) => {
    r || (!H(o2) || !o2.includes(e)) && (r = R2("UNSUPPORTED_CHAINS", `${t}, chain ${o2} should be a string and conform to "namespace:chainId" format`));
  }) : r = R2("UNSUPPORTED_CHAINS", `${t}, chains ${n2} should be an array of strings conforming to "namespace:chainId" format`), r;
}
function en(e, n2) {
  let t = null;
  return Object.entries(e).forEach(([r, o2]) => {
    if (t)
      return;
    const s = Xe(r, V(r, o2), `${n2} requiredNamespace`);
    s && (t = s);
  }), t;
}
function nn(e, n2) {
  let t = null;
  return C3(e) ? e.forEach((r) => {
    t || Ze(r) || (t = R2("UNSUPPORTED_ACCOUNTS", `${n2}, account ${r} should be a string and conform to "namespace:chainId:address" format`));
  }) : t = R2("UNSUPPORTED_ACCOUNTS", `${n2}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), t;
}
function tn(e, n2) {
  let t = null;
  return Object.values(e).forEach((r) => {
    if (t)
      return;
    const o2 = nn(r == null ? void 0 : r.accounts, `${n2} namespace`);
    o2 && (t = o2);
  }), t;
}
function rn(e, n2) {
  let t = null;
  return oe(e == null ? void 0 : e.methods) ? oe(e == null ? void 0 : e.events) || (t = R2("UNSUPPORTED_EVENTS", `${n2}, events should be an array of strings or empty array for no events`)) : t = R2("UNSUPPORTED_METHODS", `${n2}, methods should be an array of strings or empty array for no methods`), t;
}
function se(e, n2) {
  let t = null;
  return Object.values(e).forEach((r) => {
    if (t)
      return;
    const o2 = rn(r, `${n2}, namespace`);
    o2 && (t = o2);
  }), t;
}
function _t(e, n2, t) {
  let r = null;
  if (e && x2(e)) {
    const o2 = se(e, n2);
    o2 && (r = o2);
    const s = en(e, n2);
    s && (r = s);
  } else
    r = N("MISSING_OR_INVALID", `${n2}, ${t} should be an object with data`);
  return r;
}
function on(e, n2) {
  let t = null;
  if (e && x2(e)) {
    const r = se(e, n2);
    r && (t = r);
    const o2 = tn(e, n2);
    o2 && (t = o2);
  } else
    t = N("MISSING_OR_INVALID", `${n2}, namespaces should be an object with data`);
  return t;
}
function sn(e) {
  return m(e.protocol, true);
}
function wt(e, n2) {
  let t = false;
  return n2 && !e ? t = true : e && C3(e) && e.length && e.forEach((r) => {
    t = sn(r);
  }), t;
}
function jt(e) {
  return typeof e == "number";
}
function Ct(e) {
  return typeof e < "u" && typeof e !== null;
}
function $t(e) {
  return !(!e || typeof e != "object" || !e.code || !F(e.code, false) || !e.message || !m(e.message, false));
}
function Dt(e) {
  return !(S(e) || !m(e.method, false));
}
function Vt(e) {
  return !(S(e) || S(e.result) && S(e.error) || !F(e.id, false) || !m(e.jsonrpc, false));
}
function Mt(e) {
  return !(S(e) || !m(e.name, false));
}
function Kt(e, n2) {
  return !(!H(n2) || !Ye(e).includes(n2));
}
function kt(e, n2, t) {
  return m(t, false) ? We(e, n2).includes(t) : false;
}
function Lt(e, n2, t) {
  return m(t, false) ? Je(e, n2).includes(t) : false;
}
function cn(e, n2, t) {
  let r = null;
  const o2 = xt(e), s = Ft(n2), c2 = Object.keys(o2), d = Object.keys(s), l = an(Object.keys(e)), i2 = an(Object.keys(n2)), u5 = l.filter((a3) => !i2.includes(a3));
  return u5.length && (r = N("NON_CONFORMING_NAMESPACES", `${t} namespaces keys don't satisfy requiredNamespaces.
      Required: ${u5.toString()}
      Received: ${Object.keys(n2).toString()}`)), b(c2, d) || (r = N("NON_CONFORMING_NAMESPACES", `${t} namespaces chains don't satisfy required namespaces.
      Required: ${c2.toString()}
      Approved: ${d.toString()}`)), Object.keys(n2).forEach((a3) => {
    if (!a3.includes(":") || r)
      return;
    const g3 = T(n2[a3].accounts);
    g3.includes(a3) || (r = N("NON_CONFORMING_NAMESPACES", `${t} namespaces accounts don't satisfy namespace accounts for ${a3}
        Required: ${a3}
        Approved: ${g3.toString()}`));
  }), c2.forEach((a3) => {
    r || (b(o2[a3].methods, s[a3].methods) ? b(o2[a3].events, s[a3].events) || (r = N("NON_CONFORMING_NAMESPACES", `${t} namespaces events don't satisfy namespace events for ${a3}`)) : r = N("NON_CONFORMING_NAMESPACES", `${t} namespaces methods don't satisfy namespace methods for ${a3}`));
  }), r;
}
function xt(e) {
  const n2 = {};
  return Object.keys(e).forEach((t) => {
    var r;
    t.includes(":") ? n2[t] = e[t] : (r = e[t].chains) == null || r.forEach((o2) => {
      n2[o2] = { methods: e[t].methods, events: e[t].events };
    });
  }), n2;
}
function an(e) {
  return [...new Set(e.map((n2) => n2.includes(":") ? n2.split(":")[0] : n2))];
}
function Ft(e) {
  const n2 = {};
  return Object.keys(e).forEach((t) => {
    if (t.includes(":"))
      n2[t] = e[t];
    else {
      const r = T(e[t].accounts);
      r == null ? void 0 : r.forEach((o2) => {
        n2[o2] = { accounts: e[t].accounts.filter((s) => s.includes(`${o2}:`)), methods: e[t].methods, events: e[t].events };
      });
    }
  }), n2;
}
function Ht(e, n2) {
  return F(e, false) && e <= n2.max && e >= n2.min;
}

// node_modules/@walletconnect/sign-client/node_modules/@walletconnect/core/dist/index.es.js
var import_time3 = __toESM(require_cjs());

// node_modules/@walletconnect/sign-client/node_modules/@walletconnect/jsonrpc-provider/dist/esm/index.js
init_shim();

// node_modules/@walletconnect/sign-client/node_modules/@walletconnect/jsonrpc-provider/dist/esm/provider.js
init_shim();
var import_events3 = __toESM(require_events());
init_esm3();
var JsonRpcProvider2 = class extends IJsonRpcProvider {
  constructor(connection) {
    super(connection);
    this.events = new import_events3.EventEmitter();
    this.hasRegisteredEventListeners = false;
    this.connection = this.setConnection(connection);
    if (this.connection.connected) {
      this.registerEventListeners();
    }
  }
  async connect(connection = this.connection) {
    await this.open(connection);
  }
  async disconnect() {
    await this.close();
  }
  on(event, listener) {
    this.events.on(event, listener);
  }
  once(event, listener) {
    this.events.once(event, listener);
  }
  off(event, listener) {
    this.events.off(event, listener);
  }
  removeListener(event, listener) {
    this.events.removeListener(event, listener);
  }
  async request(request, context) {
    return this.requestStrict(formatJsonRpcRequest(request.method, request.params || []), context);
  }
  async requestStrict(request, context) {
    return new Promise(async (resolve, reject) => {
      if (!this.connection.connected) {
        try {
          await this.open();
        } catch (e) {
          reject(e);
        }
      }
      this.events.on(`${request.id}`, (response) => {
        if (isJsonRpcError(response)) {
          reject(response.error);
        } else {
          resolve(response.result);
        }
      });
      try {
        await this.connection.send(request, context);
      } catch (e) {
        reject(e);
      }
    });
  }
  setConnection(connection = this.connection) {
    return connection;
  }
  onPayload(payload) {
    this.events.emit("payload", payload);
    if (isJsonRpcResponse(payload)) {
      this.events.emit(`${payload.id}`, payload);
    } else {
      this.events.emit("message", {
        type: payload.method,
        data: payload.params
      });
    }
  }
  onClose(event) {
    if (event && event.code === 3e3) {
      this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${event.code} ${event.reason ? `(${event.reason})` : ""}`));
    }
    this.events.emit("disconnect");
  }
  async open(connection = this.connection) {
    if (this.connection === connection && this.connection.connected)
      return;
    if (this.connection.connected)
      this.close();
    if (typeof connection === "string") {
      await this.connection.open(connection);
      connection = this.connection;
    }
    this.connection = this.setConnection(connection);
    await this.connection.open();
    this.registerEventListeners();
    this.events.emit("connect");
  }
  async close() {
    await this.connection.close();
  }
  registerEventListeners() {
    if (this.hasRegisteredEventListeners)
      return;
    this.connection.on("payload", (payload) => this.onPayload(payload));
    this.connection.on("close", (event) => this.onClose(event));
    this.connection.on("error", (error) => this.events.emit("error", error));
    this.connection.on("register_error", (error) => this.onClose());
    this.hasRegisteredEventListeners = true;
  }
};

// node_modules/@walletconnect/sign-client/node_modules/@walletconnect/core/dist/index.es.js
init_esm3();

// node_modules/@walletconnect/sign-client/node_modules/@walletconnect/jsonrpc-ws-connection/dist/esm/index.js
init_shim();

// node_modules/@walletconnect/sign-client/node_modules/@walletconnect/jsonrpc-ws-connection/dist/esm/ws.js
init_shim();
var import_events4 = __toESM(require_events());
init_esm2();
init_esm3();
var EVENT_EMITTER_MAX_LISTENERS_DEFAULT = 10;
var resolveWebSocketImplementation = () => {
  if (typeof global !== "undefined" && typeof global.WebSocket !== "undefined") {
    return global.WebSocket;
  }
  if (typeof window !== "undefined" && typeof window.WebSocket !== "undefined") {
    return window.WebSocket;
  }
  return require_browser3();
};
var isBrowser = () => typeof window !== "undefined";
var WS = resolveWebSocketImplementation();
var WsConnection = class {
  constructor(url) {
    this.url = url;
    this.events = new import_events4.EventEmitter();
    this.registering = false;
    if (!isWsUrl(url)) {
      throw new Error(`Provided URL is not compatible with WebSocket connection: ${url}`);
    }
    this.url = url;
  }
  get connected() {
    return typeof this.socket !== "undefined";
  }
  get connecting() {
    return this.registering;
  }
  on(event, listener) {
    this.events.on(event, listener);
  }
  once(event, listener) {
    this.events.once(event, listener);
  }
  off(event, listener) {
    this.events.off(event, listener);
  }
  removeListener(event, listener) {
    this.events.removeListener(event, listener);
  }
  async open(url = this.url) {
    await this.register(url);
  }
  async close() {
    return new Promise((resolve, reject) => {
      if (typeof this.socket === "undefined") {
        reject(new Error("Connection already closed"));
        return;
      }
      this.socket.onclose = (event) => {
        this.onClose(event);
        resolve();
      };
      this.socket.close();
    });
  }
  async send(payload, context) {
    if (typeof this.socket === "undefined") {
      this.socket = await this.register();
    }
    try {
      this.socket.send(safeJsonStringify(payload));
    } catch (e) {
      this.onError(payload.id, e);
    }
  }
  register(url = this.url) {
    if (!isWsUrl(url)) {
      throw new Error(`Provided URL is not compatible with WebSocket connection: ${url}`);
    }
    if (this.registering) {
      const currentMaxListeners = this.events.getMaxListeners();
      if (this.events.listenerCount("register_error") >= currentMaxListeners || this.events.listenerCount("open") >= currentMaxListeners) {
        this.events.setMaxListeners(currentMaxListeners + 1);
      }
      return new Promise((resolve, reject) => {
        this.events.once("register_error", (error) => {
          this.resetMaxListeners();
          reject(error);
        });
        this.events.once("open", () => {
          this.resetMaxListeners();
          if (typeof this.socket === "undefined") {
            return reject(new Error("WebSocket connection is missing or invalid"));
          }
          resolve(this.socket);
        });
      });
    }
    this.url = url;
    this.registering = true;
    return new Promise((resolve, reject) => {
      const opts = !(0, esm_exports2.isReactNative)() ? { rejectUnauthorized: !isLocalhostUrl(url) } : void 0;
      const socket = new WS(url, [], opts);
      if (isBrowser()) {
        socket.onerror = (event) => {
          const errorEvent = event;
          reject(this.emitError(errorEvent.error));
        };
      } else {
        socket.on("error", (errorEvent) => {
          reject(this.emitError(errorEvent));
        });
      }
      socket.onopen = () => {
        this.onOpen(socket);
        resolve(socket);
      };
    });
  }
  onOpen(socket) {
    socket.onmessage = (event) => this.onPayload(event);
    socket.onclose = (event) => this.onClose(event);
    this.socket = socket;
    this.registering = false;
    this.events.emit("open");
  }
  onClose(event) {
    this.socket = void 0;
    this.registering = false;
    this.events.emit("close", event);
  }
  onPayload(e) {
    if (typeof e.data === "undefined")
      return;
    const payload = typeof e.data === "string" ? safeJsonParse(e.data) : e.data;
    this.events.emit("payload", payload);
  }
  onError(id, e) {
    const error = this.parseError(e);
    const message = error.message || error.toString();
    const payload = formatJsonRpcError(id, message);
    this.events.emit("payload", payload);
  }
  parseError(e, url = this.url) {
    return parseConnectionError(e, url, "WS");
  }
  resetMaxListeners() {
    if (this.events.getMaxListeners() > EVENT_EMITTER_MAX_LISTENERS_DEFAULT) {
      this.events.setMaxListeners(EVENT_EMITTER_MAX_LISTENERS_DEFAULT);
    }
  }
  emitError(errorEvent) {
    const error = this.parseError(new Error((errorEvent === null || errorEvent === void 0 ? void 0 : errorEvent.message) || `WebSocket connection failed for URL: ${this.url}`));
    this.events.emit("register_error", error);
    return error;
  }
};
var ws_default = WsConnection;

// node_modules/@walletconnect/sign-client/node_modules/@walletconnect/jsonrpc-ws-connection/dist/esm/index.js
var esm_default2 = ws_default;

// node_modules/@walletconnect/sign-client/node_modules/@walletconnect/core/dist/index.es.js
var import_lodash = __toESM(require_lodash());
function Ci(r, e) {
  if (r.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), i2 = 0; i2 < t.length; i2++)
    t[i2] = 255;
  for (var s = 0; s < r.length; s++) {
    var n2 = r.charAt(s), a3 = n2.charCodeAt(0);
    if (t[a3] !== 255)
      throw new TypeError(n2 + " is ambiguous");
    t[a3] = s;
  }
  var o2 = r.length, h3 = r.charAt(0), d = Math.log(o2) / Math.log(256), l = Math.log(256) / Math.log(o2);
  function g3(u5) {
    if (u5 instanceof Uint8Array || (ArrayBuffer.isView(u5) ? u5 = new Uint8Array(u5.buffer, u5.byteOffset, u5.byteLength) : Array.isArray(u5) && (u5 = Uint8Array.from(u5))), !(u5 instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (u5.length === 0)
      return "";
    for (var y4 = 0, O4 = 0, E3 = 0, _4 = u5.length; E3 !== _4 && u5[E3] === 0; )
      E3++, y4++;
    for (var R5 = (_4 - E3) * l + 1 >>> 0, b4 = new Uint8Array(R5); E3 !== _4; ) {
      for (var S2 = u5[E3], x5 = 0, f3 = R5 - 1; (S2 !== 0 || x5 < O4) && f3 !== -1; f3--, x5++)
        S2 += 256 * b4[f3] >>> 0, b4[f3] = S2 % o2 >>> 0, S2 = S2 / o2 >>> 0;
      if (S2 !== 0)
        throw new Error("Non-zero carry");
      O4 = x5, E3++;
    }
    for (var P2 = R5 - O4; P2 !== R5 && b4[P2] === 0; )
      P2++;
    for (var K4 = h3.repeat(y4); P2 < R5; ++P2)
      K4 += r.charAt(b4[P2]);
    return K4;
  }
  function U4(u5) {
    if (typeof u5 != "string")
      throw new TypeError("Expected String");
    if (u5.length === 0)
      return new Uint8Array();
    var y4 = 0;
    if (u5[y4] !== " ") {
      for (var O4 = 0, E3 = 0; u5[y4] === h3; )
        O4++, y4++;
      for (var _4 = (u5.length - y4) * d + 1 >>> 0, R5 = new Uint8Array(_4); u5[y4]; ) {
        var b4 = t[u5.charCodeAt(y4)];
        if (b4 === 255)
          return;
        for (var S2 = 0, x5 = _4 - 1; (b4 !== 0 || S2 < E3) && x5 !== -1; x5--, S2++)
          b4 += o2 * R5[x5] >>> 0, R5[x5] = b4 % 256 >>> 0, b4 = b4 / 256 >>> 0;
        if (b4 !== 0)
          throw new Error("Non-zero carry");
        E3 = S2, y4++;
      }
      if (u5[y4] !== " ") {
        for (var f3 = _4 - E3; f3 !== _4 && R5[f3] === 0; )
          f3++;
        for (var P2 = new Uint8Array(O4 + (_4 - f3)), K4 = O4; f3 !== _4; )
          P2[K4++] = R5[f3++];
        return P2;
      }
    }
  }
  function J4(u5) {
    var y4 = U4(u5);
    if (y4)
      return y4;
    throw new Error(`Non-${e} character`);
  }
  return { encode: g3, decodeUnsafe: U4, decode: J4 };
}
var _i = Ci;
var Ri = _i;
var Ce2 = (r) => {
  if (r instanceof Uint8Array && r.constructor.name === "Uint8Array")
    return r;
  if (r instanceof ArrayBuffer)
    return new Uint8Array(r);
  if (ArrayBuffer.isView(r))
    return new Uint8Array(r.buffer, r.byteOffset, r.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var Si = (r) => new TextEncoder().encode(r);
var Pi = (r) => new TextDecoder().decode(r);
var Ti = class {
  constructor(e, t, i2) {
    this.name = e, this.prefix = t, this.baseEncode = i2;
  }
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var xi = class {
  constructor(e, t, i2) {
    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = i2;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e) {
    return _e(this, e);
  }
};
var Oi = class {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return _e(this, e);
  }
  decode(e) {
    const t = e[0], i2 = this.decoders[t];
    if (i2)
      return i2.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var _e = (r, e) => new Oi({ ...r.decoders || { [r.prefix]: r }, ...e.decoders || { [e.prefix]: e } });
var Ai = class {
  constructor(e, t, i2, s) {
    this.name = e, this.prefix = t, this.baseEncode = i2, this.baseDecode = s, this.encoder = new Ti(e, t, i2), this.decoder = new xi(e, t, s);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
};
var q3 = ({ name: r, prefix: e, encode: t, decode: i2 }) => new Ai(r, e, t, i2);
var F2 = ({ prefix: r, name: e, alphabet: t }) => {
  const { encode: i2, decode: s } = Ri(t, e);
  return q3({ prefix: r, name: e, encode: i2, decode: (n2) => Ce2(s(n2)) });
};
var zi = (r, e, t, i2) => {
  const s = {};
  for (let l = 0; l < e.length; ++l)
    s[e[l]] = l;
  let n2 = r.length;
  for (; r[n2 - 1] === "="; )
    --n2;
  const a3 = new Uint8Array(n2 * t / 8 | 0);
  let o2 = 0, h3 = 0, d = 0;
  for (let l = 0; l < n2; ++l) {
    const g3 = s[r[l]];
    if (g3 === void 0)
      throw new SyntaxError(`Non-${i2} character`);
    h3 = h3 << t | g3, o2 += t, o2 >= 8 && (o2 -= 8, a3[d++] = 255 & h3 >> o2);
  }
  if (o2 >= t || 255 & h3 << 8 - o2)
    throw new SyntaxError("Unexpected end of data");
  return a3;
};
var Ni = (r, e, t) => {
  const i2 = e[e.length - 1] === "=", s = (1 << t) - 1;
  let n2 = "", a3 = 0, o2 = 0;
  for (let h3 = 0; h3 < r.length; ++h3)
    for (o2 = o2 << 8 | r[h3], a3 += 8; a3 > t; )
      a3 -= t, n2 += e[s & o2 >> a3];
  if (a3 && (n2 += e[s & o2 << t - a3]), i2)
    for (; n2.length * t & 7; )
      n2 += "=";
  return n2;
};
var p2 = ({ name: r, prefix: e, bitsPerChar: t, alphabet: i2 }) => q3({ prefix: e, name: r, encode(s) {
  return Ni(s, i2, t);
}, decode(s) {
  return zi(s, i2, t, r);
} });
var Ui = q3({ prefix: "\0", name: "identity", encode: (r) => Pi(r), decode: (r) => Si(r) });
var Li = Object.freeze({ __proto__: null, identity: Ui });
var Fi = p2({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var Mi = Object.freeze({ __proto__: null, base2: Fi });
var $i = p2({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var Ki = Object.freeze({ __proto__: null, base8: $i });
var ki = F2({ prefix: "9", name: "base10", alphabet: "0123456789" });
var Bi = Object.freeze({ __proto__: null, base10: ki });
var ji = p2({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var Vi = p2({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var qi = Object.freeze({ __proto__: null, base16: ji, base16upper: Vi });
var Gi = p2({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var Yi = p2({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var Ji = p2({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var Hi = p2({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var Xi = p2({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var Wi = p2({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var Zi = p2({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var Qi = p2({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var es = p2({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var ts = Object.freeze({ __proto__: null, base32: Gi, base32upper: Yi, base32pad: Ji, base32padupper: Hi, base32hex: Xi, base32hexupper: Wi, base32hexpad: Zi, base32hexpadupper: Qi, base32z: es });
var is = F2({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var ss = F2({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var rs = Object.freeze({ __proto__: null, base36: is, base36upper: ss });
var ns = F2({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var as = F2({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var os = Object.freeze({ __proto__: null, base58btc: ns, base58flickr: as });
var hs = p2({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var cs = p2({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var us = p2({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var ls = p2({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var ds = Object.freeze({ __proto__: null, base64: hs, base64pad: cs, base64url: us, base64urlpad: ls });
var Re2 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var gs = Re2.reduce((r, e, t) => (r[t] = e, r), []);
var ps = Re2.reduce((r, e, t) => (r[e.codePointAt(0)] = t, r), []);
function Ds(r) {
  return r.reduce((e, t) => (e += gs[t], e), "");
}
function ys(r) {
  const e = [];
  for (const t of r) {
    const i2 = ps[t.codePointAt(0)];
    if (i2 === void 0)
      throw new Error(`Non-base256emoji character: ${t}`);
    e.push(i2);
  }
  return new Uint8Array(e);
}
var bs = q3({ prefix: "\u{1F680}", name: "base256emoji", encode: Ds, decode: ys });
var ms = Object.freeze({ __proto__: null, base256emoji: bs });
var Es = Pe2;
var Se2 = 128;
var fs = 127;
var ws = ~fs;
var vs = Math.pow(2, 31);
function Pe2(r, e, t) {
  e = e || [], t = t || 0;
  for (var i2 = t; r >= vs; )
    e[t++] = r & 255 | Se2, r /= 128;
  for (; r & ws; )
    e[t++] = r & 255 | Se2, r >>>= 7;
  return e[t] = r | 0, Pe2.bytes = t - i2 + 1, e;
}
var Is = se2;
var Cs = 128;
var Te2 = 127;
function se2(r, i2) {
  var t = 0, i2 = i2 || 0, s = 0, n2 = i2, a3, o2 = r.length;
  do {
    if (n2 >= o2)
      throw se2.bytes = 0, new RangeError("Could not decode varint");
    a3 = r[n2++], t += s < 28 ? (a3 & Te2) << s : (a3 & Te2) * Math.pow(2, s), s += 7;
  } while (a3 >= Cs);
  return se2.bytes = n2 - i2, t;
}
var _s = Math.pow(2, 7);
var Rs = Math.pow(2, 14);
var Ss = Math.pow(2, 21);
var Ps = Math.pow(2, 28);
var Ts = Math.pow(2, 35);
var xs = Math.pow(2, 42);
var Os = Math.pow(2, 49);
var As = Math.pow(2, 56);
var zs = Math.pow(2, 63);
var Ns = function(r) {
  return r < _s ? 1 : r < Rs ? 2 : r < Ss ? 3 : r < Ps ? 4 : r < Ts ? 5 : r < xs ? 6 : r < Os ? 7 : r < As ? 8 : r < zs ? 9 : 10;
};
var Us = { encode: Es, decode: Is, encodingLength: Ns };
var xe2 = Us;
var Oe2 = (r, e, t = 0) => (xe2.encode(r, e, t), e);
var Ae2 = (r) => xe2.encodingLength(r);
var re = (r, e) => {
  const t = e.byteLength, i2 = Ae2(r), s = i2 + Ae2(t), n2 = new Uint8Array(s + t);
  return Oe2(r, n2, 0), Oe2(t, n2, i2), n2.set(e, s), new Ls(r, t, e, n2);
};
var Ls = class {
  constructor(e, t, i2, s) {
    this.code = e, this.size = t, this.digest = i2, this.bytes = s;
  }
};
var ze2 = ({ name: r, code: e, encode: t }) => new Fs(r, e, t);
var Fs = class {
  constructor(e, t, i2) {
    this.name = e, this.code = t, this.encode = i2;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const t = this.encode(e);
      return t instanceof Uint8Array ? re(this.code, t) : t.then((i2) => re(this.code, i2));
    } else
      throw Error("Unknown type, must be binary type");
  }
};
var Ne = (r) => async (e) => new Uint8Array(await crypto.subtle.digest(r, e));
var Ms = ze2({ name: "sha2-256", code: 18, encode: Ne("SHA-256") });
var $s = ze2({ name: "sha2-512", code: 19, encode: Ne("SHA-512") });
var Ks = Object.freeze({ __proto__: null, sha256: Ms, sha512: $s });
var Ue2 = 0;
var ks = "identity";
var Le = Ce2;
var Bs = (r) => re(Ue2, Le(r));
var js = { code: Ue2, name: ks, encode: Le, digest: Bs };
var Vs = Object.freeze({ __proto__: null, identity: js });
new TextEncoder(), new TextDecoder();
var Fe2 = { ...Li, ...Mi, ...Ki, ...Bi, ...qi, ...ts, ...rs, ...os, ...ds, ...ms };
({ ...Ks, ...Vs });
function qs(r = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(r) : new Uint8Array(r);
}
function Me2(r, e, t, i2) {
  return { name: r, prefix: e, encoder: { name: r, prefix: e, encode: t }, decoder: { decode: i2 } };
}
var $e2 = Me2("utf8", "u", (r) => "u" + new TextDecoder("utf8").decode(r), (r) => new TextEncoder().encode(r.substring(1)));
var ne2 = Me2("ascii", "a", (r) => {
  let e = "a";
  for (let t = 0; t < r.length; t++)
    e += String.fromCharCode(r[t]);
  return e;
}, (r) => {
  r = r.substring(1);
  const e = qs(r.length);
  for (let t = 0; t < r.length; t++)
    e[t] = r.charCodeAt(t);
  return e;
});
var Gs = { utf8: $e2, "utf-8": $e2, hex: Fe2.base16, latin1: ne2, ascii: ne2, binary: ne2, ...Fe2 };
function Ys(r, e = "utf8") {
  const t = Gs[e];
  if (!t)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r, "utf8") : t.decoder.decode(`${t.prefix}${r}`);
}
var ae3 = "wc";
var Ke = 2;
var G2 = "core";
var T2 = `${ae3}@${2}:${G2}:`;
var ke = { name: G2, logger: "error" };
var Be = { database: ":memory:" };
var je2 = "crypto";
var oe2 = "client_ed25519_seed";
var Ve2 = import_time3.ONE_DAY;
var qe2 = "keychain";
var Ge = "0.3";
var Ye2 = "messages";
var Je2 = "0.3";
var He2 = import_time3.SIX_HOURS;
var Xe2 = "publisher";
var We2 = "irn";
var Ze2 = "error";
var he = "wss://relay.walletconnect.com";
var Qe = "relayer";
var D = { message: "relayer_message", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" };
var et2 = "_subscription";
var M = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" };
var tt2 = import_time3.ONE_SECOND;
var it2 = "2.6.0";
var st2 = "0.3";
var I = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" };
var rt2 = "subscription";
var nt2 = "0.3";
var at2 = import_time3.FIVE_SECONDS * 1e3;
var ot2 = "pairing";
var ht = "0.3";
var N2 = { wc_pairingDelete: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: import_time3.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: import_time3.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 0 } } };
var C4 = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" };
var ct2 = "history";
var ut2 = "0.3";
var lt2 = "expirer";
var m2 = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" };
var dt2 = "0.3";
var gt = class {
  constructor(e, t) {
    this.core = e, this.logger = t, this.keychain = /* @__PURE__ */ new Map(), this.name = qe2, this.version = Ge, this.initialized = false, this.storagePrefix = T2, this.init = async () => {
      if (!this.initialized) {
        const i2 = await this.getKeyChain();
        typeof i2 < "u" && (this.keychain = i2), this.initialized = true;
      }
    }, this.has = (i2) => (this.isInitialized(), this.keychain.has(i2)), this.set = async (i2, s) => {
      this.isInitialized(), this.keychain.set(i2, s), await this.persist();
    }, this.get = (i2) => {
      this.isInitialized();
      const s = this.keychain.get(i2);
      if (typeof s > "u") {
        const { message: n2 } = N("NO_MATCHING_KEY", `${this.name}: ${i2}`);
        throw new Error(n2);
      }
      return s;
    }, this.del = async (i2) => {
      this.isInitialized(), this.keychain.delete(i2), await this.persist();
    }, this.core = e, this.logger = (0, import_logger.generateChildLogger)(t, this.name);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, Gn(e));
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? Yn(e) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var pt2 = class {
  constructor(e, t, i2) {
    this.core = e, this.logger = t, this.name = je2, this.initialized = false, this.init = async () => {
      this.initialized || (await this.keychain.init(), this.initialized = true);
    }, this.hasKeys = (s) => (this.isInitialized(), this.keychain.has(s)), this.getClientId = async () => {
      this.isInitialized();
      const s = await this.getClientSeed(), n2 = generateKeyPair(s);
      return encodeIss(n2.publicKey);
    }, this.generateKeyPair = () => {
      this.isInitialized();
      const s = Rn();
      return this.setPrivateKey(s.publicKey, s.privateKey);
    }, this.signJWT = async (s) => {
      this.isInitialized();
      const n2 = await this.getClientSeed(), a3 = generateKeyPair(n2), o2 = An(), h3 = Ve2;
      return await signJWT(o2, s, h3, a3);
    }, this.generateSharedKey = (s, n2, a3) => {
      this.isInitialized();
      const o2 = this.getPrivateKey(s), h3 = Un(o2, n2);
      return this.setSymKey(h3, a3);
    }, this.setSymKey = async (s, n2) => {
      this.isInitialized();
      const a3 = n2 || _n(s);
      return await this.keychain.set(a3, s), a3;
    }, this.deleteKeyPair = async (s) => {
      this.isInitialized(), await this.keychain.del(s);
    }, this.deleteSymKey = async (s) => {
      this.isInitialized(), await this.keychain.del(s);
    }, this.encode = async (s, n2, a3) => {
      this.isInitialized();
      const o2 = Pe(a3), h3 = safeJsonStringify(n2);
      if (Dn(o2)) {
        const U4 = o2.senderPublicKey, J4 = o2.receiverPublicKey;
        s = await this.generateSharedKey(U4, J4);
      }
      const d = this.getSymKey(s), { type: l, senderPublicKey: g3 } = o2;
      return jn({ type: l, symKey: d, message: h3, senderPublicKey: g3 });
    }, this.decode = async (s, n2, a3) => {
      this.isInitialized();
      const o2 = $n(n2, a3);
      if (Dn(o2)) {
        const l = o2.receiverPublicKey, g3 = o2.senderPublicKey;
        s = await this.generateSharedKey(l, g3);
      }
      const h3 = this.getSymKey(s), d = Cn({ symKey: h3, encoded: n2 });
      return safeJsonParse(d);
    }, this.getPayloadType = (s) => {
      const n2 = Q(s);
      return j(n2.type);
    }, this.getPayloadSenderPublicKey = (s) => {
      const n2 = Q(s);
      return n2.senderPublicKey ? toString(n2.senderPublicKey, f) : void 0;
    }, this.core = e, this.logger = (0, import_logger.generateChildLogger)(t, this.name), this.keychain = i2 || new gt(this.core, this.logger);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  async setPrivateKey(e, t) {
    return await this.keychain.set(e, t), e;
  }
  getPrivateKey(e) {
    return this.keychain.get(e);
  }
  async getClientSeed() {
    let e = "";
    try {
      e = this.keychain.get(oe2);
    } catch {
      e = An(), await this.keychain.set(oe2, e);
    }
    return Ys(e, "base16");
  }
  getSymKey(e) {
    return this.keychain.get(e);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Dt2 = class extends a {
  constructor(e, t) {
    super(e, t), this.logger = e, this.core = t, this.messages = /* @__PURE__ */ new Map(), this.name = Ye2, this.version = Je2, this.initialized = false, this.storagePrefix = T2, this.init = async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const i2 = await this.getRelayerMessages();
          typeof i2 < "u" && (this.messages = i2), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (i2) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(i2);
        } finally {
          this.initialized = true;
        }
      }
    }, this.set = async (i2, s) => {
      this.isInitialized();
      const n2 = wn(s);
      let a3 = this.messages.get(i2);
      return typeof a3 > "u" && (a3 = {}), typeof a3[n2] < "u" || (a3[n2] = s, this.messages.set(i2, a3), await this.persist()), n2;
    }, this.get = (i2) => {
      this.isInitialized();
      let s = this.messages.get(i2);
      return typeof s > "u" && (s = {}), s;
    }, this.has = (i2, s) => {
      this.isInitialized();
      const n2 = this.get(i2), a3 = wn(s);
      return typeof n2[a3] < "u";
    }, this.del = async (i2) => {
      this.isInitialized(), this.messages.delete(i2), await this.persist();
    }, this.logger = (0, import_logger.generateChildLogger)(e, this.name), this.core = t;
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, Gn(e));
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? Yn(e) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Zs = class extends u {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, this.events = new import_events5.EventEmitter(), this.name = Xe2, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = 1e4, this.publish = async (i2, s, n2) => {
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i2, message: s, opts: n2 } });
      try {
        const a3 = (n2 == null ? void 0 : n2.ttl) || He2, o2 = it(n2), h3 = (n2 == null ? void 0 : n2.prompt) || false, d = (n2 == null ? void 0 : n2.tag) || 0, l = { topic: i2, message: s, opts: { ttl: a3, relay: o2, prompt: h3, tag: d } }, g3 = wn(s);
        this.queue.set(g3, l);
        try {
          await await Xn(this.rpcPublish(i2, s, a3, o2, h3, d), this.publishTimeout), this.relayer.events.emit(D.publish, l);
        } catch {
          this.logger.debug("Publishing Payload stalled"), this.relayer.events.emit(D.connection_stalled);
          return;
        }
        this.onPublish(g3, l), this.logger.debug("Successfully Published Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i2, message: s, opts: n2 } });
      } catch (a3) {
        throw this.logger.debug("Failed to Publish Payload"), this.logger.error(a3), a3;
      }
    }, this.on = (i2, s) => {
      this.events.on(i2, s);
    }, this.once = (i2, s) => {
      this.events.once(i2, s);
    }, this.off = (i2, s) => {
      this.events.off(i2, s);
    }, this.removeListener = (i2, s) => {
      this.events.removeListener(i2, s);
    }, this.relayer = e, this.logger = (0, import_logger.generateChildLogger)(t, this.name), this.registerEventListeners();
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  rpcPublish(e, t, i2, s, n2, a3) {
    var o2, h3, d, l;
    const g3 = { method: ct(s.protocol).publish, params: { topic: e, message: t, ttl: i2, prompt: n2, tag: a3 } };
    return S((o2 = g3.params) == null ? void 0 : o2.prompt) && ((h3 = g3.params) == null || delete h3.prompt), S((d = g3.params) == null ? void 0 : d.tag) && ((l = g3.params) == null || delete l.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: g3 }), this.relayer.request(g3);
  }
  onPublish(e, t) {
    this.queue.delete(e);
  }
  checkQueue() {
    this.queue.forEach(async (e) => {
      const { topic: t, message: i2, opts: s } = e;
      await this.publish(t, i2, s);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, () => {
      this.checkQueue();
    });
  }
};
var Qs = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map(), this.set = (e, t) => {
      const i2 = this.get(e);
      this.exists(e, t) || this.map.set(e, [...i2, t]);
    }, this.get = (e) => this.map.get(e) || [], this.exists = (e, t) => this.get(e).includes(t), this.delete = (e, t) => {
      if (typeof t > "u") {
        this.map.delete(e);
        return;
      }
      if (!this.map.has(e))
        return;
      const i2 = this.get(e);
      if (!this.exists(e, t))
        return;
      const s = i2.filter((n2) => n2 !== t);
      if (!s.length) {
        this.map.delete(e);
        return;
      }
      this.map.set(e, s);
    }, this.clear = () => {
      this.map.clear();
    };
  }
  get topics() {
    return Array.from(this.map.keys());
  }
};
var er = Object.defineProperty;
var tr = Object.defineProperties;
var ir = Object.getOwnPropertyDescriptors;
var yt = Object.getOwnPropertySymbols;
var sr = Object.prototype.hasOwnProperty;
var rr = Object.prototype.propertyIsEnumerable;
var bt2 = (r, e, t) => e in r ? er(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var $3 = (r, e) => {
  for (var t in e || (e = {}))
    sr.call(e, t) && bt2(r, t, e[t]);
  if (yt)
    for (var t of yt(e))
      rr.call(e, t) && bt2(r, t, e[t]);
  return r;
};
var ce3 = (r, e) => tr(r, ir(e));
var mt = class extends x {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new Qs(), this.events = new import_events5.EventEmitter(), this.name = rt2, this.version = nt2, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = false, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = T2, this.subscribeTimeout = 1e4, this.restartInProgress = false, this.batchSubscribeTopicsLimit = 500, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restart(), this.registerEventListeners(), this.onEnable(), this.clientId = await this.relayer.core.crypto.getClientId());
    }, this.subscribe = async (i2, s) => {
      await this.restartToComplete(), this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i2, opts: s } });
      try {
        const n2 = it(s), a3 = { topic: i2, relay: n2 };
        this.pending.set(i2, a3);
        const o2 = await this.rpcSubscribe(i2, n2);
        return this.onSubscribe(o2, a3), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i2, opts: s } }), o2;
      } catch (n2) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(n2), n2;
      }
    }, this.unsubscribe = async (i2, s) => {
      await this.restartToComplete(), this.isInitialized(), typeof (s == null ? void 0 : s.id) < "u" ? await this.unsubscribeById(i2, s.id, s) : await this.unsubscribeByTopic(i2, s);
    }, this.isSubscribed = async (i2) => this.topics.includes(i2) ? true : await new Promise((s, n2) => {
      const a3 = new import_time3.Watch();
      a3.start(this.pendingSubscriptionWatchLabel);
      const o2 = setInterval(() => {
        !this.pending.has(i2) && this.topics.includes(i2) && (clearInterval(o2), a3.stop(this.pendingSubscriptionWatchLabel), s(true)), a3.elapsed(this.pendingSubscriptionWatchLabel) >= at2 && (clearInterval(o2), a3.stop(this.pendingSubscriptionWatchLabel), n2(false));
      }, this.pollingInterval);
    }), this.on = (i2, s) => {
      this.events.on(i2, s);
    }, this.once = (i2, s) => {
      this.events.once(i2, s);
    }, this.off = (i2, s) => {
      this.events.off(i2, s);
    }, this.removeListener = (i2, s) => {
      this.events.removeListener(i2, s);
    }, this.restart = async () => {
      this.restartInProgress = true, await this.restore(), await this.reset(), this.restartInProgress = false;
    }, this.relayer = e, this.logger = (0, import_logger.generateChildLogger)(t, this.name), this.clientId = "";
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  hasSubscription(e, t) {
    let i2 = false;
    try {
      i2 = this.getSubscription(e).topic === t;
    } catch {
    }
    return i2;
  }
  onEnable() {
    this.cached = [], this.initialized = true;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e, t) {
    const i2 = this.topicMap.get(e);
    await Promise.all(i2.map(async (s) => await this.unsubscribeById(e, s, t)));
  }
  async unsubscribeById(e, t, i2) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: i2 } });
    try {
      const s = it(i2);
      await this.rpcUnsubscribe(e, t, s);
      const n2 = R2("USER_DISCONNECTED", `${this.name}, ${e}`);
      await this.onUnsubscribe(e, t, n2), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: i2 } });
    } catch (s) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(s), s;
    }
  }
  async rpcSubscribe(e, t) {
    const i2 = { method: ct(t.protocol).subscribe, params: { topic: e } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i2 });
    try {
      await await Xn(this.relayer.request(i2), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(D.connection_stalled);
    }
    return wn(e + this.clientId);
  }
  async rpcBatchSubscribe(e) {
    if (!e.length)
      return;
    const t = e[0].relay, i2 = { method: ct(t.protocol).batchSubscribe, params: { topics: e.map((s) => s.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i2 });
    try {
      return await await Xn(this.relayer.request(i2), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Payload stalled"), this.relayer.events.emit(D.connection_stalled);
    }
  }
  rpcUnsubscribe(e, t, i2) {
    const s = { method: ct(i2.protocol).unsubscribe, params: { topic: e, id: t } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s }), this.relayer.request(s);
  }
  onSubscribe(e, t) {
    this.setSubscription(e, ce3($3({}, t), { id: e })), this.pending.delete(t.topic);
  }
  onBatchSubscribe(e) {
    e.length && e.forEach((t) => {
      this.setSubscription(t.id, $3({}, t)), this.pending.delete(t.topic);
    });
  }
  async onUnsubscribe(e, t, i2) {
    this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, i2), await this.relayer.messages.del(e);
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e, t) {
    this.subscriptions.has(e) || (this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e, subscription: t }), this.addSubscription(e, t));
  }
  addSubscription(e, t) {
    this.subscriptions.set(e, $3({}, t)), this.topicMap.set(t.topic, e), this.events.emit(I.created, t);
  }
  getSubscription(e) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e });
    const t = this.subscriptions.get(e);
    if (!t) {
      const { message: i2 } = N("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(i2);
    }
    return t;
  }
  deleteSubscription(e, t) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e, reason: t });
    const i2 = this.getSubscription(e);
    this.subscriptions.delete(e), this.topicMap.delete(i2.topic, e), this.events.emit(I.deleted, ce3($3({}, i2), { reason: t }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(I.sync);
  }
  async reset() {
    if (!this.cached.length)
      return;
    const e = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
    for (let t = 0; t < e; t++) {
      const i2 = this.cached.splice(0, this.batchSubscribeTopicsLimit);
      await this.batchSubscribe(i2);
    }
    this.events.emit(I.resubscribed);
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions();
      if (typeof e > "u" || !e.length)
        return;
      if (this.subscriptions.size) {
        const { message: t } = N("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);
    }
  }
  async batchSubscribe(e) {
    if (!e.length)
      return;
    const t = await this.rpcBatchSubscribe(e);
    C3(t) && this.onBatchSubscribe(t.map((i2, s) => ce3($3({}, e[s]), { id: i2 })));
  }
  async onConnect() {
    this.restartInProgress || (await this.restart(), this.onEnable());
  }
  onDisconnect() {
    this.onDisable();
  }
  async checkPending() {
    if (this.relayer.transportExplicitlyClosed)
      return;
    const e = [];
    this.pending.forEach((t) => {
      e.push(t);
    }), await this.batchSubscribe(e);
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, async () => {
      await this.checkPending();
    }), this.relayer.on(D.connect, async () => {
      await this.onConnect();
    }), this.relayer.on(D.disconnect, () => {
      this.onDisconnect();
    }), this.events.on(I.created, async (e) => {
      const t = I.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), await this.persist();
    }), this.events.on(I.deleted, async (e) => {
      const t = I.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), await this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async restartToComplete() {
    this.restartInProgress && await new Promise((e) => {
      const t = setInterval(() => {
        this.restartInProgress || (clearInterval(t), e());
      }, this.pollingInterval);
    });
  }
};
var nr = Object.defineProperty;
var Et = Object.getOwnPropertySymbols;
var ar = Object.prototype.hasOwnProperty;
var or = Object.prototype.propertyIsEnumerable;
var ft2 = (r, e, t) => e in r ? nr(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var hr = (r, e) => {
  for (var t in e || (e = {}))
    ar.call(e, t) && ft2(r, t, e[t]);
  if (Et)
    for (var t of Et(e))
      or.call(e, t) && ft2(r, t, e[t]);
  return r;
};
var wt2 = class extends g {
  constructor(e) {
    super(e), this.protocol = "wc", this.version = 2, this.events = new import_events5.EventEmitter(), this.name = Qe, this.transportExplicitlyClosed = false, this.initialized = false, this.reconnecting = false, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "socket stalled"], this.request = async (t) => {
      this.logger.debug("Publishing Request Payload");
      try {
        return await this.toEstablishConnection(), await this.provider.request(t);
      } catch (i2) {
        throw this.logger.debug("Failed to Publish Request"), this.logger.error(i2), i2;
      }
    }, this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? (0, import_logger.generateChildLogger)(e.logger, this.name) : (0, import_pino.default)((0, import_logger.getDefaultLoggerOptions)({ level: e.logger || Ze2 })), this.messages = new Dt2(this.logger, e.core), this.subscriber = new mt(this, this.logger), this.publisher = new Zs(this, this.logger), this.relayUrl = (e == null ? void 0 : e.relayUrl) || he, this.projectId = e.projectId, this.provider = {};
  }
  async init() {
    this.logger.trace("Initialized"), await this.createProvider(), await Promise.all([this.messages.init(), this.transportOpen(), this.subscriber.init()]), this.registerEventListeners(), this.initialized = true;
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get connected() {
    return this.provider.connection.connected;
  }
  get connecting() {
    return this.provider.connection.connecting;
  }
  async publish(e, t, i2) {
    this.isInitialized(), await this.publisher.publish(e, t, i2), await this.recordMessageEvent({ topic: e, message: t, publishedAt: Date.now() });
  }
  async subscribe(e, t) {
    this.isInitialized();
    let i2 = "";
    return await Promise.all([new Promise((s) => {
      this.subscriber.once(I.created, (n2) => {
        n2.topic === e && s();
      });
    }), new Promise(async (s) => {
      i2 = await this.subscriber.subscribe(e, t), s();
    })]), i2;
  }
  async unsubscribe(e, t) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, t);
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async transportClose() {
    this.transportExplicitlyClosed = true, this.connected && (await this.provider.disconnect(), this.events.emit(D.transport_closed));
  }
  async transportOpen(e) {
    if (!this.reconnecting) {
      this.relayUrl = e || this.relayUrl, this.transportExplicitlyClosed = false, this.reconnecting = true;
      try {
        await Promise.all([new Promise((t) => {
          this.initialized || t(), this.subscriber.once(I.resubscribed, () => {
            t();
          });
        }), await Promise.race([new Promise(async (t, i2) => {
          await Xn(this.provider.connect(), 5e3, "socket stalled").catch((s) => i2(s)).then(() => t()).finally(() => this.removeListener(D.transport_closed, this.rejectTransportOpen));
        }), new Promise((t) => this.once(D.transport_closed, this.rejectTransportOpen))])]);
      } catch (t) {
        this.logger.error(t);
        const i2 = t;
        if (!this.isConnectionStalled(i2.message))
          throw t;
        this.events.emit(D.transport_closed);
      } finally {
        this.reconnecting = false;
      }
    }
  }
  async restartTransport(e) {
    this.transportExplicitlyClosed || (this.relayUrl = e || this.relayUrl, await this.transportClose(), await this.createProvider(), await this.transportOpen());
  }
  isConnectionStalled(e) {
    return this.staleConnectionErrors.some((t) => e.includes(t));
  }
  rejectTransportOpen() {
    throw new Error("closeTransport called before connection was established");
  }
  async createProvider() {
    const e = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new JsonRpcProvider2(new esm_default2(Hn({ sdkVersion: it2, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: true }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e) {
    const { topic: t, message: i2 } = e;
    await this.messages.set(t, i2);
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: t, message: i2 } = e;
    return await this.subscriber.isSubscribed(t) ? this.messages.has(t, i2) : true;
  }
  async onProviderPayload(e) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e }), isJsonRpcRequest(e)) {
      if (!e.method.endsWith(et2))
        return;
      const t = e.params, { topic: i2, message: s, publishedAt: n2 } = t.data, a3 = { topic: i2, message: s, publishedAt: n2 };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(hr({ type: "event", event: t.id }, a3)), this.events.emit(t.id, a3), await this.acknowledgePayload(e), await this.onMessageEvent(a3);
    }
  }
  async onMessageEvent(e) {
    await this.shouldIgnoreMessageEvent(e) || (this.events.emit(D.message, e), await this.recordMessageEvent(e));
  }
  async acknowledgePayload(e) {
    const t = formatJsonRpcResult(e.id, true);
    await this.provider.connection.send(t);
  }
  registerProviderListeners() {
    this.provider.on(M.payload, (e) => this.onProviderPayload(e)), this.provider.on(M.connect, () => {
      this.events.emit(D.connect);
    }), this.provider.on(M.disconnect, () => {
      this.onProviderDisconnect();
    }), this.provider.on(M.error, (e) => {
      this.logger.error(e), this.events.emit(D.error, e);
    });
  }
  registerEventListeners() {
    this.events.on(D.connection_stalled, async () => {
      await this.restartTransport();
    });
  }
  onProviderDisconnect() {
    this.events.emit(D.disconnect), this.attemptToReconnect();
  }
  attemptToReconnect() {
    this.transportExplicitlyClosed || setTimeout(async () => {
      await this.restartTransport();
    }, (0, import_time3.toMiliseconds)(tt2));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async toEstablishConnection() {
    if (!this.connected) {
      if (this.connecting)
        return await new Promise((e) => {
          const t = setInterval(() => {
            this.connected && (clearInterval(t), e());
          }, this.connectionStatusPollingInterval);
        });
      await this.restartTransport();
    }
  }
};
var cr = Object.defineProperty;
var vt = Object.getOwnPropertySymbols;
var ur = Object.prototype.hasOwnProperty;
var lr = Object.prototype.propertyIsEnumerable;
var It2 = (r, e, t) => e in r ? cr(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var Ct2 = (r, e) => {
  for (var t in e || (e = {}))
    ur.call(e, t) && It2(r, t, e[t]);
  if (vt)
    for (var t of vt(e))
      lr.call(e, t) && It2(r, t, e[t]);
  return r;
};
var _t2 = class extends p {
  constructor(e, t, i2, s = T2, n2 = void 0) {
    super(e, t, i2, s), this.core = e, this.logger = t, this.name = i2, this.map = /* @__PURE__ */ new Map(), this.version = st2, this.cached = [], this.initialized = false, this.storagePrefix = T2, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((a3) => {
        this.getKey && a3 !== null && !S(a3) ? this.map.set(this.getKey(a3), a3) : Rt(a3) ? this.map.set(a3.id, a3) : At(a3) && this.map.set(a3.topic, a3);
      }), this.cached = [], this.initialized = true);
    }, this.set = async (a3, o2) => {
      this.isInitialized(), this.map.has(a3) ? await this.update(a3, o2) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: a3, value: o2 }), this.map.set(a3, o2), await this.persist());
    }, this.get = (a3) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: a3 }), this.getData(a3)), this.getAll = (a3) => (this.isInitialized(), a3 ? this.values.filter((o2) => Object.keys(a3).every((h3) => (0, import_lodash.default)(o2[h3], a3[h3]))) : this.values), this.update = async (a3, o2) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: a3, update: o2 });
      const h3 = Ct2(Ct2({}, this.getData(a3)), o2);
      this.map.set(a3, h3), await this.persist();
    }, this.delete = async (a3, o2) => {
      this.isInitialized(), this.map.has(a3) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: a3, reason: o2 }), this.map.delete(a3), await this.persist());
    }, this.logger = (0, import_logger.generateChildLogger)(t, this.name), this.storagePrefix = s, this.getKey = n2;
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e) {
    const t = this.map.get(e);
    if (!t) {
      const { message: i2 } = N("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(i2), new Error(i2);
    }
    return t;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e = await this.getDataStore();
      if (typeof e > "u" || !e.length)
        return;
      if (this.map.size) {
        const { message: t } = N("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Rt2 = class {
  constructor(e, t) {
    this.core = e, this.logger = t, this.name = ot2, this.version = ht, this.events = new import_events5.default(), this.initialized = false, this.storagePrefix = T2, this.ignoredPayloadTypes = [U], this.registeredMethods = [], this.init = async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
    }, this.register = ({ methods: i2 }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...i2])];
    }, this.create = async () => {
      this.isInitialized();
      const i2 = An(), s = await this.core.crypto.setSymKey(i2), n2 = rt(import_time3.FIVE_MINUTES), a3 = { protocol: We2 }, o2 = { topic: s, expiry: n2, relay: a3, active: false }, h3 = pt({ protocol: this.core.protocol, version: this.core.version, topic: s, symKey: i2, relay: a3 });
      return await this.pairings.set(s, o2), await this.core.relayer.subscribe(s), this.core.expirer.set(s, n2), { topic: s, uri: h3 };
    }, this.pair = async (i2) => {
      this.isInitialized(), this.isValidPair(i2);
      const { topic: s, symKey: n2, relay: a3 } = ft(i2.uri);
      if (this.pairings.keys.includes(s))
        throw new Error(`Pairing already exists: ${s}`);
      if (this.core.crypto.hasKeys(s))
        throw new Error(`Keychain already exists: ${s}`);
      const o2 = rt(import_time3.FIVE_MINUTES), h3 = { topic: s, relay: a3, expiry: o2, active: false };
      return await this.pairings.set(s, h3), await this.core.crypto.setSymKey(n2, s), await this.core.relayer.subscribe(s, { relay: a3 }), this.core.expirer.set(s, o2), i2.activatePairing && await this.activate({ topic: s }), h3;
    }, this.activate = async ({ topic: i2 }) => {
      this.isInitialized();
      const s = rt(import_time3.THIRTY_DAYS);
      await this.pairings.update(i2, { active: true, expiry: s }), this.core.expirer.set(i2, s);
    }, this.ping = async (i2) => {
      this.isInitialized(), await this.isValidPing(i2);
      const { topic: s } = i2;
      if (this.pairings.keys.includes(s)) {
        const n2 = await this.sendRequest(s, "wc_pairingPing", {}), { done: a3, resolve: o2, reject: h3 } = Zn();
        this.events.once(st("pairing_ping", n2), ({ error: d }) => {
          d ? h3(d) : o2();
        }), await a3();
      }
    }, this.updateExpiry = async ({ topic: i2, expiry: s }) => {
      this.isInitialized(), await this.pairings.update(i2, { expiry: s });
    }, this.updateMetadata = async ({ topic: i2, metadata: s }) => {
      this.isInitialized(), await this.pairings.update(i2, { peerMetadata: s });
    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (i2) => {
      this.isInitialized(), await this.isValidDisconnect(i2);
      const { topic: s } = i2;
      this.pairings.keys.includes(s) && (await this.sendRequest(s, "wc_pairingDelete", R2("USER_DISCONNECTED")), await this.deletePairing(s));
    }, this.sendRequest = async (i2, s, n2) => {
      const a3 = formatJsonRpcRequest(s, n2), o2 = await this.core.crypto.encode(i2, a3), h3 = N2[s].req;
      return this.core.history.set(i2, a3), await this.core.relayer.publish(i2, o2, h3), a3.id;
    }, this.sendResult = async (i2, s, n2) => {
      const a3 = formatJsonRpcResult(i2, n2), o2 = await this.core.crypto.encode(s, a3), h3 = await this.core.history.get(s, i2), d = N2[h3.request.method].res;
      await this.core.relayer.publish(s, o2, d), await this.core.history.resolve(a3);
    }, this.sendError = async (i2, s, n2) => {
      const a3 = formatJsonRpcError(i2, n2), o2 = await this.core.crypto.encode(s, a3), h3 = await this.core.history.get(s, i2), d = N2[h3.request.method] ? N2[h3.request.method].res : N2.unregistered_method.res;
      await this.core.relayer.publish(s, o2, d), await this.core.history.resolve(a3);
    }, this.deletePairing = async (i2, s) => {
      await this.core.relayer.unsubscribe(i2), await Promise.all([this.pairings.delete(i2, R2("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(i2), s ? Promise.resolve() : this.core.expirer.del(i2)]);
    }, this.cleanup = async () => {
      const i2 = this.pairings.getAll().filter((s) => ot(s.expiry));
      await Promise.all(i2.map((s) => this.deletePairing(s.topic)));
    }, this.onRelayEventRequest = (i2) => {
      const { topic: s, payload: n2 } = i2, a3 = n2.method;
      if (this.pairings.keys.includes(s))
        switch (a3) {
          case "wc_pairingPing":
            return this.onPairingPingRequest(s, n2);
          case "wc_pairingDelete":
            return this.onPairingDeleteRequest(s, n2);
          default:
            return this.onUnknownRpcMethodRequest(s, n2);
        }
    }, this.onRelayEventResponse = async (i2) => {
      const { topic: s, payload: n2 } = i2, a3 = (await this.core.history.get(s, n2.id)).request.method;
      if (this.pairings.keys.includes(s))
        switch (a3) {
          case "wc_pairingPing":
            return this.onPairingPingResponse(s, n2);
          default:
            return this.onUnknownRpcMethodResponse(a3);
        }
    }, this.onPairingPingRequest = async (i2, s) => {
      const { id: n2 } = s;
      try {
        this.isValidPing({ topic: i2 }), await this.sendResult(n2, i2, true), this.events.emit("pairing_ping", { id: n2, topic: i2 });
      } catch (a3) {
        await this.sendError(n2, i2, a3), this.logger.error(a3);
      }
    }, this.onPairingPingResponse = (i2, s) => {
      const { id: n2 } = s;
      setTimeout(() => {
        isJsonRpcResult(s) ? this.events.emit(st("pairing_ping", n2), {}) : isJsonRpcError(s) && this.events.emit(st("pairing_ping", n2), { error: s.error });
      }, 500);
    }, this.onPairingDeleteRequest = async (i2, s) => {
      const { id: n2 } = s;
      try {
        this.isValidDisconnect({ topic: i2 }), await this.deletePairing(i2), this.events.emit("pairing_delete", { id: n2, topic: i2 });
      } catch (a3) {
        await this.sendError(n2, i2, a3), this.logger.error(a3);
      }
    }, this.onUnknownRpcMethodRequest = async (i2, s) => {
      const { id: n2, method: a3 } = s;
      try {
        if (this.registeredMethods.includes(a3))
          return;
        const o2 = R2("WC_METHOD_UNSUPPORTED", a3);
        await this.sendError(n2, i2, o2), this.logger.error(o2);
      } catch (o2) {
        await this.sendError(n2, i2, o2), this.logger.error(o2);
      }
    }, this.onUnknownRpcMethodResponse = (i2) => {
      this.registeredMethods.includes(i2) || this.logger.error(R2("WC_METHOD_UNSUPPORTED", i2));
    }, this.isValidPair = (i2) => {
      if (!Ct(i2)) {
        const { message: s } = N("MISSING_OR_INVALID", `pair() params: ${i2}`);
        throw new Error(s);
      }
      if (!Tt(i2.uri)) {
        const { message: s } = N("MISSING_OR_INVALID", `pair() uri: ${i2.uri}`);
        throw new Error(s);
      }
    }, this.isValidPing = async (i2) => {
      if (!Ct(i2)) {
        const { message: n2 } = N("MISSING_OR_INVALID", `ping() params: ${i2}`);
        throw new Error(n2);
      }
      const { topic: s } = i2;
      await this.isValidPairingTopic(s);
    }, this.isValidDisconnect = async (i2) => {
      if (!Ct(i2)) {
        const { message: n2 } = N("MISSING_OR_INVALID", `disconnect() params: ${i2}`);
        throw new Error(n2);
      }
      const { topic: s } = i2;
      await this.isValidPairingTopic(s);
    }, this.isValidPairingTopic = async (i2) => {
      if (!m(i2, false)) {
        const { message: s } = N("MISSING_OR_INVALID", `pairing topic should be a string: ${i2}`);
        throw new Error(s);
      }
      if (!this.pairings.keys.includes(i2)) {
        const { message: s } = N("NO_MATCHING_KEY", `pairing topic doesn't exist: ${i2}`);
        throw new Error(s);
      }
      if (ot(this.pairings.get(i2).expiry)) {
        await this.deletePairing(i2);
        const { message: s } = N("EXPIRED", `pairing topic: ${i2}`);
        throw new Error(s);
      }
    }, this.core = e, this.logger = (0, import_logger.generateChildLogger)(t, this.name), this.pairings = new _t2(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(D.message, async (e) => {
      const { topic: t, message: i2 } = e;
      if (this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i2)))
        return;
      const s = await this.core.crypto.decode(t, i2);
      isJsonRpcRequest(s) ? (this.core.history.set(t, s), this.onRelayEventRequest({ topic: t, payload: s })) : isJsonRpcResponse(s) && (await this.core.history.resolve(s), this.onRelayEventResponse({ topic: t, payload: s }));
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(m2.expired, async (e) => {
      const { topic: t } = tt(e.target);
      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, true), this.events.emit("pairing_expire", { topic: t }));
    });
  }
};
var St3 = class extends h {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, this.records = /* @__PURE__ */ new Map(), this.events = new import_events5.EventEmitter(), this.name = ct2, this.version = ut2, this.cached = [], this.initialized = false, this.storagePrefix = T2, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i2) => this.records.set(i2.id, i2)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.set = (i2, s, n2) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: i2, request: s, chainId: n2 }), this.records.has(s.id))
        return;
      const a3 = { id: s.id, topic: i2, request: { method: s.method, params: s.params || null }, chainId: n2 };
      this.records.set(a3.id, a3), this.events.emit(C4.created, a3);
    }, this.resolve = async (i2) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: i2 }), !this.records.has(i2.id))
        return;
      const s = await this.getRecord(i2.id);
      typeof s.response > "u" && (s.response = isJsonRpcError(i2) ? { error: i2.error } : { result: i2.result }, this.records.set(s.id, s), this.events.emit(C4.updated, s));
    }, this.get = async (i2, s) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: i2, id: s }), await this.getRecord(s)), this.delete = (i2, s) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: s }), this.values.forEach((n2) => {
        if (n2.topic === i2) {
          if (typeof s < "u" && n2.id !== s)
            return;
          this.records.delete(n2.id), this.events.emit(C4.deleted, n2);
        }
      });
    }, this.exists = async (i2, s) => (this.isInitialized(), this.records.has(s) ? (await this.getRecord(s)).topic === i2 : false), this.on = (i2, s) => {
      this.events.on(i2, s);
    }, this.once = (i2, s) => {
      this.events.once(i2, s);
    }, this.off = (i2, s) => {
      this.events.off(i2, s);
    }, this.removeListener = (i2, s) => {
      this.events.removeListener(i2, s);
    }, this.logger = (0, import_logger.generateChildLogger)(t, this.name);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e = [];
    return this.values.forEach((t) => {
      if (typeof t.response < "u")
        return;
      const i2 = { topic: t.topic, request: formatJsonRpcRequest(t.request.method, t.request.params, t.id), chainId: t.chainId };
      return e.push(i2);
    }), e;
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e) {
    this.isInitialized();
    const t = this.records.get(e);
    if (!t) {
      const { message: i2 } = N("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(i2);
    }
    return t;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(C4.sync);
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords();
      if (typeof e > "u" || !e.length)
        return;
      if (this.records.size) {
        const { message: t } = N("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
    }
  }
  registerEventListeners() {
    this.events.on(C4.created, (e) => {
      const t = C4.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e }), this.persist();
    }), this.events.on(C4.updated, (e) => {
      const t = C4.updated;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e }), this.persist();
    }), this.events.on(C4.deleted, (e) => {
      const t = C4.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Pt2 = class extends E {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, this.expirations = /* @__PURE__ */ new Map(), this.events = new import_events5.EventEmitter(), this.name = lt2, this.version = dt2, this.cached = [], this.initialized = false, this.storagePrefix = T2, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i2) => this.expirations.set(i2.target, i2)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.has = (i2) => {
      try {
        const s = this.formatTarget(i2);
        return typeof this.getExpiration(s) < "u";
      } catch {
        return false;
      }
    }, this.set = (i2, s) => {
      this.isInitialized();
      const n2 = this.formatTarget(i2), a3 = { target: n2, expiry: s };
      this.expirations.set(n2, a3), this.checkExpiry(n2, a3), this.events.emit(m2.created, { target: n2, expiration: a3 });
    }, this.get = (i2) => {
      this.isInitialized();
      const s = this.formatTarget(i2);
      return this.getExpiration(s);
    }, this.del = (i2) => {
      if (this.isInitialized(), this.has(i2)) {
        const s = this.formatTarget(i2), n2 = this.getExpiration(s);
        this.expirations.delete(s), this.events.emit(m2.deleted, { target: s, expiration: n2 });
      }
    }, this.on = (i2, s) => {
      this.events.on(i2, s);
    }, this.once = (i2, s) => {
      this.events.once(i2, s);
    }, this.off = (i2, s) => {
      this.events.off(i2, s);
    }, this.removeListener = (i2, s) => {
      this.events.removeListener(i2, s);
    }, this.logger = (0, import_logger.generateChildLogger)(t, this.name);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e) {
    if (typeof e == "string")
      return et(e);
    if (typeof e == "number")
      return nt(e);
    const { message: t } = N("UNKNOWN_TYPE", `Target type: ${typeof e}`);
    throw new Error(t);
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(m2.sync);
  }
  async restore() {
    try {
      const e = await this.getExpirations();
      if (typeof e > "u" || !e.length)
        return;
      if (this.expirations.size) {
        const { message: t } = N("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);
    }
  }
  getExpiration(e) {
    const t = this.expirations.get(e);
    if (!t) {
      const { message: i2 } = N("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(i2), new Error(i2);
    }
    return t;
  }
  checkExpiry(e, t) {
    const { expiry: i2 } = t;
    (0, import_time3.toMiliseconds)(i2) - Date.now() <= 0 && this.expire(e, t);
  }
  expire(e, t) {
    this.expirations.delete(e), this.events.emit(m2.expired, { target: e, expiration: t });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e, t) => this.checkExpiry(t, e));
  }
  registerEventListeners() {
    this.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, () => this.checkExpirations()), this.events.on(m2.created, (e) => {
      const t = m2.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(m2.expired, (e) => {
      const t = m2.expired;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(m2.deleted, (e) => {
      const t = m2.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var dr = Object.defineProperty;
var Tt2 = Object.getOwnPropertySymbols;
var gr = Object.prototype.hasOwnProperty;
var pr = Object.prototype.propertyIsEnumerable;
var xt2 = (r, e, t) => e in r ? dr(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var Ot = (r, e) => {
  for (var t in e || (e = {}))
    gr.call(e, t) && xt2(r, t, e[t]);
  if (Tt2)
    for (var t of Tt2(e))
      pr.call(e, t) && xt2(r, t, e[t]);
  return r;
};
var Y2 = class extends n {
  constructor(e) {
    super(e), this.protocol = ae3, this.version = Ke, this.name = G2, this.events = new import_events5.EventEmitter(), this.initialized = false, this.on = (i2, s) => this.events.on(i2, s), this.once = (i2, s) => this.events.once(i2, s), this.off = (i2, s) => this.events.off(i2, s), this.removeListener = (i2, s) => this.events.removeListener(i2, s), this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || he;
    const t = typeof (e == null ? void 0 : e.logger) < "u" && typeof (e == null ? void 0 : e.logger) != "string" ? e.logger : (0, import_pino.default)((0, import_logger.getDefaultLoggerOptions)({ level: (e == null ? void 0 : e.logger) || ke.logger }));
    this.logger = (0, import_logger.generateChildLogger)(t, this.name), this.heartbeat = new import_heartbeat.HeartBeat(), this.crypto = new pt2(this, this.logger, e == null ? void 0 : e.keychain), this.history = new St3(this, this.logger), this.expirer = new Pt2(this, this.logger), this.storage = e != null && e.storage ? e.storage : new import_keyvaluestorage.default(Ot(Ot({}, Be), e == null ? void 0 : e.storageOptions)), this.relayer = new wt2({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new Rt2(this, this.logger);
  }
  static async init(e) {
    const t = new Y2(e);
    return await t.initialize(), t;
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.initialized = true, this.logger.info("Core Initialization Success");
    } catch (e) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;
    }
  }
};
var Dr = Y2;

// node_modules/@walletconnect/sign-client/dist/index.es.js
var import_logger2 = __toESM(require_cjs2());
var import_events6 = __toESM(require_events());
var import_time4 = __toESM(require_cjs());
init_esm3();
var k2 = "wc";
var X2 = 2;
var J2 = "client";
var C5 = `${k2}@${X2}:${J2}:`;
var G3 = { name: J2, logger: "error", controller: false, relayUrl: "wss://relay.walletconnect.com" };
var ee2 = "proposal";
var se3 = "Proposal expired";
var te = "session";
var b2 = import_time4.SEVEN_DAYS;
var ie4 = "engine";
var V2 = { wc_sessionPropose: { req: { ttl: import_time4.FIVE_MINUTES, prompt: true, tag: 1100 }, res: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1101 } }, wc_sessionSettle: { req: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1102 }, res: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1104 }, res: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1105 } }, wc_sessionExtend: { req: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1106 }, res: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1107 } }, wc_sessionRequest: { req: { ttl: import_time4.FIVE_MINUTES, prompt: true, tag: 1108 }, res: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1109 } }, wc_sessionEvent: { req: { ttl: import_time4.FIVE_MINUTES, prompt: true, tag: 1110 }, res: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1111 } }, wc_sessionDelete: { req: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1112 }, res: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1113 } }, wc_sessionPing: { req: { ttl: import_time4.THIRTY_SECONDS, prompt: false, tag: 1114 }, res: { ttl: import_time4.THIRTY_SECONDS, prompt: false, tag: 1115 } } };
var $4 = { min: import_time4.FIVE_MINUTES, max: import_time4.SEVEN_DAYS };
var ne3 = "request";
var Je3 = Object.defineProperty;
var He3 = Object.defineProperties;
var Fe3 = Object.getOwnPropertyDescriptors;
var oe3 = Object.getOwnPropertySymbols;
var Qe2 = Object.prototype.hasOwnProperty;
var Be2 = Object.prototype.propertyIsEnumerable;
var re2 = (d, n2, e) => n2 in d ? Je3(d, n2, { enumerable: true, configurable: true, writable: true, value: e }) : d[n2] = e;
var u2 = (d, n2) => {
  for (var e in n2 || (n2 = {}))
    Qe2.call(n2, e) && re2(d, e, n2[e]);
  if (oe3)
    for (var e of oe3(n2))
      Be2.call(n2, e) && re2(d, e, n2[e]);
  return d;
};
var H3 = (d, n2) => He3(d, Fe3(n2));
var We3 = class extends C2 {
  constructor(n2) {
    super(n2), this.name = ie4, this.events = new import_events6.default(), this.initialized = false, this.ignoredPayloadTypes = [U], this.init = async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.client.core.pairing.register({ methods: Object.keys(V2) }), this.initialized = true);
    }, this.connect = async (e) => {
      this.isInitialized();
      const s = H3(u2({}, e), { requiredNamespaces: e.requiredNamespaces || {}, optionalNamespaces: e.optionalNamespaces || {} });
      await this.isValidConnect(s);
      const { pairingTopic: t, requiredNamespaces: i2, optionalNamespaces: o2, sessionProperties: a3, relays: r } = s;
      let p4 = t, h3, E3 = false;
      if (p4 && (E3 = this.client.core.pairing.pairings.get(p4).active), !p4 || !E3) {
        const { topic: I4, uri: g3 } = await this.client.core.pairing.create();
        p4 = I4, h3 = g3;
      }
      const m5 = await this.client.core.crypto.generateKeyPair(), P2 = u2({ requiredNamespaces: i2, optionalNamespaces: o2, relays: r != null ? r : [{ protocol: We2 }], proposer: { publicKey: m5, metadata: this.client.metadata } }, a3 && { sessionProperties: a3 }), { reject: y4, resolve: T3, done: U4 } = Zn(import_time4.FIVE_MINUTES, se3);
      if (this.events.once(st("session_connect"), async ({ error: I4, session: g3 }) => {
        if (I4)
          y4(I4);
        else if (g3) {
          g3.self.publicKey = m5;
          const x5 = H3(u2({}, g3), { requiredNamespaces: g3.requiredNamespaces, optionalNamespaces: g3.optionalNamespaces });
          await this.client.session.set(g3.topic, x5), await this.setExpiry(g3.topic, g3.expiry), p4 && await this.client.core.pairing.updateMetadata({ topic: p4, metadata: g3.peer.metadata }), T3(x5);
        }
      }), !p4) {
        const { message: I4 } = N("NO_MATCHING_KEY", `connect() pairing topic: ${p4}`);
        throw new Error(I4);
      }
      const L2 = await this.sendRequest(p4, "wc_sessionPropose", P2), K4 = rt(import_time4.FIVE_MINUTES);
      return await this.setProposal(L2, u2({ id: L2, expiry: K4 }, P2)), { uri: h3, approval: U4 };
    }, this.pair = async (e) => (this.isInitialized(), await this.client.core.pairing.pair(e)), this.approve = async (e) => {
      this.isInitialized(), await this.isValidApprove(e);
      const { id: s, relayProtocol: t, namespaces: i2, sessionProperties: o2 } = e, a3 = this.client.proposal.get(s);
      let { pairingTopic: r, proposer: p4, requiredNamespaces: h3, optionalNamespaces: E3 } = a3;
      r = r || "", x2(h3) || (h3 = bt(i2, "approve()"));
      const m5 = await this.client.core.crypto.generateKeyPair(), P2 = p4.publicKey, y4 = await this.client.core.crypto.generateSharedKey(m5, P2);
      r && s && (await this.client.core.pairing.updateMetadata({ topic: r, metadata: p4.metadata }), await this.sendResult(s, r, { relay: { protocol: t != null ? t : "irn" }, responderPublicKey: m5 }), await this.client.proposal.delete(s, R2("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: r }));
      const T3 = u2({ relay: { protocol: t != null ? t : "irn" }, namespaces: i2, requiredNamespaces: h3, optionalNamespaces: E3, pairingTopic: r, controller: { publicKey: m5, metadata: this.client.metadata }, expiry: rt(b2) }, o2 && { sessionProperties: o2 });
      await this.client.core.relayer.subscribe(y4);
      const U4 = await this.sendRequest(y4, "wc_sessionSettle", T3), { done: L2, resolve: K4, reject: I4 } = Zn();
      this.events.once(st("session_approve", U4), ({ error: x5 }) => {
        x5 ? I4(x5) : K4(this.client.session.get(y4));
      });
      const g3 = H3(u2({}, T3), { topic: y4, pairingTopic: r, acknowledged: false, self: T3.controller, peer: { publicKey: p4.publicKey, metadata: p4.metadata }, controller: m5 });
      return await this.client.session.set(y4, g3), await this.setExpiry(y4, rt(b2)), { topic: y4, acknowledged: L2 };
    }, this.reject = async (e) => {
      this.isInitialized(), await this.isValidReject(e);
      const { id: s, reason: t } = e, { pairingTopic: i2 } = this.client.proposal.get(s);
      i2 && (await this.sendError(s, i2, t), await this.client.proposal.delete(s, R2("USER_DISCONNECTED")));
    }, this.update = async (e) => {
      this.isInitialized(), await this.isValidUpdate(e);
      const { topic: s, namespaces: t } = e, i2 = await this.sendRequest(s, "wc_sessionUpdate", { namespaces: t }), { done: o2, resolve: a3, reject: r } = Zn();
      return this.events.once(st("session_update", i2), ({ error: p4 }) => {
        p4 ? r(p4) : a3();
      }), await this.client.session.update(s, { namespaces: t }), { acknowledged: o2 };
    }, this.extend = async (e) => {
      this.isInitialized(), await this.isValidExtend(e);
      const { topic: s } = e, t = await this.sendRequest(s, "wc_sessionExtend", {}), { done: i2, resolve: o2, reject: a3 } = Zn();
      return this.events.once(st("session_extend", t), ({ error: r }) => {
        r ? a3(r) : o2();
      }), await this.setExpiry(s, rt(b2)), { acknowledged: i2 };
    }, this.request = async (e) => {
      this.isInitialized(), await this.isValidRequest(e);
      const { chainId: s, request: t, topic: i2, expiry: o2 } = e, a3 = await this.sendRequest(i2, "wc_sessionRequest", { request: t, chainId: s }, o2), { done: r, resolve: p4, reject: h3 } = Zn(o2);
      return this.events.once(st("session_request", a3), ({ error: E3, result: m5 }) => {
        E3 ? h3(E3) : p4(m5);
      }), this.client.events.emit("session_request_sent", { topic: i2, request: t, chainId: s, id: a3 }), await r();
    }, this.respond = async (e) => {
      this.isInitialized(), await this.isValidRespond(e);
      const { topic: s, response: t } = e, { id: i2 } = t;
      isJsonRpcResult(t) ? await this.sendResult(i2, s, t.result) : isJsonRpcError(t) && await this.sendError(i2, s, t.error), this.deletePendingSessionRequest(e.response.id, { message: "fulfilled", code: 0 });
    }, this.ping = async (e) => {
      this.isInitialized(), await this.isValidPing(e);
      const { topic: s } = e;
      if (this.client.session.keys.includes(s)) {
        const t = await this.sendRequest(s, "wc_sessionPing", {}), { done: i2, resolve: o2, reject: a3 } = Zn();
        this.events.once(st("session_ping", t), ({ error: r }) => {
          r ? a3(r) : o2();
        }), await i2();
      } else
        this.client.core.pairing.pairings.keys.includes(s) && await this.client.core.pairing.ping({ topic: s });
    }, this.emit = async (e) => {
      this.isInitialized(), await this.isValidEmit(e);
      const { topic: s, event: t, chainId: i2 } = e;
      await this.sendRequest(s, "wc_sessionEvent", { event: t, chainId: i2 });
    }, this.disconnect = async (e) => {
      this.isInitialized(), await this.isValidDisconnect(e);
      const { topic: s } = e;
      this.client.session.keys.includes(s) ? (await this.sendRequest(s, "wc_sessionDelete", R2("USER_DISCONNECTED")), await this.deleteSession(s)) : await this.client.core.pairing.disconnect({ topic: s });
    }, this.find = (e) => (this.isInitialized(), this.client.session.getAll().filter((s) => Pt(s, e))), this.getPendingSessionRequests = () => (this.isInitialized(), this.client.pendingRequest.getAll()), this.deleteSession = async (e, s) => {
      const { self: t } = this.client.session.get(e);
      await this.client.core.relayer.unsubscribe(e), await Promise.all([this.client.session.delete(e, R2("USER_DISCONNECTED")), this.client.core.crypto.deleteKeyPair(t.publicKey), this.client.core.crypto.deleteSymKey(e), s ? Promise.resolve() : this.client.core.expirer.del(e)]);
    }, this.deleteProposal = async (e, s) => {
      await Promise.all([this.client.proposal.delete(e, R2("USER_DISCONNECTED")), s ? Promise.resolve() : this.client.core.expirer.del(e)]);
    }, this.deletePendingSessionRequest = async (e, s, t = false) => {
      await Promise.all([this.client.pendingRequest.delete(e, s), t ? Promise.resolve() : this.client.core.expirer.del(e)]);
    }, this.setExpiry = async (e, s) => {
      this.client.session.keys.includes(e) && await this.client.session.update(e, { expiry: s }), this.client.core.expirer.set(e, s);
    }, this.setProposal = async (e, s) => {
      await this.client.proposal.set(e, s), this.client.core.expirer.set(e, s.expiry);
    }, this.setPendingSessionRequest = async (e) => {
      const s = V2.wc_sessionRequest.req.ttl, { id: t, topic: i2, params: o2 } = e;
      await this.client.pendingRequest.set(t, { id: t, topic: i2, params: o2 }), s && this.client.core.expirer.set(t, rt(s));
    }, this.sendRequest = async (e, s, t, i2) => {
      const o2 = formatJsonRpcRequest(s, t), a3 = await this.client.core.crypto.encode(e, o2), r = V2[s].req;
      return i2 && (r.ttl = i2), this.client.core.history.set(e, o2), this.client.core.relayer.publish(e, a3, r), o2.id;
    }, this.sendResult = async (e, s, t) => {
      const i2 = formatJsonRpcResult(e, t), o2 = await this.client.core.crypto.encode(s, i2), a3 = await this.client.core.history.get(s, e), r = V2[a3.request.method].res;
      this.client.core.relayer.publish(s, o2, r), await this.client.core.history.resolve(i2);
    }, this.sendError = async (e, s, t) => {
      const i2 = formatJsonRpcError(e, t), o2 = await this.client.core.crypto.encode(s, i2), a3 = await this.client.core.history.get(s, e), r = V2[a3.request.method].res;
      this.client.core.relayer.publish(s, o2, r), await this.client.core.history.resolve(i2);
    }, this.cleanup = async () => {
      const e = [], s = [];
      this.client.session.getAll().forEach((t) => {
        ot(t.expiry) && e.push(t.topic);
      }), this.client.proposal.getAll().forEach((t) => {
        ot(t.expiry) && s.push(t.id);
      }), await Promise.all([...e.map((t) => this.deleteSession(t)), ...s.map((t) => this.deleteProposal(t))]);
    }, this.onRelayEventRequest = (e) => {
      const { topic: s, payload: t } = e, i2 = t.method;
      switch (i2) {
        case "wc_sessionPropose":
          return this.onSessionProposeRequest(s, t);
        case "wc_sessionSettle":
          return this.onSessionSettleRequest(s, t);
        case "wc_sessionUpdate":
          return this.onSessionUpdateRequest(s, t);
        case "wc_sessionExtend":
          return this.onSessionExtendRequest(s, t);
        case "wc_sessionPing":
          return this.onSessionPingRequest(s, t);
        case "wc_sessionDelete":
          return this.onSessionDeleteRequest(s, t);
        case "wc_sessionRequest":
          return this.onSessionRequest(s, t);
        case "wc_sessionEvent":
          return this.onSessionEventRequest(s, t);
        default:
          return this.client.logger.info(`Unsupported request method ${i2}`);
      }
    }, this.onRelayEventResponse = async (e) => {
      const { topic: s, payload: t } = e, i2 = (await this.client.core.history.get(s, t.id)).request.method;
      switch (i2) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(s, t);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(s, t);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(s, t);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(s, t);
        case "wc_sessionPing":
          return this.onSessionPingResponse(s, t);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(s, t);
        default:
          return this.client.logger.info(`Unsupported response method ${i2}`);
      }
    }, this.onSessionProposeRequest = async (e, s) => {
      const { params: t, id: i2 } = s;
      try {
        this.isValidConnect(u2({}, s.params));
        const o2 = rt(import_time4.FIVE_MINUTES), a3 = u2({ id: i2, pairingTopic: e, expiry: o2 }, t);
        await this.setProposal(i2, a3), this.client.events.emit("session_proposal", { id: i2, params: a3 });
      } catch (o2) {
        await this.sendError(i2, e, o2), this.client.logger.error(o2);
      }
    }, this.onSessionProposeResponse = async (e, s) => {
      const { id: t } = s;
      if (isJsonRpcResult(s)) {
        const { result: i2 } = s;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: i2 });
        const o2 = this.client.proposal.get(t);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: o2 });
        const a3 = o2.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: a3 });
        const r = i2.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: r });
        const p4 = await this.client.core.crypto.generateSharedKey(a3, r);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", sessionTopic: p4 });
        const h3 = await this.client.core.relayer.subscribe(p4);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: h3 }), await this.client.core.pairing.activate({ topic: e });
      } else
        isJsonRpcError(s) && (await this.client.proposal.delete(t, R2("USER_DISCONNECTED")), this.events.emit(st("session_connect"), { error: s.error }));
    }, this.onSessionSettleRequest = async (e, s) => {
      const { id: t, params: i2 } = s;
      try {
        this.isValidSessionSettleRequest(i2);
        const { relay: o2, controller: a3, expiry: r, namespaces: p4, requiredNamespaces: h3, optionalNamespaces: E3, sessionProperties: m5, pairingTopic: P2 } = s.params, y4 = u2({ topic: e, relay: o2, expiry: r, namespaces: p4, acknowledged: true, pairingTopic: P2, requiredNamespaces: h3, optionalNamespaces: E3, controller: a3.publicKey, self: { publicKey: "", metadata: this.client.metadata }, peer: { publicKey: a3.publicKey, metadata: a3.metadata } }, m5 && { sessionProperties: m5 });
        await this.sendResult(s.id, e, true), this.events.emit(st("session_connect"), { session: y4 });
      } catch (o2) {
        await this.sendError(t, e, o2), this.client.logger.error(o2);
      }
    }, this.onSessionSettleResponse = async (e, s) => {
      const { id: t } = s;
      isJsonRpcResult(s) ? (await this.client.session.update(e, { acknowledged: true }), this.events.emit(st("session_approve", t), {})) : isJsonRpcError(s) && (await this.client.session.delete(e, R2("USER_DISCONNECTED")), this.events.emit(st("session_approve", t), { error: s.error }));
    }, this.onSessionUpdateRequest = async (e, s) => {
      const { params: t, id: i2 } = s;
      try {
        this.isValidUpdate(u2({ topic: e }, t)), await this.client.session.update(e, { namespaces: t.namespaces }), await this.sendResult(i2, e, true), this.client.events.emit("session_update", { id: i2, topic: e, params: t });
      } catch (o2) {
        await this.sendError(i2, e, o2), this.client.logger.error(o2);
      }
    }, this.onSessionUpdateResponse = (e, s) => {
      const { id: t } = s;
      isJsonRpcResult(s) ? this.events.emit(st("session_update", t), {}) : isJsonRpcError(s) && this.events.emit(st("session_update", t), { error: s.error });
    }, this.onSessionExtendRequest = async (e, s) => {
      const { id: t } = s;
      try {
        this.isValidExtend({ topic: e }), await this.setExpiry(e, rt(b2)), await this.sendResult(t, e, true), this.client.events.emit("session_extend", { id: t, topic: e });
      } catch (i2) {
        await this.sendError(t, e, i2), this.client.logger.error(i2);
      }
    }, this.onSessionExtendResponse = (e, s) => {
      const { id: t } = s;
      isJsonRpcResult(s) ? this.events.emit(st("session_extend", t), {}) : isJsonRpcError(s) && this.events.emit(st("session_extend", t), { error: s.error });
    }, this.onSessionPingRequest = async (e, s) => {
      const { id: t } = s;
      try {
        this.isValidPing({ topic: e }), await this.sendResult(t, e, true), this.client.events.emit("session_ping", { id: t, topic: e });
      } catch (i2) {
        await this.sendError(t, e, i2), this.client.logger.error(i2);
      }
    }, this.onSessionPingResponse = (e, s) => {
      const { id: t } = s;
      setTimeout(() => {
        isJsonRpcResult(s) ? this.events.emit(st("session_ping", t), {}) : isJsonRpcError(s) && this.events.emit(st("session_ping", t), { error: s.error });
      }, 500);
    }, this.onSessionDeleteRequest = async (e, s) => {
      const { id: t } = s;
      try {
        this.isValidDisconnect({ topic: e, reason: s.params }), this.client.core.relayer.once(D.publish, async () => {
          await this.deleteSession(e);
        }), await this.sendResult(t, e, true), this.client.events.emit("session_delete", { id: t, topic: e });
      } catch (i2) {
        await this.sendError(t, e, i2), this.client.logger.error(i2);
      }
    }, this.onSessionRequest = async (e, s) => {
      const { id: t, params: i2 } = s;
      try {
        this.isValidRequest(u2({ topic: e }, i2)), await this.setPendingSessionRequest({ id: t, topic: e, params: i2 }), this.client.events.emit("session_request", { id: t, topic: e, params: i2 });
      } catch (o2) {
        await this.sendError(t, e, o2), this.client.logger.error(o2);
      }
    }, this.onSessionRequestResponse = (e, s) => {
      const { id: t } = s;
      isJsonRpcResult(s) ? this.events.emit(st("session_request", t), { result: s.result }) : isJsonRpcError(s) && this.events.emit(st("session_request", t), { error: s.error });
    }, this.onSessionEventRequest = async (e, s) => {
      const { id: t, params: i2 } = s;
      try {
        this.isValidEmit(u2({ topic: e }, i2)), this.client.events.emit("session_event", { id: t, topic: e, params: i2 });
      } catch (o2) {
        await this.sendError(t, e, o2), this.client.logger.error(o2);
      }
    }, this.isValidConnect = async (e) => {
      if (!Ct(e)) {
        const { message: r } = N("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(e)}`);
        throw new Error(r);
      }
      const { pairingTopic: s, requiredNamespaces: t, optionalNamespaces: i2, sessionProperties: o2, relays: a3 } = e;
      if (S(s) || await this.isValidPairingTopic(s), !wt(a3, true)) {
        const { message: r } = N("MISSING_OR_INVALID", `connect() relays: ${a3}`);
        throw new Error(r);
      }
      !S(t) && x2(t) !== 0 && this.validateNamespaces(t, "requiredNamespaces"), !S(i2) && x2(i2) !== 0 && this.validateNamespaces(i2, "optionalNamespaces"), S(o2) || this.validateSessionProps(o2, "sessionProperties");
    }, this.validateNamespaces = (e, s) => {
      const t = _t(e, "connect()", s);
      if (t)
        throw new Error(t.message);
    }, this.isValidApprove = async (e) => {
      if (!Ct(e))
        throw new Error(N("MISSING_OR_INVALID", `approve() params: ${e}`).message);
      const { id: s, namespaces: t, relayProtocol: i2, sessionProperties: o2 } = e;
      await this.isValidProposalId(s);
      const a3 = this.client.proposal.get(s), r = on(t, "approve()");
      if (r)
        throw new Error(r.message);
      const p4 = cn(a3.requiredNamespaces, t, "approve()");
      if (p4)
        throw new Error(p4.message);
      if (!m(i2, true)) {
        const { message: h3 } = N("MISSING_OR_INVALID", `approve() relayProtocol: ${i2}`);
        throw new Error(h3);
      }
      S(o2) || this.validateSessionProps(o2, "sessionProperties");
    }, this.isValidReject = async (e) => {
      if (!Ct(e)) {
        const { message: i2 } = N("MISSING_OR_INVALID", `reject() params: ${e}`);
        throw new Error(i2);
      }
      const { id: s, reason: t } = e;
      if (await this.isValidProposalId(s), !$t(t)) {
        const { message: i2 } = N("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(t)}`);
        throw new Error(i2);
      }
    }, this.isValidSessionSettleRequest = (e) => {
      if (!Ct(e)) {
        const { message: p4 } = N("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${e}`);
        throw new Error(p4);
      }
      const { relay: s, controller: t, namespaces: i2, expiry: o2 } = e;
      if (!sn(s)) {
        const { message: p4 } = N("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(p4);
      }
      const a3 = Ut(t, "onSessionSettleRequest()");
      if (a3)
        throw new Error(a3.message);
      const r = on(i2, "onSessionSettleRequest()");
      if (r)
        throw new Error(r.message);
      if (ot(o2)) {
        const { message: p4 } = N("EXPIRED", "onSessionSettleRequest()");
        throw new Error(p4);
      }
    }, this.isValidUpdate = async (e) => {
      if (!Ct(e)) {
        const { message: r } = N("MISSING_OR_INVALID", `update() params: ${e}`);
        throw new Error(r);
      }
      const { topic: s, namespaces: t } = e;
      await this.isValidSessionTopic(s);
      const i2 = this.client.session.get(s), o2 = on(t, "update()");
      if (o2)
        throw new Error(o2.message);
      const a3 = cn(i2.requiredNamespaces, t, "update()");
      if (a3)
        throw new Error(a3.message);
    }, this.isValidExtend = async (e) => {
      if (!Ct(e)) {
        const { message: t } = N("MISSING_OR_INVALID", `extend() params: ${e}`);
        throw new Error(t);
      }
      const { topic: s } = e;
      await this.isValidSessionTopic(s);
    }, this.isValidRequest = async (e) => {
      if (!Ct(e)) {
        const { message: r } = N("MISSING_OR_INVALID", `request() params: ${e}`);
        throw new Error(r);
      }
      const { topic: s, request: t, chainId: i2, expiry: o2 } = e;
      await this.isValidSessionTopic(s);
      const { namespaces: a3 } = this.client.session.get(s);
      if (!Kt(a3, i2)) {
        const { message: r } = N("MISSING_OR_INVALID", `request() chainId: ${i2}`);
        throw new Error(r);
      }
      if (!Dt(t)) {
        const { message: r } = N("MISSING_OR_INVALID", `request() ${JSON.stringify(t)}`);
        throw new Error(r);
      }
      if (!kt(a3, i2, t.method)) {
        const { message: r } = N("MISSING_OR_INVALID", `request() method: ${t.method}`);
        throw new Error(r);
      }
      if (o2 && !Ht(o2, $4)) {
        const { message: r } = N("MISSING_OR_INVALID", `request() expiry: ${o2}. Expiry must be a number (in seconds) between ${$4.min} and ${$4.max}`);
        throw new Error(r);
      }
    }, this.isValidRespond = async (e) => {
      if (!Ct(e)) {
        const { message: i2 } = N("MISSING_OR_INVALID", `respond() params: ${e}`);
        throw new Error(i2);
      }
      const { topic: s, response: t } = e;
      if (await this.isValidSessionTopic(s), !Vt(t)) {
        const { message: i2 } = N("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(t)}`);
        throw new Error(i2);
      }
    }, this.isValidPing = async (e) => {
      if (!Ct(e)) {
        const { message: t } = N("MISSING_OR_INVALID", `ping() params: ${e}`);
        throw new Error(t);
      }
      const { topic: s } = e;
      await this.isValidSessionOrPairingTopic(s);
    }, this.isValidEmit = async (e) => {
      if (!Ct(e)) {
        const { message: a3 } = N("MISSING_OR_INVALID", `emit() params: ${e}`);
        throw new Error(a3);
      }
      const { topic: s, event: t, chainId: i2 } = e;
      await this.isValidSessionTopic(s);
      const { namespaces: o2 } = this.client.session.get(s);
      if (!Kt(o2, i2)) {
        const { message: a3 } = N("MISSING_OR_INVALID", `emit() chainId: ${i2}`);
        throw new Error(a3);
      }
      if (!Mt(t)) {
        const { message: a3 } = N("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(t)}`);
        throw new Error(a3);
      }
      if (!Lt(o2, i2, t.name)) {
        const { message: a3 } = N("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(t)}`);
        throw new Error(a3);
      }
    }, this.isValidDisconnect = async (e) => {
      if (!Ct(e)) {
        const { message: t } = N("MISSING_OR_INVALID", `disconnect() params: ${e}`);
        throw new Error(t);
      }
      const { topic: s } = e;
      await this.isValidSessionOrPairingTopic(s);
    }, this.validateSessionProps = (e, s) => {
      Object.values(e).forEach((t) => {
        if (!m(t, false)) {
          const { message: i2 } = N("MISSING_OR_INVALID", `${s} must be in Record<string, string> format. Received: ${JSON.stringify(t)}`);
          throw new Error(i2);
        }
      });
    };
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: n2 } = N("NOT_INITIALIZED", this.name);
      throw new Error(n2);
    }
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(D.message, async (n2) => {
      const { topic: e, message: s } = n2;
      if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(s)))
        return;
      const t = await this.client.core.crypto.decode(e, s);
      isJsonRpcRequest(t) ? (this.client.core.history.set(e, t), this.onRelayEventRequest({ topic: e, payload: t })) : isJsonRpcResponse(t) && (await this.client.core.history.resolve(t), this.onRelayEventResponse({ topic: e, payload: t }));
    });
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(m2.expired, async (n2) => {
      const { topic: e, id: s } = tt(n2.target);
      if (s && this.client.pendingRequest.keys.includes(s))
        return await this.deletePendingSessionRequest(s, N("EXPIRED"), true);
      e ? this.client.session.keys.includes(e) && (await this.deleteSession(e, true), this.client.events.emit("session_expire", { topic: e })) : s && (await this.deleteProposal(s, true), this.client.events.emit("proposal_expire", { id: s }));
    });
  }
  isValidPairingTopic(n2) {
    if (!m(n2, false)) {
      const { message: e } = N("MISSING_OR_INVALID", `pairing topic should be a string: ${n2}`);
      throw new Error(e);
    }
    if (!this.client.core.pairing.pairings.keys.includes(n2)) {
      const { message: e } = N("NO_MATCHING_KEY", `pairing topic doesn't exist: ${n2}`);
      throw new Error(e);
    }
    if (ot(this.client.core.pairing.pairings.get(n2).expiry)) {
      const { message: e } = N("EXPIRED", `pairing topic: ${n2}`);
      throw new Error(e);
    }
  }
  async isValidSessionTopic(n2) {
    if (!m(n2, false)) {
      const { message: e } = N("MISSING_OR_INVALID", `session topic should be a string: ${n2}`);
      throw new Error(e);
    }
    if (!this.client.session.keys.includes(n2)) {
      const { message: e } = N("NO_MATCHING_KEY", `session topic doesn't exist: ${n2}`);
      throw new Error(e);
    }
    if (ot(this.client.session.get(n2).expiry)) {
      await this.deleteSession(n2);
      const { message: e } = N("EXPIRED", `session topic: ${n2}`);
      throw new Error(e);
    }
  }
  async isValidSessionOrPairingTopic(n2) {
    if (this.client.session.keys.includes(n2))
      await this.isValidSessionTopic(n2);
    else if (this.client.core.pairing.pairings.keys.includes(n2))
      this.isValidPairingTopic(n2);
    else if (m(n2, false)) {
      const { message: e } = N("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${n2}`);
      throw new Error(e);
    } else {
      const { message: e } = N("MISSING_OR_INVALID", `session or pairing topic should be a string: ${n2}`);
      throw new Error(e);
    }
  }
  async isValidProposalId(n2) {
    if (!jt(n2)) {
      const { message: e } = N("MISSING_OR_INVALID", `proposal id should be a number: ${n2}`);
      throw new Error(e);
    }
    if (!this.client.proposal.keys.includes(n2)) {
      const { message: e } = N("NO_MATCHING_KEY", `proposal id doesn't exist: ${n2}`);
      throw new Error(e);
    }
    if (ot(this.client.proposal.get(n2).expiry)) {
      await this.deleteProposal(n2);
      const { message: e } = N("EXPIRED", `proposal id: ${n2}`);
      throw new Error(e);
    }
  }
};
var Ze3 = class extends _t2 {
  constructor(n2, e) {
    super(n2, e, ee2, C5), this.core = n2, this.logger = e;
  }
};
var es2 = class extends _t2 {
  constructor(n2, e) {
    super(n2, e, te, C5), this.core = n2, this.logger = e;
  }
};
var ss2 = class extends _t2 {
  constructor(n2, e) {
    super(n2, e, ne3, C5, (s) => s.id), this.core = n2, this.logger = e;
  }
};
var M2 = class extends y {
  constructor(n2) {
    super(n2), this.protocol = k2, this.version = X2, this.name = G3.name, this.events = new import_events6.EventEmitter(), this.on = (s, t) => this.events.on(s, t), this.once = (s, t) => this.events.once(s, t), this.off = (s, t) => this.events.off(s, t), this.removeListener = (s, t) => this.events.removeListener(s, t), this.removeAllListeners = (s) => this.events.removeAllListeners(s), this.connect = async (s) => {
      try {
        return await this.engine.connect(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.pair = async (s) => {
      try {
        return await this.engine.pair(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.approve = async (s) => {
      try {
        return await this.engine.approve(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.reject = async (s) => {
      try {
        return await this.engine.reject(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.update = async (s) => {
      try {
        return await this.engine.update(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.extend = async (s) => {
      try {
        return await this.engine.extend(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.request = async (s) => {
      try {
        return await this.engine.request(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.respond = async (s) => {
      try {
        return await this.engine.respond(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.ping = async (s) => {
      try {
        return await this.engine.ping(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.emit = async (s) => {
      try {
        return await this.engine.emit(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.disconnect = async (s) => {
      try {
        return await this.engine.disconnect(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.find = (s) => {
      try {
        return this.engine.find(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.name = (n2 == null ? void 0 : n2.name) || G3.name, this.metadata = (n2 == null ? void 0 : n2.metadata) || xn();
    const e = typeof (n2 == null ? void 0 : n2.logger) < "u" && typeof (n2 == null ? void 0 : n2.logger) != "string" ? n2.logger : (0, import_pino2.default)((0, import_logger2.getDefaultLoggerOptions)({ level: (n2 == null ? void 0 : n2.logger) || G3.logger }));
    this.core = (n2 == null ? void 0 : n2.core) || new Dr(n2), this.logger = (0, import_logger2.generateChildLogger)(e, this.name), this.session = new es2(this.core, this.logger), this.proposal = new Ze3(this.core, this.logger), this.pendingRequest = new ss2(this.core, this.logger), this.engine = new We3(this);
  }
  static async init(n2) {
    const e = new M2(n2);
    return await e.initialize(), e;
  }
  get context() {
    return (0, import_logger2.getLoggerContext)(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.engine.init(), this.logger.info("SignClient Initialization Success");
    } catch (n2) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(n2.message), n2;
    }
  }
};

// node_modules/@walletconnect/universal-provider/node_modules/@walletconnect/utils/dist/index.es.js
init_shim();
var import_chacha20poly13053 = __toESM(require_chacha20poly1305());
var import_hkdf3 = __toESM(require_hkdf());
var import_random3 = __toESM(require_random());
var import_sha2563 = __toESM(require_sha256());
var ue4 = __toESM(require_x25519());
init_es();
var import_time5 = __toESM(require_cjs());
var import_window_getters3 = __toESM(require_cjs3());
var import_window_metadata3 = __toESM(require_cjs4());
var $5 = __toESM(require_query_string3());
var St4 = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
function R3(e, n2) {
  const { message: t, code: r } = St4[e];
  return { message: n2 ? `${t} ${n2}` : t, code: r };
}
function C6(e, n2) {
  return Array.isArray(e) ? typeof n2 < "u" && e.length ? e.every(n2) : true : false;
}
function x3(e) {
  return Object.getPrototypeOf(e) === Object.prototype && Object.keys(e).length;
}

// node_modules/@walletconnect/universal-provider/dist/index.es.js
var import_logger3 = __toESM(require_cjs2());
var import_events7 = __toESM(require_events());
var I2 = "error";
var M3 = "wss://relay.walletconnect.com";
var G4 = "wc";
var z2 = "universal_provider";
var E2 = `${G4}@${2}:${z2}:`;
var x4 = "https://rpc.walletconnect.com/v1";
var o = { DEFAULT_CHAIN_CHANGED: "default_chain_changed" };
var J3 = Object.defineProperty;
var $6 = Object.getOwnPropertySymbols;
var V3 = Object.prototype.hasOwnProperty;
var W3 = Object.prototype.propertyIsEnumerable;
var H4 = (i2, e, t) => e in i2 ? J3(i2, e, { enumerable: true, configurable: true, writable: true, value: t }) : i2[e] = t;
var f2 = (i2, e) => {
  for (var t in e || (e = {}))
    V3.call(e, t) && H4(i2, t, e[t]);
  if ($6)
    for (var t of $6(e))
      W3.call(e, t) && H4(i2, t, e[t]);
  return i2;
};
function a2(i2, e, t) {
  let s;
  const n2 = g2(i2);
  return e.rpcMap && (s = e.rpcMap[n2]), s || (s = `${x4}?chainId=eip155:${n2}&projectId=${t}`), s;
}
function g2(i2) {
  return i2.includes("eip155") ? Number(i2.split(":")[1]) : Number(i2);
}
function K2(i2, e) {
  if (!e.includes(i2))
    throw new Error(`Chain '${i2}' not approved. Please use one of the following: ${e.toString()}`);
}
function X3(i2) {
  return i2.map((e) => `${e.split(":")[0]}:${e.split(":")[1]}`);
}
function Y3(i2, e) {
  const t = Object.keys(e.namespaces).filter((n2) => n2.includes(i2));
  if (!t.length)
    return [];
  const s = [];
  return t.forEach((n2) => {
    const r = e.namespaces[n2].accounts;
    s.push(...r);
  }), s;
}
function B(i2, e = {}) {
  const t = A2(i2), s = A2(e);
  return f2({}, Object.assign(t, s));
}
function A2(i2) {
  var e, t, s, n2;
  const r = {};
  if (!x3(i2))
    return r;
  for (const [v2, l] of Object.entries(i2)) {
    const q6 = y2(v2) ? [v2] : l.chains, S2 = l.methods || [], D3 = l.events || [], p4 = N3(v2);
    r[p4] = { chains: P(q6, (e = r[p4]) == null ? void 0 : e.chains), methods: P(S2, (t = r[p4]) == null ? void 0 : t.methods), events: P(D3, (s = r[p4]) == null ? void 0 : s.events), rpcMap: f2(f2({}, (n2 = r[p4]) == null ? void 0 : n2.rpcMap), l.rpcMap) };
  }
  return r;
}
function y2(i2) {
  return i2.includes(":");
}
function N3(i2) {
  return y2(i2) ? i2.split(":")[0] : i2;
}
function P(i2 = [], e = []) {
  return [.../* @__PURE__ */ new Set([...i2, ...e])];
}
var h2 = (i2, e) => {
  const t = (s) => {
    s.request !== e.request || s.topic !== e.topic || (i2.events.removeListener("session_request_sent", t), Q2(e));
  };
  i2.on("session_request_sent", t);
};
function Q2(i2) {
  if (typeof window < "u")
    try {
      const e = window.localStorage.getItem("WALLETCONNECT_DEEPLINK_CHOICE");
      if (e) {
        const t = JSON.parse(e), s = t == null ? void 0 : t.href;
        if (typeof s == "string") {
          s.endsWith("/") && s.slice(0, -1);
          const n2 = `${s}/wc?requestId=${i2.id}&sessionTopic=${i2.topic}`;
          window.open(n2, "_self", "noreferrer noopener");
        }
      }
    } catch (e) {
      console.error(e);
    }
}
var Z2 = class {
  constructor(e) {
    this.name = "eip155", this.namespace = e.namespace, this.client = e.client, this.events = e.events, this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain());
  }
  async request(e) {
    var t;
    switch (e.request.method) {
      case "eth_requestAccounts":
        return this.getAccounts();
      case "eth_accounts":
        return this.getAccounts();
      case "wallet_switchEthereumChain":
        return this.handleSwitchChain(e.request.params ? (t = e.request.params[0]) == null ? void 0 : t.chainId : "0x0"), null;
      case "eth_chainId":
        return parseInt(this.getDefaultChain());
    }
    return this.namespace.methods.includes(e.request.method) ? (h2(this.client, e), await this.client.request(e)) : this.getHttpProvider().request(e.request);
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  setDefaultChain(e, t) {
    const s = g2(e);
    if (!this.httpProviders[s]) {
      const n2 = t || a2(`${this.name}:${s}`, this.namespace, this.client.core.projectId);
      if (!n2)
        throw new Error(`No RPC url provided for chainId: ${s}`);
      this.setHttpProvider(s, n2);
    }
    this.chainId = s, this.events.emit(o.DEFAULT_CHAIN_CHANGED, `${this.name}:${s}`);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId)
      return this.chainId.toString();
    if (this.namespace.defaultChain)
      return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e)
      throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  createHttpProvider(e, t) {
    const s = t || a2(`${this.name}:${e}`, this.namespace, this.client.core.projectId);
    return typeof s > "u" ? void 0 : new JsonRpcProvider(new HttpConnection(s));
  }
  setHttpProvider(e, t) {
    const s = this.createHttpProvider(e, t);
    s && (this.httpProviders[e] = s);
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((t) => {
      var s;
      const n2 = g2(t);
      e[n2] = this.createHttpProvider(n2, (s = this.namespace.rpcMap) == null ? void 0 : s[t]);
    }), e;
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]))] : [];
  }
  getHttpProvider() {
    const e = this.chainId, t = this.httpProviders[e];
    if (typeof t > "u")
      throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  handleSwitchChain(e) {
    const t = parseInt(e, 16), s = `${this.name}:${t}`;
    K2(s, this.namespace.chains), this.setDefaultChain(`${t}`);
  }
};
var ee3 = class {
  constructor(e) {
    this.name = "solana", this.namespace = e.namespace, this.events = e.events, this.client = e.client, this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? (h2(this.client, e), this.client.request(e)) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, t) {
    if (!this.httpProviders[e]) {
      const s = t || a2(`${this.name}:${e}`, this.namespace, this.client.core.projectId);
      if (!s)
        throw new Error(`No RPC url provided for chainId: ${e}`);
      this.setHttpProvider(e, s);
    }
    this.chainId = e, this.events.emit(o.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getDefaultChain() {
    if (this.chainId)
      return this.chainId;
    if (this.namespace.defaultChain)
      return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e)
      throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((t) => {
      var s;
      e[t] = this.createHttpProvider(t, (s = this.namespace.rpcMap) == null ? void 0 : s[t]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, t = this.httpProviders[e];
    if (typeof t > "u")
      throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  setHttpProvider(e, t) {
    const s = this.createHttpProvider(e, t);
    s && (this.httpProviders[e] = s);
  }
  createHttpProvider(e, t) {
    const s = t || a2(e, this.namespace, this.client.core.projectId);
    return typeof s > "u" ? void 0 : new JsonRpcProvider(new esm_default(s));
  }
};
var te2 = class {
  constructor(e) {
    this.name = "cosmos", this.namespace = e.namespace, this.events = e.events, this.client = e.client, this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId)
      return this.chainId;
    if (this.namespace.defaultChain)
      return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e)
      throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? (h2(this.client, e), this.client.request(e)) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, t) {
    if (this.chainId = e, !this.httpProviders[e]) {
      const s = t || a2(`${this.name}:${e}`, this.namespace, this.client.core.projectId);
      if (!s)
        throw new Error(`No RPC url provided for chainId: ${e}`);
      this.setHttpProvider(e, s);
    }
    this.events.emit(o.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((t) => {
      var s;
      e[t] = this.createHttpProvider(t, (s = this.namespace.rpcMap) == null ? void 0 : s[t]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, t = this.httpProviders[e];
    if (typeof t > "u")
      throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  setHttpProvider(e, t) {
    const s = this.createHttpProvider(e, t);
    s && (this.httpProviders[e] = s);
  }
  createHttpProvider(e, t) {
    const s = t || a2(e, this.namespace, this.client.core.projectId);
    return typeof s > "u" ? void 0 : new JsonRpcProvider(new esm_default(s));
  }
};
var se4 = class {
  constructor(e) {
    this.name = "cip34", this.namespace = e.namespace, this.events = e.events, this.client = e.client, this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId)
      return this.chainId;
    if (this.namespace.defaultChain)
      return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e)
      throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? (h2(this.client, e), this.client.request(e)) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, t) {
    if (this.chainId = e, !this.httpProviders[e]) {
      const s = t || this.getCardanoRPCUrl(e);
      if (!s)
        throw new Error(`No RPC url provided for chainId: ${e}`);
      this.setHttpProvider(e, s);
    }
    this.events.emit(o.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((t) => {
      const s = this.getCardanoRPCUrl(t);
      e[t] = this.createHttpProvider(t, s);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, t = this.httpProviders[e];
    if (typeof t > "u")
      throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  getCardanoRPCUrl(e) {
    const t = this.namespace.rpcMap;
    if (t)
      return t[e];
  }
  setHttpProvider(e, t) {
    const s = this.createHttpProvider(e, t);
    s && (this.httpProviders[e] = s);
  }
  createHttpProvider(e, t) {
    const s = t || this.getCardanoRPCUrl(e);
    return typeof s > "u" ? void 0 : new JsonRpcProvider(new esm_default(s));
  }
};
var ie6 = class {
  constructor(e) {
    this.name = "elrond", this.namespace = e.namespace, this.events = e.events, this.client = e.client, this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? (h2(this.client, e), this.client.request(e)) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, t) {
    if (!this.httpProviders[e]) {
      const s = t || a2(`${this.name}:${e}`, this.namespace, this.client.core.projectId);
      if (!s)
        throw new Error(`No RPC url provided for chainId: ${e}`);
      this.setHttpProvider(e, s);
    }
    this.chainId = e, this.events.emit(o.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getDefaultChain() {
    if (this.chainId)
      return this.chainId;
    if (this.namespace.defaultChain)
      return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e)
      throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((t) => {
      var s;
      e[t] = this.createHttpProvider(t, (s = this.namespace.rpcMap) == null ? void 0 : s[t]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, t = this.httpProviders[e];
    if (typeof t > "u")
      throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  setHttpProvider(e, t) {
    const s = this.createHttpProvider(e, t);
    s && (this.httpProviders[e] = s);
  }
  createHttpProvider(e, t) {
    const s = t || a2(e, this.namespace, this.client.core.projectId);
    return typeof s > "u" ? void 0 : new JsonRpcProvider(new esm_default(s));
  }
};
var ne4 = class {
  constructor(e) {
    this.name = "multiversx", this.namespace = e.namespace, this.events = e.events, this.client = e.client, this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? (h2(this.client, e), this.client.request(e)) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, t) {
    if (!this.httpProviders[e]) {
      const s = t || a2(`${this.name}:${e}`, this.namespace, this.client.core.projectId);
      if (!s)
        throw new Error(`No RPC url provided for chainId: ${e}`);
      this.setHttpProvider(e, s);
    }
    this.chainId = e, this.events.emit(o.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getDefaultChain() {
    if (this.chainId)
      return this.chainId;
    if (this.namespace.defaultChain)
      return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e)
      throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((t) => {
      var s;
      e[t] = this.createHttpProvider(t, (s = this.namespace.rpcMap) == null ? void 0 : s[t]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, t = this.httpProviders[e];
    if (typeof t > "u")
      throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  setHttpProvider(e, t) {
    const s = this.createHttpProvider(e, t);
    s && (this.httpProviders[e] = s);
  }
  createHttpProvider(e, t) {
    const s = t || a2(e, this.namespace, this.client.core.projectId);
    return typeof s > "u" ? void 0 : new JsonRpcProvider(new esm_default(s));
  }
};
var re3 = Object.defineProperty;
var ae6 = Object.defineProperties;
var oe4 = Object.getOwnPropertyDescriptors;
var O2 = Object.getOwnPropertySymbols;
var ce5 = Object.prototype.hasOwnProperty;
var he3 = Object.prototype.propertyIsEnumerable;
var b3 = (i2, e, t) => e in i2 ? re3(i2, e, { enumerable: true, configurable: true, writable: true, value: t }) : i2[e] = t;
var u3 = (i2, e) => {
  for (var t in e || (e = {}))
    ce5.call(e, t) && b3(i2, t, e[t]);
  if (O2)
    for (var t of O2(e))
      he3.call(e, t) && b3(i2, t, e[t]);
  return i2;
};
var w3 = (i2, e) => ae6(i2, oe4(e));
var m3 = class {
  constructor(e) {
    this.events = new import_events7.default(), this.rpcProviders = {}, this.shouldAbortPairingAttempt = false, this.maxPairingAttempts = 10, this.providerOpts = e, this.logger = typeof (e == null ? void 0 : e.logger) < "u" && typeof (e == null ? void 0 : e.logger) != "string" ? e.logger : (0, import_pino3.default)((0, import_logger3.getDefaultLoggerOptions)({ level: (e == null ? void 0 : e.logger) || I2 }));
  }
  static async init(e) {
    const t = new m3(e);
    return await t.initialize(), t;
  }
  async request(e, t) {
    const [s, n2] = this.validateChain(t);
    if (!this.session)
      throw new Error("Please call connect() before request()");
    return await this.getProvider(s).request({ request: u3({}, e), chainId: `${s}:${n2}`, topic: this.session.topic });
  }
  sendAsync(e, t, s) {
    this.request(e, s).then((n2) => t(null, n2)).catch((n2) => t(n2, void 0));
  }
  async enable() {
    if (!this.client)
      throw new Error("Sign Client not initialized");
    return this.session || await this.connect({ namespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties }), await this.requestAccounts();
  }
  async disconnect() {
    var e;
    if (!this.session)
      throw new Error("Please call connect() before enable()");
    await this.client.disconnect({ topic: (e = this.session) == null ? void 0 : e.topic, reason: R3("USER_DISCONNECTED") }), await this.cleanup();
  }
  async connect(e) {
    if (!this.client)
      throw new Error("Sign Client not initialized");
    if (this.setNamespaces(e), await this.cleanupPendingPairings(), !e.skipPairing)
      return await this.pair(e.pairingTopic);
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  get isWalletConnect() {
    return true;
  }
  async pair(e) {
    this.shouldAbortPairingAttempt = false;
    let t = 0;
    do {
      if (this.shouldAbortPairingAttempt)
        throw new Error("Pairing aborted");
      if (t >= this.maxPairingAttempts)
        throw new Error("Max auto pairing attempts reached");
      const { uri: s, approval: n2 } = await this.client.connect({ pairingTopic: e, requiredNamespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties });
      s && (this.uri = s, this.events.emit("display_uri", s)), await n2().then((r) => {
        this.session = r;
      }).catch((r) => {
        if (r.message !== se3)
          throw r;
        t++;
      });
    } while (!this.session);
    return this.onConnect(), this.session;
  }
  setDefaultChain(e, t) {
    try {
      const [s, n2] = this.validateChain(e);
      this.getProvider(s).setDefaultChain(n2, t);
    } catch (s) {
      if (!/Please call connect/.test(s.message))
        throw s;
    }
  }
  async cleanupPendingPairings(e = {}) {
    this.logger.info("Cleaning up inactive pairings...");
    const t = this.client.pairing.getAll();
    if (C6(t)) {
      for (const s of t)
        e.deletePairings ? this.client.core.expirer.set(s.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(s.topic);
      this.logger.info(`Inactive pairings cleared: ${t.length}`);
    }
  }
  abortPairingAttempt() {
    this.shouldAbortPairingAttempt = true;
  }
  async checkStorage() {
    if (this.namespaces = await this.getFromStore("namespaces") || {}, this.optionalNamespaces = await this.getFromStore("optionalNamespaces") || {}, this.client.session.length) {
      const e = this.client.session.keys.length - 1;
      this.session = this.client.session.get(this.client.session.keys[e]), this.createProviders();
    }
  }
  async initialize() {
    this.logger.trace("Initialized"), await this.createClient(), await this.checkStorage(), this.registerEventListeners();
  }
  async createClient() {
    this.client = this.providerOpts.client || await M2.init({ logger: this.providerOpts.logger || I2, relayUrl: this.providerOpts.relayUrl || M3, projectId: this.providerOpts.projectId, metadata: this.providerOpts.metadata, storageOptions: this.providerOpts.storageOptions, name: this.providerOpts.name }), this.logger.trace("SignClient Initialized");
  }
  createProviders() {
    if (!this.client)
      throw new Error("Sign Client not initialized");
    if (!this.session)
      throw new Error("Session not initialized. Please call connect() before enable()");
    [...new Set(Object.keys(this.session.namespaces).map((e) => N3(e)))].forEach((e) => {
      if (!this.session)
        return;
      const t = Y3(e, this.session), s = X3(t), n2 = B(this.namespaces, this.optionalNamespaces), r = w3(u3({}, n2[e]), { accounts: t, chains: s });
      switch (e) {
        case "eip155":
          this.rpcProviders[e] = new Z2({ client: this.client, namespace: r, events: this.events });
          break;
        case "solana":
          this.rpcProviders[e] = new ee3({ client: this.client, namespace: r, events: this.events });
          break;
        case "cosmos":
          this.rpcProviders[e] = new te2({ client: this.client, namespace: r, events: this.events });
          break;
        case "polkadot":
          break;
        case "cip34":
          this.rpcProviders[e] = new se4({ client: this.client, namespace: r, events: this.events });
          break;
        case "elrond":
          this.rpcProviders[e] = new ie6({ client: this.client, namespace: r, events: this.events });
          break;
        case "multiversx":
          this.rpcProviders[e] = new ne4({ client: this.client, namespace: r, events: this.events });
          break;
      }
    });
  }
  registerEventListeners() {
    if (typeof this.client > "u")
      throw new Error("Sign Client is not initialized");
    this.client.on("session_ping", (e) => {
      this.events.emit("session_ping", e);
    }), this.client.on("session_event", (e) => {
      const { params: t } = e, { event: s } = t;
      s.name === "accountsChanged" ? this.events.emit("accountsChanged", s.data) : s.name === "chainChanged" ? this.onChainChanged(t.chainId) : this.events.emit(s.name, s.data), this.events.emit("session_event", e);
    }), this.client.on("session_update", ({ topic: e, params: t }) => {
      var s;
      const { namespaces: n2 } = t, r = (s = this.client) == null ? void 0 : s.session.get(e);
      this.session = w3(u3({}, r), { namespaces: n2 }), this.onSessionUpdate(), this.events.emit("session_update", { topic: e, params: t });
    }), this.client.on("session_delete", async (e) => {
      await this.cleanup(), this.events.emit("session_delete", e), this.events.emit("disconnect", w3(u3({}, R3("USER_DISCONNECTED")), { data: e.topic }));
    }), this.on(o.DEFAULT_CHAIN_CHANGED, (e) => {
      this.onChainChanged(e, true);
    });
  }
  getProvider(e) {
    if (!this.rpcProviders[e])
      throw new Error(`Provider not found: ${e}`);
    return this.rpcProviders[e];
  }
  onSessionUpdate() {
    Object.keys(this.rpcProviders).forEach((e) => {
      var t;
      this.getProvider(e).updateNamespace((t = this.session) == null ? void 0 : t.namespaces[e]);
    });
  }
  setNamespaces(e) {
    const { namespaces: t, optionalNamespaces: s, sessionProperties: n2 } = e;
    if (!t || !Object.keys(t).length)
      throw new Error("Namespaces must be not empty");
    this.namespaces = t, this.optionalNamespaces = s, this.sessionProperties = n2, this.persist("namespaces", t), this.persist("optionalNamespaces", s);
  }
  validateChain(e) {
    const [t, s] = (e == null ? void 0 : e.split(":")) || ["", ""];
    if (t && !Object.keys(this.namespaces).includes(t))
      throw new Error(`Namespace '${t}' is not configured. Please call connect() first with namespace config.`);
    if (t && s)
      return [t, s];
    const n2 = Object.keys(this.namespaces)[0], r = this.rpcProviders[n2].getDefaultChain();
    return [n2, r];
  }
  async requestAccounts() {
    const [e] = this.validateChain();
    return await this.getProvider(e).requestAccounts();
  }
  onChainChanged(e, t = false) {
    const [s, n2] = this.validateChain(e);
    t || this.getProvider(s).setDefaultChain(n2), this.namespaces[s].defaultChain = n2, this.persist("namespaces", this.namespaces), this.events.emit("chainChanged", n2);
  }
  onConnect() {
    this.createProviders(), this.events.emit("connect", { session: this.session });
  }
  async cleanup() {
    this.session = void 0, await this.cleanupPendingPairings({ deletePairings: true });
  }
  persist(e, t) {
    this.client.core.storage.setItem(`${E2}/${e}`, t);
  }
  async getFromStore(e) {
    return await this.client.core.storage.getItem(`${E2}/${e}`);
  }
};
var pe4 = m3;

// node_modules/@walletconnect/ethereum-provider/dist/index.es.js
var j2 = "wc";
var $7 = "ethereum_provider";
var q5 = `${j2}@${2}:${$7}:`;
var N4 = "https://rpc.walletconnect.com/v1/";
var p3 = ["eth_sendTransaction", "personal_sign"];
var D2 = ["eth_accounts", "eth_requestAccounts", "eth_call", "eth_getBalance", "eth_sendRawTransaction", "eth_sign", "eth_signTransaction", "eth_signTypedData", "eth_signTypedData_v3", "eth_signTypedData_v4", "wallet_switchEthereumChain", "wallet_addEthereumChain", "wallet_getPermissions", "wallet_requestPermissions", "wallet_registerOnboarding", "wallet_watchAsset", "wallet_scanQRCode"];
var u4 = ["chainChanged", "accountsChanged"];
var U3 = ["message", "disconnect", "connect"];
var Q3 = Object.defineProperty;
var L = Object.defineProperties;
var H5 = Object.getOwnPropertyDescriptors;
var _3 = Object.getOwnPropertySymbols;
var G5 = Object.prototype.hasOwnProperty;
var K3 = Object.prototype.propertyIsEnumerable;
var y3 = (a3, t, s) => t in a3 ? Q3(a3, t, { enumerable: true, configurable: true, writable: true, value: s }) : a3[t] = s;
var I3 = (a3, t) => {
  for (var s in t || (t = {}))
    G5.call(t, s) && y3(a3, s, t[s]);
  if (_3)
    for (var s of _3(t))
      K3.call(t, s) && y3(a3, s, t[s]);
  return a3;
};
var O3 = (a3, t) => L(a3, H5(t));
function C7(a3) {
  return Number(a3[0].split(":")[1]);
}
function w4(a3) {
  return `0x${a3.toString(16)}`;
}
function V4(a3) {
  const { chains: t, optionalChains: s, methods: i2, optionalMethods: e, events: n2, optionalEvents: c2, rpcMap: h3 } = a3;
  if (!C(t))
    throw new Error("Invalid chains");
  const o2 = t, r = i2 || p3, f3 = n2 || u4, M4 = { [C7(o2)]: h3[C7(o2)] }, E3 = { chains: o2, methods: r, events: f3, rpcMap: M4 }, l = n2 == null ? void 0 : n2.filter((g3) => !u4.includes(g3)), d = i2 == null ? void 0 : i2.filter((g3) => !p3.includes(g3));
  if (!s && !c2 && !e && !(l != null && l.length) && !(d != null && d.length))
    return { required: E3 };
  const b4 = (l == null ? void 0 : l.length) && (d == null ? void 0 : d.length) || !s, A3 = { chains: [...new Set(b4 ? o2.concat(s || []) : s)], methods: [...new Set(r.concat(e || []))], events: [...new Set(f3.concat(c2 || []))], rpcMap: h3 };
  return { required: E3, optional: A3 };
}
var m4 = class {
  constructor() {
    this.events = new import_events8.EventEmitter(), this.namespace = "eip155", this.accounts = [], this.chainId = 1, this.STORAGE_KEY = q5, this.on = (t, s) => (this.events.on(t, s), this), this.once = (t, s) => (this.events.once(t, s), this), this.removeListener = (t, s) => (this.events.removeListener(t, s), this), this.off = (t, s) => (this.events.off(t, s), this), this.parseAccount = (t) => this.isCompatibleChainId(t) ? this.parseAccountId(t).address : t, this.signer = {}, this.rpc = {};
  }
  static async init(t) {
    const s = new m4();
    return await s.initialize(t), s;
  }
  async request(t) {
    return await this.signer.request(t, this.formatChainId(this.chainId));
  }
  sendAsync(t, s) {
    this.signer.sendAsync(t, s, this.formatChainId(this.chainId));
  }
  get connected() {
    return this.signer.client ? this.signer.client.core.relayer.connected : false;
  }
  get connecting() {
    return this.signer.client ? this.signer.client.core.relayer.connecting : false;
  }
  async enable() {
    return this.session || await this.connect(), await this.request({ method: "eth_requestAccounts" });
  }
  async connect(t) {
    if (!this.signer.client)
      throw new Error("Provider not initialized. Call init() first");
    this.loadConnectOpts(t);
    const { required: s, optional: i2 } = V4(this.rpc);
    try {
      const e = await new Promise(async (c2, h3) => {
        var o2;
        this.rpc.showQrModal && ((o2 = this.modal) == null || o2.subscribeModal((r) => {
          !r.open && !this.signer.session && (this.signer.abortPairingAttempt(), h3(new Error("Connection request reset. Please try again.")));
        })), await this.signer.connect(O3(I3({ namespaces: { [this.namespace]: s } }, i2 && { optionalNamespaces: { [this.namespace]: i2 } }), { pairingTopic: t == null ? void 0 : t.pairingTopic })).then((r) => {
          c2(r);
        }).catch((r) => {
          h3(new Error(r.message));
        });
      });
      if (!e)
        return;
      this.setChainIds(this.rpc.chains);
      const n2 = bn(e.namespaces, [this.namespace]);
      this.setAccounts(n2), this.events.emit("connect", { chainId: w4(this.chainId) });
    } catch (e) {
      throw this.signer.logger.error(e), e;
    } finally {
      this.modal && this.modal.closeModal();
    }
  }
  async disconnect() {
    this.session && await this.signer.disconnect(), this.reset();
  }
  get isWalletConnect() {
    return true;
  }
  get session() {
    return this.signer.session;
  }
  registerEventListeners() {
    this.signer.on("session_event", (t) => {
      const { params: s } = t, { event: i2 } = s;
      i2.name === "accountsChanged" ? (this.accounts = this.parseAccounts(i2.data), this.events.emit("accountsChanged", this.accounts)) : i2.name === "chainChanged" ? this.setChainId(this.formatChainId(i2.data)) : this.events.emit(i2.name, i2.data), this.events.emit("session_event", t);
    }), this.signer.on("chainChanged", (t) => {
      const s = parseInt(t);
      this.chainId = s, this.events.emit("chainChanged", w4(this.chainId)), this.persist();
    }), this.signer.on("session_update", (t) => {
      this.events.emit("session_update", t);
    }), this.signer.on("session_delete", (t) => {
      this.reset(), this.events.emit("session_delete", t), this.events.emit("disconnect", O3(I3({}, R("USER_DISCONNECTED")), { data: t.topic, name: "USER_DISCONNECTED" }));
    }), this.signer.on("display_uri", (t) => {
      var s, i2;
      this.rpc.showQrModal && ((s = this.modal) == null || s.closeModal(), (i2 = this.modal) == null || i2.openModal({ uri: t })), this.events.emit("display_uri", t);
    });
  }
  setHttpProvider(t) {
    this.request({ method: "wallet_switchEthereumChain", params: [{ chainId: t.toString(16) }] });
  }
  isCompatibleChainId(t) {
    return typeof t == "string" ? t.startsWith(`${this.namespace}:`) : false;
  }
  formatChainId(t) {
    return `${this.namespace}:${t}`;
  }
  parseChainId(t) {
    return Number(t.split(":")[1]);
  }
  setChainIds(t) {
    const s = t.filter((i2) => this.isCompatibleChainId(i2)).map((i2) => this.parseChainId(i2));
    s.length && (this.chainId = s[0], this.events.emit("chainChanged", w4(this.chainId)), this.persist());
  }
  setChainId(t) {
    if (this.isCompatibleChainId(t)) {
      const s = this.parseChainId(t);
      this.chainId = s, this.setHttpProvider(s);
    }
  }
  parseAccountId(t) {
    const [s, i2, e] = t.split(":");
    return { chainId: `${s}:${i2}`, address: e };
  }
  setAccounts(t) {
    this.accounts = t.filter((s) => this.parseChainId(this.parseAccountId(s).chainId) === this.chainId).map((s) => this.parseAccountId(s).address), this.events.emit("accountsChanged", this.accounts);
  }
  getRpcConfig(t) {
    var s, i2;
    return { chains: ((s = t.chains) == null ? void 0 : s.map((e) => this.formatChainId(e))) || [`${this.namespace}:1`], optionalChains: t.optionalChains ? t.optionalChains.map((e) => this.formatChainId(e)) : void 0, methods: (t == null ? void 0 : t.methods) || p3, events: (t == null ? void 0 : t.events) || u4, optionalMethods: (t == null ? void 0 : t.optionalMethods) || [], optionalEvents: (t == null ? void 0 : t.optionalEvents) || [], rpcMap: (t == null ? void 0 : t.rpcMap) || this.buildRpcMap(t.chains.concat(t.optionalChains || []), t.projectId), showQrModal: Boolean(t == null ? void 0 : t.showQrModal), qrModalOptions: (i2 = t == null ? void 0 : t.qrModalOptions) != null ? i2 : void 0, projectId: t.projectId, metadata: t.metadata };
  }
  buildRpcMap(t, s) {
    const i2 = {};
    return t.forEach((e) => {
      i2[e] = this.getRpcUrl(e, s);
    }), i2;
  }
  async initialize(t) {
    if (this.rpc = this.getRpcConfig(t), this.chainId = C7(this.rpc.chains), this.signer = await pe4.init({ projectId: this.rpc.projectId, metadata: this.rpc.metadata }), this.registerEventListeners(), await this.loadPersistedSession(), this.rpc.showQrModal)
      try {
        const { Web3Modal: s } = await import("./index.es-KUZ3ZITV.js");
        this.modal = new s(I3({ walletConnectVersion: 2, projectId: this.rpc.projectId, standaloneChains: this.rpc.chains }, this.rpc.qrModalOptions));
      } catch {
        throw new Error("To use QR modal, please install @web3modal/standalone package");
      }
  }
  loadConnectOpts(t) {
    if (!t)
      return;
    const { chains: s, optionalChains: i2, rpcMap: e } = t;
    s && C(s) && (this.rpc.chains = s.map((n2) => this.formatChainId(n2)), s.forEach((n2) => {
      this.rpc.rpcMap[n2] = (e == null ? void 0 : e[n2]) || this.getRpcUrl(n2);
    })), i2 && C(i2) && (this.rpc.optionalChains = [], this.rpc.optionalChains = i2 == null ? void 0 : i2.map((n2) => this.formatChainId(n2)), i2.forEach((n2) => {
      this.rpc.rpcMap[n2] = (e == null ? void 0 : e[n2]) || this.getRpcUrl(n2);
    }));
  }
  getRpcUrl(t, s) {
    var i2;
    return ((i2 = this.rpc.rpcMap) == null ? void 0 : i2[t]) || `${N4}?chainId=eip155:${t}&projectId=${s || this.rpc.projectId}`;
  }
  async loadPersistedSession() {
    if (!this.session)
      return;
    const t = await this.signer.client.core.storage.getItem(`${this.STORAGE_KEY}/chainId`);
    this.setChainIds(t ? [this.formatChainId(t)] : this.session.namespaces[this.namespace].accounts), this.setAccounts(this.session.namespaces[this.namespace].accounts);
  }
  reset() {
    this.chainId = 1, this.accounts = [];
  }
  persist() {
    this.session && this.signer.client.core.storage.setItem(`${this.STORAGE_KEY}/chainId`, this.chainId);
  }
  parseAccounts(t) {
    return typeof t == "string" || t instanceof String ? [this.parseAccount(t)] : t.map((s) => this.parseAccount(s));
  }
};
var Y4 = m4;
export {
  Y4 as EthereumProvider,
  U3 as OPTIONAL_EVENTS,
  D2 as OPTIONAL_METHODS,
  u4 as REQUIRED_EVENTS,
  p3 as REQUIRED_METHODS,
  m4 as default
};
//# sourceMappingURL=index.es-ACMM3LGC.js.map
