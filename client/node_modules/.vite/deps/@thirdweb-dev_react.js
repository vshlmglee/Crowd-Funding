import {
  frameWallet
} from "./chunk-7N6DMJ6H.js";
import {
  paperWallet
} from "./chunk-R2NTHXVG.js";
import {
  walletConnect
} from "./chunk-ATILLPH2.js";
import {
  safeWallet
} from "./chunk-W2YYN4WU.js";
import {
  magicLink
} from "./chunk-P2DF27DO.js";
import {
  TextDivider
} from "./chunk-UDQEC4N7.js";
import {
  $1746a345f3d73bb7$export$f680877a34711e37,
  $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c,
  $5cb92bef7577960e$export$177fb62ff3ec1f22,
  $5d3850c4d0b4e6c7$export$41fb9f06171c75f4,
  $5d3850c4d0b4e6c7$export$602eac185826482c,
  $5d3850c4d0b4e6c7$export$7c6e2c02157bb7d2,
  $5d3850c4d0b4e6c7$export$be92b6f5f03c0fe9,
  $5d3850c4d0b4e6c7$export$c6fdb837b070b4ff,
  $5d3850c4d0b4e6c7$export$f39c2d165cd861fe,
  $5d3850c4d0b4e6c7$export$f99233281efd08a0,
  $5e63c961fc1ce211$export$8c6ed5c666ac1360,
  $5e63c961fc1ce211$export$d9f1ccf0bdb05d45,
  $6ed0406888f73fc4$export$43e446d32b3d21af,
  $6ed0406888f73fc4$export$c7b2cbe3552a0d05,
  $71cd76cc60e0454e$export$6f32135080cb4c3,
  $8927f6f2acc4f386$export$250ffa63cdc0d034,
  $8927f6f2acc4f386$export$6d1a0317bde7de7f,
  $921a889cee6df7e8$export$99c2b779aa4e8b8b,
  $9f79659886946c16$export$e5c5a5f917a5871c,
  $b1b2314f5f9a1d84$export$25bec8c6f54ee79a,
  $c512c27ab02ef895$export$50c7b4e9d9f19c1,
  $d3863c46a17e8a28$export$20e40289641fbbb6,
  $e42e1063c40fb3ef$export$b9ecd428b558ff10,
  $f1701beae083dbae$export$602eac185826482c,
  BackButton,
  Combination_default,
  ConnectingScreen,
  FormFieldWithIconButton,
  GetStartedScreen,
  HeadlessConnectUI,
  HelperLink,
  Img,
  ModalConfigCtx,
  ModalDescription,
  ModalTitle,
  ScanScreen,
  SetModalConfigCtx,
  Skeleton,
  WalletSelection,
  WalletSelector,
  WalletUIStatesProvider,
  coinbaseWallet,
  defaultWallets,
  fadeInAnimation,
  hideOthers,
  isMobile,
  metamaskWallet,
  require_lib,
  useIsHeadlessWallet,
  useIsWalletModalOpen,
  useSetIsWalletModalOpen,
  walletConnectV1
} from "./chunk-OZUD3FIK.js";
import {
  Button,
  CheckIcon,
  ChevronRightIcon,
  CopyIcon,
  Cross2Icon,
  EnterIcon,
  ErrorMessage,
  ExclamationTriangleIcon,
  EyeClosedIcon,
  EyeOpenIcon,
  Flex,
  FormFooter,
  IconButton,
  Input,
  Label,
  MagnifyingGlassIcon,
  PinBottomIcon,
  ShuffleIcon,
  Spacer,
  Spinner,
  ThemeProvider,
  ThirdwebAuthProvider,
  ThirdwebConfigProvider,
  ThirdwebConnectedWalletProvider,
  ThirdwebProviderCore,
  ThirdwebSDKProvider,
  ThirdwebThemeContext,
  UploadIcon,
  __DEV__,
  _extends,
  compilerMetadata,
  contractType,
  darkTheme,
  fontSize,
  getErc1155,
  getErc20,
  getErc721,
  getErcs,
  iconSize,
  keyframes,
  lightTheme,
  media,
  newStyled,
  radius,
  resolveIpfsUri,
  resolveMimeType,
  shadow,
  shouldNeverPersistQuery,
  spacing,
  useAcceptDirectListingOffer,
  useActiveChain,
  useActiveClaimCondition,
  useActiveClaimConditionForWallet,
  useActiveListings,
  useAddress,
  useAirdropNFT,
  useAllRoleMembers,
  useAppURI,
  useAuctionWinner,
  useAuth,
  useBalance,
  useBatchesToReveal,
  useBidBuffer,
  useBurnNFT,
  useBurnToken,
  useBuyDirectListing,
  useBuyNow,
  useCancelDirectListing,
  useCancelEnglishAuction,
  useCancelListing,
  useChain,
  useChainId,
  useClaimConditions,
  useClaimIneligibilityReasons,
  useClaimNFT,
  useClaimToken,
  useClaimedNFTSupply,
  useClaimedNFTs,
  useClaimerProofs,
  useCompilerMetadata,
  useConnect,
  useConnectedWallet,
  useConnectionStatus,
  useContract,
  useContractEvents,
  useContractMetadata,
  useContractMetadataUpdate,
  useContractRead,
  useContractType,
  useContractWrite,
  useCreateAuctionListing,
  useCreateDirectListing,
  useCreateSmartWallet,
  useCreateWalletInstance,
  useDelayedRevealLazyMint,
  useDirectListing,
  useDirectListings,
  useDirectListingsCount,
  useDisconnect,
  useEdition,
  useEditionDrop,
  useEnglishAuction,
  useEnglishAuctionWinningBid,
  useEnglishAuctions,
  useEnglishAuctionsCount,
  useExecuteAuctionSale,
  useGrantRole,
  useIsAddressRole,
  useIsSmartWalletDeployed,
  useLazyMint,
  useListing,
  useListings,
  useListingsCount,
  useLogin,
  useLogout,
  useMakeBid,
  useMakeOffer,
  useMarketplace,
  useMetadata,
  useMinimumNextBid,
  useMintNFT,
  useMintNFTSupply,
  useMintToken,
  useMultiwrap,
  useMutation,
  useNFT,
  useNFTBalance,
  useNFTCollection,
  useNFTDrop,
  useNFTs,
  useNetwork,
  useNetworkMismatch,
  useOffers,
  useOwnedNFTs,
  usePack,
  usePlatformFees,
  usePrimarySaleRecipient,
  useQuery,
  useQueryClient,
  useReadonlySDK,
  useResetClaimConditions,
  useRevealLazyMint,
  useRevokeRole,
  useRoleMembers,
  useRoyaltySettings,
  useSDK,
  useSDKChainId,
  useSetAllRoleMembers,
  useSetAppURI,
  useSetClaimConditions,
  useSetConnectedWallet,
  useSetConnectionStatus,
  useSignatureDrop,
  useSigner,
  useSmartWallets,
  useSplit,
  useStorage,
  useStorageUpload,
  useSupportedChains,
  useSupportedWallet,
  useSwitchAccount,
  useSwitchChain,
  useThirdwebAuthContext,
  useThirdwebConfigContext,
  useThirdwebConnectedWalletContext,
  useToken,
  useTokenBalance,
  useTokenDecimals,
  useTokenDrop,
  useTokenSupply,
  useTotalCirculatingSupply,
  useTotalCount,
  useTransferBatchToken,
  useTransferNFT,
  useTransferToken,
  useUnclaimedNFTSupply,
  useUnclaimedNFTs,
  useUpdateMetadata,
  useUpdatePlatformFees,
  useUpdatePrimarySaleRecipient,
  useUpdateRoyaltySettings,
  useUser,
  useValidDirectListings,
  useValidEnglishAuctions,
  useVote,
  useWallet,
  useWalletConfig,
  useWalletContext,
  useWallets,
  useWatchTransactions,
  useWinningBid
} from "./chunk-FZ33VQ4Q.js";
import {
  LocalWallet,
  SmartWallet,
  ZerionWallet
} from "./chunk-RDOPESVP.js";
import "./chunk-BENPVMCZ.js";
import "./chunk-RM25UG3Z.js";
import "./chunk-BL5AGTOU.js";
import {
  assertWindowEthereum
} from "./chunk-FETDTUNB.js";
import {
  require_copy_to_clipboard
} from "./chunk-PHXX4BES.js";
import "./chunk-7EEN2ZWX.js";
import {
  init_es
} from "./chunk-SXM3NUOY.js";
import "./chunk-5WOQBMPG.js";
import "./chunk-CY63Z6PF.js";
import "./chunk-L4L7HN5R.js";
import "./chunk-JG4XYP4Y.js";
import "./chunk-7AECAD2M.js";
import "./chunk-QYBIZOMF.js";
import {
  walletIds
} from "./chunk-OLCE3NRE.js";
import "./chunk-F62DJTWJ.js";
import "./chunk-56PDSJSZ.js";
import "./chunk-ZD2O36CB.js";
import "./chunk-TJDZPDYI.js";
import "./chunk-UZDOK4BQ.js";
import {
  APPROVED_IMPLEMENTATIONS,
  ContractDeployer,
  EditionMetadataInputOrUriSchema,
  EditionMetadataInputSchema,
  EditionMetadataOutputSchema,
  EditionMetadataWithOwnerOutputSchema,
  LOCAL_NODE_PKEY,
  OptionalPropertiesInput,
  ProposalState,
  SUPPORTED_CHAIN_IDS,
  ThirdwebSDK,
  TokenMintInputSchema,
  UserWallet,
  checkVerificationStatus,
  computeCloneFactoryAddress,
  computeNativeTokenAddress,
  convertParamValues,
  createTransactionBatches,
  deployContractDeterministic,
  deployContractDeterministicRaw,
  deployCreate2Factory,
  deployWithThrowawayDeployer,
  directDeployDeterministic,
  directDeployDeterministicWithUri,
  estimateGasForDeploy,
  extractFunctionParamsFromAbi,
  getAllDetectedExtensionNames,
  getAllDetectedExtensions,
  getAllDetectedFeatureNames,
  getAllDetectedFeatures,
  getApprovedImplementation,
  getBlock,
  getBlockNumber,
  getBlockWithTransactions,
  getCachedAbiForContract,
  getChainId,
  getContract,
  getContractFromAbi,
  getDefaultTrustedForwarders,
  getDeployArguments,
  getDeploymentInfo,
  getEncodedConstructorParamsForThirdwebContract,
  getThirdwebContractAddress,
  getTrustedForwarders,
  isVerifiedOnEtherscan,
  matchesPrebuiltAbi,
  normalizeAmount,
  predictAddressDeterministic,
  predictAddressDeterministicWithUri,
  predictThirdwebContractAddress,
  toDisplayValue,
  toEther,
  toUnits,
  toWei,
  verify,
  verifyThirdwebPrebuiltImplementation,
  watchBlock,
  watchBlockNumber,
  watchBlockWithTransactions,
  watchTransactions
} from "./chunk-ORAGSJLL.js";
import {
  TokenERC20History
} from "./chunk-D23TLJPD.js";
import {
  StandardErc20
} from "./chunk-OXAJC4ZB.js";
import {
  VoteType
} from "./chunk-E3TFATJ7.js";
import {
  ListingType,
  MarketplaceAuction,
  MarketplaceDirect
} from "./chunk-7KGO3PSZ.js";
import {
  hasERC20Allowance
} from "./chunk-5UEGDNJK.js";
import {
  StandardErc721
} from "./chunk-BUTP5E4N.js";
import {
  DropErc1155History
} from "./chunk-DFRSFLUM.js";
import {
  PAPER_API_URL,
  PaperCheckout,
  createCheckoutLinkIntent,
  fetchRegisteredCheckoutId,
  parseChainIdToPaperChain
} from "./chunk-YJBHRKKK.js";
import {
  StandardErc1155
} from "./chunk-JHRKZYUE.js";
import {
  ALL_ROLES,
  AbiObjectSchema,
  AbiSchema,
  AbiTypeSchema,
  AddressOrEnsSchema,
  AddressSchema,
  AdminRoleMissingError,
  AssetNotFoundError,
  AuctionAlreadyStartedError,
  AuctionHasNotEndedError,
  BYOCContractMetadataSchema,
  BaseSignaturePayloadInput,
  BigNumberSchema,
  BigNumberTransformSchema,
  BigNumberishSchema,
  COMMON_FACTORY,
  CONTRACTS_MAP,
  CONTRACT_ADDRESSES,
  CREATE2_FACTORY_BYTECODE,
  CallOverrideSchema,
  ChainId,
  ChainIdToAddressSchema,
  ClaimConditionInputArray,
  ClaimConditionInputSchema,
  ClaimConditionMetadataSchema,
  ClaimConditionOutputSchema,
  ClaimEligibility,
  CommonContractOutputSchema,
  CommonContractSchema,
  CommonPlatformFeeSchema,
  CommonPrimarySaleSchema,
  CommonRoyaltySchema,
  CommonSymbolSchema,
  CommonTrustedForwarderSchema,
  CompilerMetadataFetchedSchema,
  ContractAppURI,
  ContractEncoder,
  ContractEvents,
  ContractInfoSchema,
  ContractInterceptor,
  ContractMetadata,
  ContractOwner,
  ContractPlatformFee,
  ContractPrimarySale,
  ContractPublishedMetadata,
  ContractRoles,
  ContractRoyalty,
  CurrencySchema,
  CurrencyValueSchema,
  CustomContractDeploy,
  CustomContractInput,
  CustomContractOutput,
  CustomContractSchema,
  CustomFactoryInput,
  DEPLOYER_ABI,
  DEPLOYER_BYTECODE,
  DelayedReveal,
  DeployTransaction,
  DeployTypeInput,
  DeploymentNetworkInput,
  DropClaimConditions,
  DropErc1155ClaimConditions,
  DuplicateFileNameError,
  DuplicateLeafsError,
  EditionDropInitializer,
  EditionInitializer,
  EndDateSchema,
  Erc1155,
  Erc1155BatchMintable,
  Erc1155Burnable,
  Erc1155Enumerable,
  Erc1155LazyMintable,
  Erc1155Mintable,
  Erc1155SignatureMintable,
  Erc20,
  Erc20BatchMintable,
  Erc20Burnable,
  Erc20ClaimableWithConditions,
  Erc20Droppable,
  Erc20Mintable,
  Erc20SignatureMintable,
  Erc721,
  Erc721BatchMintable,
  Erc721Burnable,
  Erc721Claimable,
  Erc721ClaimableWithConditions,
  Erc721Enumerable,
  Erc721LazyMintable,
  Erc721Mintable,
  Erc721Supply,
  Erc721TieredDrop,
  Erc721WithQuantitySignatureMintable,
  EventType,
  ExtensionNotImplementedError,
  ExtraPublishMetadataSchemaInput,
  ExtraPublishMetadataSchemaOutput,
  FactoryDeploymentSchema,
  FetchError,
  FileNameMissingError,
  FullPublishMetadataSchemaInput,
  FullPublishMetadataSchemaOutput,
  FunctionDeprecatedError,
  GAS_LIMIT_FOR_DEPLOYER,
  GasCostEstimator,
  GenericRequest,
  InterfaceId_IERC1155,
  InterfaceId_IERC721,
  InvalidAddressError,
  LINK_TOKEN_ADDRESS,
  ListingNotFoundError,
  MarketplaceInitializer,
  MarketplaceV3DirectListings,
  MarketplaceV3EnglishAuctions,
  MarketplaceV3Initializer,
  MarketplaceV3Offers,
  MerkleSchema,
  MintRequest1155,
  MintRequest20,
  MintRequest721,
  MintRequest721withQuantity,
  MissingOwnerRoleError,
  MissingRoleError,
  MultiwrapInitializer,
  NATIVE_TOKENS,
  NATIVE_TOKEN_ADDRESS,
  NFTCollectionInitializer,
  NFTDropInitializer,
  NotEnoughTokensError,
  NotFoundError,
  OZ_DEFENDER_FORWARDER_ADDRESS,
  PREBUILT_CONTRACTS_APPURI_MAP,
  PREBUILT_CONTRACTS_MAP,
  PackInitializer,
  PartialClaimConditionInputSchema,
  PreDeployMetadata,
  PreDeployMetadataFetchedSchema,
  ProfileSchemaInput,
  ProfileSchemaOutput,
  PublishedContractSchema,
  QuantityAboveLimitError,
  RawDateSchema,
  RestrictedTransferError,
  SIGNATURE,
  SUPPORTED_FEATURES,
  Signature1155PayloadInput,
  Signature1155PayloadInputWithTokenId,
  Signature1155PayloadOutput,
  Signature20PayloadInput,
  Signature20PayloadOutput,
  Signature721PayloadInput,
  Signature721PayloadOutput,
  Signature721WithQuantityInput,
  Signature721WithQuantityOutput,
  SignatureDropInitializer,
  SnapshotEntryInput,
  SnapshotEntryWithProofSchema,
  SnapshotInfoSchema,
  SnapshotInputSchema,
  SnapshotSchema,
  SplitInitializer,
  StartDateSchema,
  StaticJsonRpcBatchProvider,
  Status,
  TokenDropInitializer,
  TokenInitializer,
  Transaction,
  TransactionError,
  UploadError,
  VoteInitializer,
  WrongListingTypeError,
  approveErc20Allowance,
  assertEnabled,
  biconomySendFunction,
  cleanCurrencyAddress,
  computeDeploymentAddress,
  computeDeploymentInfo,
  computeEOAForwarderAddress,
  computeForwarderAddress,
  convertToReadableQuantity,
  createSnapshot,
  defaultGaslessSendFunction,
  defenderSendFunction,
  detectContractFeature,
  detectFeatures,
  encodeConstructorParamsForImplementation,
  extractCommentFromMetadata,
  extractConstructorParams,
  extractConstructorParamsFromAbi,
  extractEventsFromAbi,
  extractFunctions,
  extractFunctionsFromAbi,
  extractIPFSHashFromBytecode,
  extractMinimalProxyImplementationAddress,
  fetchAbiFromAddress,
  fetchAndCacheDeployMetadata,
  fetchAndCachePublishedContractURI,
  fetchContractMetadataFromAddress,
  fetchCurrencyMetadata,
  fetchCurrencyValue,
  fetchExtendedReleaseMetadata,
  fetchPreDeployMetadata,
  fetchRawPredeployMetadata,
  fetchSnapshotEntryForAddress,
  fetchSourceFilesFromMetadata,
  getChainIdFromNetwork,
  getChainProvider,
  getContractAddressByChainId,
  getContractName,
  getContractPublisherAddress,
  getContractTypeForRemoteName,
  getCreate2FactoryAddress,
  getCreate2FactoryDeploymentInfo,
  getInitBytecodeWithSalt,
  getKeylessTxn,
  getMultichainRegistryAddress,
  getNativeTokenByChainId,
  getProviderFromRpcUrl,
  getRoleHash,
  getRpcUrl,
  getSaltHash,
  getSignerAndProvider,
  getSupportedChains,
  hasFunction,
  hasMatchingAbi,
  includesErrorMessage,
  invariant,
  isChainConfig,
  isContractDeployed,
  isDowngradeVersion,
  isEIP155Enforced,
  isExtensionEnabled,
  isFeatureEnabled,
  isIncrementalVersion,
  isNativeToken,
  isProvider,
  isSigner,
  normalizePriceValue,
  parseRevertReason,
  prepareGaslessRequest,
  resolveAddress,
  resolveContractUriFromAddress,
  resolveEns,
  setErc20Allowance,
  setSupportedChains,
  toSemver
} from "./chunk-6GQJFAXU.js";
import "./chunk-XUXNDKXO.js";
import "./chunk-KSBPR6CT.js";
import "./chunk-XQLXTUOU.js";
import {
  c1337
} from "./chunk-MF32MPNC.js";
import "./chunk-24M2PVBU.js";
import {
  init_lib7 as init_lib,
  utils_exports
} from "./chunk-T4GQYX7O.js";
import "./chunk-RGAYGF33.js";
import "./chunk-XLOOGUEN.js";
import "./chunk-2O4376VB.js";
import "./chunk-MLWVUS32.js";
import {
  require_jsx_runtime
} from "./chunk-UMZUPRA3.js";
import {
  require_react_dom
} from "./chunk-TRITR2GG.js";
import {
  require_react
} from "./chunk-TUKKSTYG.js";
import {
  init_shim
} from "./chunk-ZGMFR26H.js";
import {
  __toESM
} from "./chunk-IKJM6GHQ.js";

// node_modules/@thirdweb-dev/react/dist/thirdweb-dev-react.browser.esm.js
init_shim();
var import_react18 = __toESM(require_react());
var import_jsx_runtime2 = __toESM(require_jsx_runtime());

// node_modules/@thirdweb-dev/react/dist/useWalletConnect-36cbc580.browser.esm.js
init_shim();
var import_react14 = __toESM(require_react());
var import_jsx_runtime = __toESM(require_jsx_runtime());

// node_modules/@radix-ui/react-popover/dist/index.mjs
init_shim();
var import_react5 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-popper/dist/index.mjs
init_shim();
var import_react4 = __toESM(require_react(), 1);

// node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.esm.js
init_shim();

// node_modules/@floating-ui/dom/dist/floating-ui.dom.esm.js
init_shim();

// node_modules/@floating-ui/core/dist/floating-ui.core.esm.js
init_shim();
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getLengthFromAxis(axis) {
  return axis === "y" ? "height" : "width";
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "x" : "y";
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  const commonAlign = reference[length] / 2 - floating[length] / 2;
  const side = getSide(placement);
  const isVertical = mainAxis === "x";
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
      continue;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getSideObjectFromPadding(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getSideObjectFromPadding(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    ...rects.floating,
    x,
    y
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var min = Math.min;
var max = Math.max;
function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getSideObjectFromPadding(padding);
    const coords = {
      x,
      y
    };
    const axis = getMainAxisFromPlacement(placement);
    const length = getLengthFromAxis(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max3 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = within(min$1, center, max3);
    const shouldAddOffset = getAlignment(placement) != null && center != offset2 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? min$1 - center : max3 - center : 0;
    return {
      [axis]: coords[axis] - alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 + alignmentOffset
      }
    };
  }
});
var sides = ["top", "right", "bottom", "left"];
var allPlacements = sides.reduce((acc, side) => acc.concat(side, side + "-start", side + "-end"), []);
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  let mainAlignmentSide = mainAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return {
    main: mainAlignmentSide,
    cross: getOppositePlacement(mainAlignmentSide)
  };
}
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      const side = getSide(placement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const {
          main,
          cross
        } = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[main], overflow[cross]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$map$so;
              const placement2 = (_overflowsData$map$so = overflowsData.map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
var hide = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getMainAxisFromPlacement(placement) === "x";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      const {
        x,
        y
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: diffCoords
      };
    }
  };
};
function getCrossAxis(axis) {
  return axis === "x" ? "y" : "x";
}
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const mainAxis = getMainAxisFromPlacement(getSide(placement));
      const crossAxis = getCrossAxis(mainAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min3 = mainAxisCoord + overflow[minSide];
        const max3 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = within(min3, mainAxisCoord, max3);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min3 = crossAxisCoord + overflow[minSide];
        const max3 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = within(min3, crossAxisCoord, max3);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y
        }
      };
    }
  };
};
var limitShift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset2 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const mainAxis = getMainAxisFromPlacement(placement);
      const crossAxis = getCrossAxis(mainAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset2, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const axis = getMainAxisFromPlacement(placement);
      const isXAxis = axis === "x";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const overflowAvailableHeight = height - overflow[heightSide];
      const overflowAvailableWidth = width - overflow[widthSide];
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if (isXAxis) {
        const maximumClippingWidth = width - overflow.left - overflow.right;
        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
      } else {
        const maximumClippingHeight = height - overflow.top - overflow.bottom;
        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isXAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// node_modules/@floating-ui/dom/dist/floating-ui.dom.esm.js
function getWindow(node) {
  var _node$ownerDocument;
  return ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function isNode(value) {
  return value instanceof getWindow(value).Node;
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function isHTMLElement(value) {
  return value instanceof getWindow(value).HTMLElement;
}
function isElement(value) {
  return value instanceof getWindow(value).Element;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return node instanceof getWindow(node).ShadowRoot || node instanceof ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isContainingBlock(element) {
  const safari = isSafari();
  const css = getComputedStyle$1(element);
  return css.transform !== "none" || css.perspective !== "none" || !safari && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !safari && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function isSafari() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
var min2 = Math.min;
var max2 = Math.max;
var round = Math.round;
var floor = Math.floor;
var createEmptyCoords = (v) => ({
  x: v,
  y: v
});
function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createEmptyCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = createEmptyCoords(0);
function getVisualOffsets(element, isFixed, floatingOffsetParent) {
  var _win$visualViewport, _win$visualViewport2;
  if (isFixed === void 0) {
    isFixed = true;
  }
  if (!isSafari()) {
    return noOffsets;
  }
  const win = element ? getWindow(element) : window;
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== win) {
    return noOffsets;
  }
  return {
    x: ((_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) || 0,
    y: ((_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) || 0
  };
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createEmptyCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = getVisualOffsets(domElement, isFixedStrategy, offsetParent);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentIFrame = win.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== win) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentIFrame = getWindow(currentIFrame).frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getDocumentElement(node) {
  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  if (offsetParent === documentElement) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createEmptyCoords(1);
  const offsets = createEmptyCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max2(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max2(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x += max2(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = node.assignedSlot || node.parentNode || isShadowRoot(node) && node.host || getDocumentElement(node);
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list) {
  var _node$ownerDocument;
  if (list === void 0) {
    list = [];
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor));
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isSafari();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createEmptyCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max2(rect.top, accRect.top);
    accRect.right = min2(rect.right, accRect.right);
    accRect.bottom = min2(rect.bottom, accRect.bottom);
    accRect.left = max2(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  return getCssDimensions(element);
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = getParentNode(currentNode);
    }
  }
  return null;
}
function getOffsetParent(element, polyfill) {
  const window2 = getWindow(element);
  if (!isHTMLElement(element)) {
    return window2;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createEmptyCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
var platform = {
  getClippingRect,
  convertOffsetParentRelativeRectToViewportRelativeRect,
  isElement,
  getDimensions,
  getOffsetParent,
  getDocumentElement,
  getScale,
  async getElementRects(_ref) {
    let {
      reference,
      floating,
      strategy
    } = _ref;
    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
    const getDimensionsFn = this.getDimensions;
    return {
      reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),
      floating: {
        x: 0,
        y: 0,
        ...await getDimensionsFn(floating)
      }
    };
  },
  getClientRects: (element) => Array.from(element.getClientRects()),
  isRTL: (element) => getComputedStyle$1(element).direction === "rtl"
};
function observeMove(element, onMove) {
  let io = null;
  const root = getDocumentElement(element);
  function cleanup() {
    io && io.disconnect();
    io = null;
  }
  function refresh(skip) {
    if (skip === void 0) {
      skip = false;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    let isFirstUpdate = true;
    io = new IntersectionObserver((entries) => {
      if (entries[0].intersectionRatio !== 1 && !isFirstUpdate) {
        refresh();
      }
      isFirstUpdate = false;
    }, {
      rootMargin,
      threshold: 1
    });
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = true,
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver(update);
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo && cleanupIo();
    resizeObserver && resizeObserver.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.esm.js
var React = __toESM(require_react());
var import_react = __toESM(require_react());
var ReactDOM = __toESM(require_react_dom());
var arrow2 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options === "function" ? options(state) : options;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      } else if (element) {
        return arrow({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
var index = typeof document !== "undefined" ? import_react.useLayoutEffect : import_react.useEffect;
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (typeof a === "function" && a.toString() === b.toString()) {
    return true;
  }
  let length, i, keys;
  if (a && b && typeof a == "object") {
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length)
        return false;
      for (i = length; i-- !== 0; ) {
        if (!deepEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) {
      return false;
    }
    for (i = length; i-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b, keys[i])) {
        return false;
      }
    }
    for (i = length; i-- !== 0; ) {
      const key = keys[i];
      if (key === "_owner" && a.$$typeof) {
        continue;
      }
      if (!deepEqual(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b !== b;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = React.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = React.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = React.useState(null);
  const [_floating, _setFloating] = React.useState(null);
  const setReference = React.useCallback((node) => {
    if (node != referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, [_setReference]);
  const setFloating = React.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, [_setFloating]);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React.useRef(null);
  const floatingRef = React.useRef(null);
  const dataRef = React.useRef(data);
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const update = React.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition2(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        isPositioned: true
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl)
      referenceRef.current = referenceEl;
    if (floatingEl)
      floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      } else {
        update();
      }
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef]);
  const refs = React.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x = roundByDPR(elements.floating, data.x);
    const y = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x + "px, " + y + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x,
      top: y
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return React.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}

// node_modules/@radix-ui/react-arrow/dist/index.mjs
init_shim();
var import_react2 = __toESM(require_react(), 1);
var $7e8f5cd07187803e$var$NAME = "Arrow";
var $7e8f5cd07187803e$export$21b07c8f274aebd5 = (0, import_react2.forwardRef)((props, forwardedRef) => {
  const { children, width = 10, height = 5, ...arrowProps } = props;
  return (0, import_react2.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.svg, _extends({}, arrowProps, {
    ref: forwardedRef,
    width,
    height,
    viewBox: "0 0 30 10",
    preserveAspectRatio: "none"
  }), props.asChild ? children : (0, import_react2.createElement)("polygon", {
    points: "0,0 30,0 15,10"
  }));
});
Object.assign($7e8f5cd07187803e$export$21b07c8f274aebd5, {
  displayName: $7e8f5cd07187803e$var$NAME
});
var $7e8f5cd07187803e$export$be92b6f5f03c0fe9 = $7e8f5cd07187803e$export$21b07c8f274aebd5;

// node_modules/@radix-ui/react-use-size/dist/index.mjs
init_shim();
var import_react3 = __toESM(require_react(), 1);
function $db6c3485150b8e66$export$1ab7ae714698c4b8(element) {
  const [size2, setSize] = (0, import_react3.useState)(void 0);
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (element) {
      setSize({
        width: element.offsetWidth,
        height: element.offsetHeight
      });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries))
          return;
        if (!entries.length)
          return;
        const entry = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element.offsetWidth;
          height = element.offsetHeight;
        }
        setSize({
          width,
          height
        });
      });
      resizeObserver.observe(element, {
        box: "border-box"
      });
      return () => resizeObserver.unobserve(element);
    } else
      setSize(void 0);
  }, [
    element
  ]);
  return size2;
}

// node_modules/@radix-ui/react-popper/dist/index.mjs
var $cf1ac5d9fe0e8206$var$POPPER_NAME = "Popper";
var [$cf1ac5d9fe0e8206$var$createPopperContext, $cf1ac5d9fe0e8206$export$722aac194ae923] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($cf1ac5d9fe0e8206$var$POPPER_NAME);
var [$cf1ac5d9fe0e8206$var$PopperProvider, $cf1ac5d9fe0e8206$var$usePopperContext] = $cf1ac5d9fe0e8206$var$createPopperContext($cf1ac5d9fe0e8206$var$POPPER_NAME);
var $cf1ac5d9fe0e8206$export$badac9ada3a0bdf9 = (props) => {
  const { __scopePopper, children } = props;
  const [anchor, setAnchor] = (0, import_react4.useState)(null);
  return (0, import_react4.createElement)($cf1ac5d9fe0e8206$var$PopperProvider, {
    scope: __scopePopper,
    anchor,
    onAnchorChange: setAnchor
  }, children);
};
Object.assign($cf1ac5d9fe0e8206$export$badac9ada3a0bdf9, {
  displayName: $cf1ac5d9fe0e8206$var$POPPER_NAME
});
var $cf1ac5d9fe0e8206$var$ANCHOR_NAME = "PopperAnchor";
var $cf1ac5d9fe0e8206$export$ecd4e1ccab6ed6d = (0, import_react4.forwardRef)((props, forwardedRef) => {
  const { __scopePopper, virtualRef, ...anchorProps } = props;
  const context = $cf1ac5d9fe0e8206$var$usePopperContext($cf1ac5d9fe0e8206$var$ANCHOR_NAME, __scopePopper);
  const ref = (0, import_react4.useRef)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
  (0, import_react4.useEffect)(() => {
    context.onAnchorChange((virtualRef === null || virtualRef === void 0 ? void 0 : virtualRef.current) || ref.current);
  });
  return virtualRef ? null : (0, import_react4.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, anchorProps, {
    ref: composedRefs
  }));
});
Object.assign($cf1ac5d9fe0e8206$export$ecd4e1ccab6ed6d, {
  displayName: $cf1ac5d9fe0e8206$var$ANCHOR_NAME
});
var $cf1ac5d9fe0e8206$var$CONTENT_NAME = "PopperContent";
var [$cf1ac5d9fe0e8206$var$PopperContentProvider, $cf1ac5d9fe0e8206$var$useContentContext] = $cf1ac5d9fe0e8206$var$createPopperContext($cf1ac5d9fe0e8206$var$CONTENT_NAME);
var $cf1ac5d9fe0e8206$export$bc4ae5855d3c4fc = (0, import_react4.forwardRef)((props, forwardedRef) => {
  var _arrowSize$width, _arrowSize$height, _middlewareData$arrow, _middlewareData$arrow2, _middlewareData$arrow3, _middlewareData$trans, _middlewareData$trans2, _middlewareData$hide;
  const { __scopePopper, side = "bottom", sideOffset = 0, align = "center", alignOffset = 0, arrowPadding = 0, collisionBoundary = [], collisionPadding: collisionPaddingProp = 0, sticky = "partial", hideWhenDetached = false, avoidCollisions = true, onPlaced, ...contentProps } = props;
  const context = $cf1ac5d9fe0e8206$var$usePopperContext($cf1ac5d9fe0e8206$var$CONTENT_NAME, __scopePopper);
  const [content, setContent] = (0, import_react4.useState)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
    forwardedRef,
    (node) => setContent(node)
  );
  const [arrow3, setArrow] = (0, import_react4.useState)(null);
  const arrowSize = $db6c3485150b8e66$export$1ab7ae714698c4b8(arrow3);
  const arrowWidth = (_arrowSize$width = arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.width) !== null && _arrowSize$width !== void 0 ? _arrowSize$width : 0;
  const arrowHeight = (_arrowSize$height = arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.height) !== null && _arrowSize$height !== void 0 ? _arrowSize$height : 0;
  const desiredPlacement = side + (align !== "center" ? "-" + align : "");
  const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...collisionPaddingProp
  };
  const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [
    collisionBoundary
  ];
  const hasExplicitBoundaries = boundary.length > 0;
  const detectOverflowOptions = {
    padding: collisionPadding,
    boundary: boundary.filter($cf1ac5d9fe0e8206$var$isNotNull),
    altBoundary: hasExplicitBoundaries
  };
  const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
    strategy: "fixed",
    placement: desiredPlacement,
    whileElementsMounted: autoUpdate,
    elements: {
      reference: context.anchor
    },
    middleware: [
      offset({
        mainAxis: sideOffset + arrowHeight,
        alignmentAxis: alignOffset
      }),
      avoidCollisions && shift({
        mainAxis: true,
        crossAxis: false,
        limiter: sticky === "partial" ? limitShift() : void 0,
        ...detectOverflowOptions
      }),
      avoidCollisions && flip({
        ...detectOverflowOptions
      }),
      size({
        ...detectOverflowOptions,
        apply: ({ elements, rects, availableWidth, availableHeight }) => {
          const { width: anchorWidth, height: anchorHeight } = rects.reference;
          const contentStyle = elements.floating.style;
          contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
          contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
          contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
          contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
        }
      }),
      arrow3 && arrow2({
        element: arrow3,
        padding: arrowPadding
      }),
      $cf1ac5d9fe0e8206$var$transformOrigin({
        arrowWidth,
        arrowHeight
      }),
      hideWhenDetached && hide({
        strategy: "referenceHidden"
      })
    ]
  });
  const [placedSide, placedAlign] = $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement);
  const handlePlaced = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onPlaced);
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (isPositioned)
      handlePlaced === null || handlePlaced === void 0 || handlePlaced();
  }, [
    isPositioned,
    handlePlaced
  ]);
  const arrowX = (_middlewareData$arrow = middlewareData.arrow) === null || _middlewareData$arrow === void 0 ? void 0 : _middlewareData$arrow.x;
  const arrowY = (_middlewareData$arrow2 = middlewareData.arrow) === null || _middlewareData$arrow2 === void 0 ? void 0 : _middlewareData$arrow2.y;
  const cannotCenterArrow = ((_middlewareData$arrow3 = middlewareData.arrow) === null || _middlewareData$arrow3 === void 0 ? void 0 : _middlewareData$arrow3.centerOffset) !== 0;
  const [contentZIndex, setContentZIndex] = (0, import_react4.useState)();
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (content)
      setContentZIndex(window.getComputedStyle(content).zIndex);
  }, [
    content
  ]);
  return (0, import_react4.createElement)("div", {
    ref: refs.setFloating,
    "data-radix-popper-content-wrapper": "",
    style: {
      ...floatingStyles,
      transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
      minWidth: "max-content",
      zIndex: contentZIndex,
      ["--radix-popper-transform-origin"]: [
        (_middlewareData$trans = middlewareData.transformOrigin) === null || _middlewareData$trans === void 0 ? void 0 : _middlewareData$trans.x,
        (_middlewareData$trans2 = middlewareData.transformOrigin) === null || _middlewareData$trans2 === void 0 ? void 0 : _middlewareData$trans2.y
      ].join(" ")
    },
    dir: props.dir
  }, (0, import_react4.createElement)($cf1ac5d9fe0e8206$var$PopperContentProvider, {
    scope: __scopePopper,
    placedSide,
    onArrowChange: setArrow,
    arrowX,
    arrowY,
    shouldHideArrow: cannotCenterArrow
  }, (0, import_react4.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
    "data-side": placedSide,
    "data-align": placedAlign
  }, contentProps, {
    ref: composedRefs,
    style: {
      ...contentProps.style,
      animation: !isPositioned ? "none" : void 0,
      opacity: (_middlewareData$hide = middlewareData.hide) !== null && _middlewareData$hide !== void 0 && _middlewareData$hide.referenceHidden ? 0 : void 0
    }
  }))));
});
Object.assign($cf1ac5d9fe0e8206$export$bc4ae5855d3c4fc, {
  displayName: $cf1ac5d9fe0e8206$var$CONTENT_NAME
});
var $cf1ac5d9fe0e8206$var$ARROW_NAME = "PopperArrow";
var $cf1ac5d9fe0e8206$var$OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var $cf1ac5d9fe0e8206$export$79d62cd4e10a3fd0 = (0, import_react4.forwardRef)(function $cf1ac5d9fe0e8206$export$79d62cd4e10a3fd02(props, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props;
  const contentContext = $cf1ac5d9fe0e8206$var$useContentContext($cf1ac5d9fe0e8206$var$ARROW_NAME, __scopePopper);
  const baseSide = $cf1ac5d9fe0e8206$var$OPPOSITE_SIDE[contentContext.placedSide];
  return (0, import_react4.createElement)("span", {
    ref: contentContext.onArrowChange,
    style: {
      position: "absolute",
      left: contentContext.arrowX,
      top: contentContext.arrowY,
      [baseSide]: 0,
      transformOrigin: {
        top: "",
        right: "0 0",
        bottom: "center 0",
        left: "100% 0"
      }[contentContext.placedSide],
      transform: {
        top: "translateY(100%)",
        right: "translateY(50%) rotate(90deg) translateX(-50%)",
        bottom: `rotate(180deg)`,
        left: "translateY(50%) rotate(-90deg) translateX(50%)"
      }[contentContext.placedSide],
      visibility: contentContext.shouldHideArrow ? "hidden" : void 0
    }
  }, (0, import_react4.createElement)($7e8f5cd07187803e$export$be92b6f5f03c0fe9, _extends({}, arrowProps, {
    ref: forwardedRef,
    style: {
      ...arrowProps.style,
      display: "block"
    }
  })));
});
Object.assign($cf1ac5d9fe0e8206$export$79d62cd4e10a3fd0, {
  displayName: $cf1ac5d9fe0e8206$var$ARROW_NAME
});
function $cf1ac5d9fe0e8206$var$isNotNull(value) {
  return value !== null;
}
var $cf1ac5d9fe0e8206$var$transformOrigin = (options) => ({
  name: "transformOrigin",
  options,
  fn(data) {
    var _middlewareData$arrow4, _middlewareData$arrow5, _middlewareData$arrow6, _middlewareData$arrow7, _middlewareData$arrow8;
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = ((_middlewareData$arrow4 = middlewareData.arrow) === null || _middlewareData$arrow4 === void 0 ? void 0 : _middlewareData$arrow4.centerOffset) !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
    const [placedSide, placedAlign] = $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement);
    const noArrowAlign = {
      start: "0%",
      center: "50%",
      end: "100%"
    }[placedAlign];
    const arrowXCenter = ((_middlewareData$arrow5 = (_middlewareData$arrow6 = middlewareData.arrow) === null || _middlewareData$arrow6 === void 0 ? void 0 : _middlewareData$arrow6.x) !== null && _middlewareData$arrow5 !== void 0 ? _middlewareData$arrow5 : 0) + arrowWidth / 2;
    const arrowYCenter = ((_middlewareData$arrow7 = (_middlewareData$arrow8 = middlewareData.arrow) === null || _middlewareData$arrow8 === void 0 ? void 0 : _middlewareData$arrow8.y) !== null && _middlewareData$arrow7 !== void 0 ? _middlewareData$arrow7 : 0) + arrowHeight / 2;
    let x = "";
    let y = "";
    if (placedSide === "bottom") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x = `${-arrowHeight}px`;
      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x = `${rects.floating.width + arrowHeight}px`;
      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return {
      data: {
        x,
        y
      }
    };
  }
});
function $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [
    side,
    align
  ];
}
var $cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9 = $cf1ac5d9fe0e8206$export$badac9ada3a0bdf9;
var $cf1ac5d9fe0e8206$export$b688253958b8dfe7 = $cf1ac5d9fe0e8206$export$ecd4e1ccab6ed6d;
var $cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2 = $cf1ac5d9fe0e8206$export$bc4ae5855d3c4fc;
var $cf1ac5d9fe0e8206$export$21b07c8f274aebd5 = $cf1ac5d9fe0e8206$export$79d62cd4e10a3fd0;

// node_modules/@radix-ui/react-popover/dist/index.mjs
var $cb5cc270b50c6fcd$var$POPOVER_NAME = "Popover";
var [$cb5cc270b50c6fcd$var$createPopoverContext, $cb5cc270b50c6fcd$export$c8393c9e73286932] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($cb5cc270b50c6fcd$var$POPOVER_NAME, [
  $cf1ac5d9fe0e8206$export$722aac194ae923
]);
var $cb5cc270b50c6fcd$var$usePopperScope = $cf1ac5d9fe0e8206$export$722aac194ae923();
var [$cb5cc270b50c6fcd$var$PopoverProvider, $cb5cc270b50c6fcd$var$usePopoverContext] = $cb5cc270b50c6fcd$var$createPopoverContext($cb5cc270b50c6fcd$var$POPOVER_NAME);
var $cb5cc270b50c6fcd$export$5b6b19405a83ff9d = (props) => {
  const { __scopePopover, children, open: openProp, defaultOpen, onOpenChange, modal = false } = props;
  const popperScope = $cb5cc270b50c6fcd$var$usePopperScope(__scopePopover);
  const triggerRef = (0, import_react5.useRef)(null);
  const [hasCustomAnchor, setHasCustomAnchor] = (0, import_react5.useState)(false);
  const [open = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return (0, import_react5.createElement)($cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9, popperScope, (0, import_react5.createElement)($cb5cc270b50c6fcd$var$PopoverProvider, {
    scope: __scopePopover,
    contentId: $1746a345f3d73bb7$export$f680877a34711e37(),
    triggerRef,
    open,
    onOpenChange: setOpen,
    onOpenToggle: (0, import_react5.useCallback)(
      () => setOpen(
        (prevOpen) => !prevOpen
      ),
      [
        setOpen
      ]
    ),
    hasCustomAnchor,
    onCustomAnchorAdd: (0, import_react5.useCallback)(
      () => setHasCustomAnchor(true),
      []
    ),
    onCustomAnchorRemove: (0, import_react5.useCallback)(
      () => setHasCustomAnchor(false),
      []
    ),
    modal
  }, children));
};
Object.assign($cb5cc270b50c6fcd$export$5b6b19405a83ff9d, {
  displayName: $cb5cc270b50c6fcd$var$POPOVER_NAME
});
var $cb5cc270b50c6fcd$var$ANCHOR_NAME = "PopoverAnchor";
var $cb5cc270b50c6fcd$export$96e5381f42521a79 = (0, import_react5.forwardRef)((props, forwardedRef) => {
  const { __scopePopover, ...anchorProps } = props;
  const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$ANCHOR_NAME, __scopePopover);
  const popperScope = $cb5cc270b50c6fcd$var$usePopperScope(__scopePopover);
  const { onCustomAnchorAdd, onCustomAnchorRemove } = context;
  (0, import_react5.useEffect)(() => {
    onCustomAnchorAdd();
    return () => onCustomAnchorRemove();
  }, [
    onCustomAnchorAdd,
    onCustomAnchorRemove
  ]);
  return (0, import_react5.createElement)($cf1ac5d9fe0e8206$export$b688253958b8dfe7, _extends({}, popperScope, anchorProps, {
    ref: forwardedRef
  }));
});
Object.assign($cb5cc270b50c6fcd$export$96e5381f42521a79, {
  displayName: $cb5cc270b50c6fcd$var$ANCHOR_NAME
});
var $cb5cc270b50c6fcd$var$TRIGGER_NAME = "PopoverTrigger";
var $cb5cc270b50c6fcd$export$7dacb05d26466c3 = (0, import_react5.forwardRef)((props, forwardedRef) => {
  const { __scopePopover, ...triggerProps } = props;
  const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$TRIGGER_NAME, __scopePopover);
  const popperScope = $cb5cc270b50c6fcd$var$usePopperScope(__scopePopover);
  const composedTriggerRef = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, context.triggerRef);
  const trigger = (0, import_react5.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends({
    type: "button",
    "aria-haspopup": "dialog",
    "aria-expanded": context.open,
    "aria-controls": context.contentId,
    "data-state": $cb5cc270b50c6fcd$var$getState(context.open)
  }, triggerProps, {
    ref: composedTriggerRef,
    onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onClick, context.onOpenToggle)
  }));
  return context.hasCustomAnchor ? trigger : (0, import_react5.createElement)($cf1ac5d9fe0e8206$export$b688253958b8dfe7, _extends({
    asChild: true
  }, popperScope), trigger);
});
Object.assign($cb5cc270b50c6fcd$export$7dacb05d26466c3, {
  displayName: $cb5cc270b50c6fcd$var$TRIGGER_NAME
});
var $cb5cc270b50c6fcd$var$PORTAL_NAME = "PopoverPortal";
var [$cb5cc270b50c6fcd$var$PortalProvider, $cb5cc270b50c6fcd$var$usePortalContext] = $cb5cc270b50c6fcd$var$createPopoverContext($cb5cc270b50c6fcd$var$PORTAL_NAME, {
  forceMount: void 0
});
var $cb5cc270b50c6fcd$export$dd679ffb4362d2d4 = (props) => {
  const { __scopePopover, forceMount, children, container } = props;
  const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$PORTAL_NAME, __scopePopover);
  return (0, import_react5.createElement)($cb5cc270b50c6fcd$var$PortalProvider, {
    scope: __scopePopover,
    forceMount
  }, (0, import_react5.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
    present: forceMount || context.open
  }, (0, import_react5.createElement)($f1701beae083dbae$export$602eac185826482c, {
    asChild: true,
    container
  }, children)));
};
Object.assign($cb5cc270b50c6fcd$export$dd679ffb4362d2d4, {
  displayName: $cb5cc270b50c6fcd$var$PORTAL_NAME
});
var $cb5cc270b50c6fcd$var$CONTENT_NAME = "PopoverContent";
var $cb5cc270b50c6fcd$export$d7e1f420b25549ff = (0, import_react5.forwardRef)((props, forwardedRef) => {
  const portalContext = $cb5cc270b50c6fcd$var$usePortalContext($cb5cc270b50c6fcd$var$CONTENT_NAME, props.__scopePopover);
  const { forceMount = portalContext.forceMount, ...contentProps } = props;
  const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$CONTENT_NAME, props.__scopePopover);
  return (0, import_react5.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
    present: forceMount || context.open
  }, context.modal ? (0, import_react5.createElement)($cb5cc270b50c6fcd$var$PopoverContentModal, _extends({}, contentProps, {
    ref: forwardedRef
  })) : (0, import_react5.createElement)($cb5cc270b50c6fcd$var$PopoverContentNonModal, _extends({}, contentProps, {
    ref: forwardedRef
  })));
});
Object.assign($cb5cc270b50c6fcd$export$d7e1f420b25549ff, {
  displayName: $cb5cc270b50c6fcd$var$CONTENT_NAME
});
var $cb5cc270b50c6fcd$var$PopoverContentModal = (0, import_react5.forwardRef)((props, forwardedRef) => {
  const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$CONTENT_NAME, props.__scopePopover);
  const contentRef = (0, import_react5.useRef)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, contentRef);
  const isRightClickOutsideRef = (0, import_react5.useRef)(false);
  (0, import_react5.useEffect)(() => {
    const content = contentRef.current;
    if (content)
      return hideOthers(content);
  }, []);
  return (0, import_react5.createElement)(Combination_default, {
    as: $5e63c961fc1ce211$export$8c6ed5c666ac1360,
    allowPinchZoom: true
  }, (0, import_react5.createElement)($cb5cc270b50c6fcd$var$PopoverContentImpl, _extends({}, props, {
    ref: composedRefs,
    trapFocus: context.open,
    disableOutsidePointerEvents: true,
    onCloseAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onCloseAutoFocus, (event) => {
      var _context$triggerRef$c;
      event.preventDefault();
      if (!isRightClickOutsideRef.current)
        (_context$triggerRef$c = context.triggerRef.current) === null || _context$triggerRef$c === void 0 || _context$triggerRef$c.focus();
    }),
    onPointerDownOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDownOutside, (event) => {
      const originalEvent = event.detail.originalEvent;
      const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
      const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
      isRightClickOutsideRef.current = isRightClick;
    }, {
      checkForDefaultPrevented: false
    }),
    onFocusOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      props.onFocusOutside,
      (event) => event.preventDefault(),
      {
        checkForDefaultPrevented: false
      }
    )
  })));
});
var $cb5cc270b50c6fcd$var$PopoverContentNonModal = (0, import_react5.forwardRef)((props, forwardedRef) => {
  const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$CONTENT_NAME, props.__scopePopover);
  const hasInteractedOutsideRef = (0, import_react5.useRef)(false);
  const hasPointerDownOutsideRef = (0, import_react5.useRef)(false);
  return (0, import_react5.createElement)($cb5cc270b50c6fcd$var$PopoverContentImpl, _extends({}, props, {
    ref: forwardedRef,
    trapFocus: false,
    disableOutsidePointerEvents: false,
    onCloseAutoFocus: (event) => {
      var _props$onCloseAutoFoc;
      (_props$onCloseAutoFoc = props.onCloseAutoFocus) === null || _props$onCloseAutoFoc === void 0 || _props$onCloseAutoFoc.call(props, event);
      if (!event.defaultPrevented) {
        var _context$triggerRef$c2;
        if (!hasInteractedOutsideRef.current)
          (_context$triggerRef$c2 = context.triggerRef.current) === null || _context$triggerRef$c2 === void 0 || _context$triggerRef$c2.focus();
        event.preventDefault();
      }
      hasInteractedOutsideRef.current = false;
      hasPointerDownOutsideRef.current = false;
    },
    onInteractOutside: (event) => {
      var _props$onInteractOuts, _context$triggerRef$c3;
      (_props$onInteractOuts = props.onInteractOutside) === null || _props$onInteractOuts === void 0 || _props$onInteractOuts.call(props, event);
      if (!event.defaultPrevented) {
        hasInteractedOutsideRef.current = true;
        if (event.detail.originalEvent.type === "pointerdown")
          hasPointerDownOutsideRef.current = true;
      }
      const target = event.target;
      const targetIsTrigger = (_context$triggerRef$c3 = context.triggerRef.current) === null || _context$triggerRef$c3 === void 0 ? void 0 : _context$triggerRef$c3.contains(target);
      if (targetIsTrigger)
        event.preventDefault();
      if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current)
        event.preventDefault();
    }
  }));
});
var $cb5cc270b50c6fcd$var$PopoverContentImpl = (0, import_react5.forwardRef)((props, forwardedRef) => {
  const { __scopePopover, trapFocus, onOpenAutoFocus, onCloseAutoFocus, disableOutsidePointerEvents, onEscapeKeyDown, onPointerDownOutside, onFocusOutside, onInteractOutside, ...contentProps } = props;
  const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$CONTENT_NAME, __scopePopover);
  const popperScope = $cb5cc270b50c6fcd$var$usePopperScope(__scopePopover);
  $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c();
  return (0, import_react5.createElement)($d3863c46a17e8a28$export$20e40289641fbbb6, {
    asChild: true,
    loop: true,
    trapped: trapFocus,
    onMountAutoFocus: onOpenAutoFocus,
    onUnmountAutoFocus: onCloseAutoFocus
  }, (0, import_react5.createElement)($5cb92bef7577960e$export$177fb62ff3ec1f22, {
    asChild: true,
    disableOutsidePointerEvents,
    onInteractOutside,
    onEscapeKeyDown,
    onPointerDownOutside,
    onFocusOutside,
    onDismiss: () => context.onOpenChange(false)
  }, (0, import_react5.createElement)($cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2, _extends({
    "data-state": $cb5cc270b50c6fcd$var$getState(context.open),
    role: "dialog",
    id: context.contentId
  }, popperScope, contentProps, {
    ref: forwardedRef,
    style: {
      ...contentProps.style,
      "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
      "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
      "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
    }
  }))));
});
var $cb5cc270b50c6fcd$var$CLOSE_NAME = "PopoverClose";
var $cb5cc270b50c6fcd$export$d6ac43ebaa40d53e = (0, import_react5.forwardRef)((props, forwardedRef) => {
  const { __scopePopover, ...closeProps } = props;
  const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$CLOSE_NAME, __scopePopover);
  return (0, import_react5.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends({
    type: "button"
  }, closeProps, {
    ref: forwardedRef,
    onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      props.onClick,
      () => context.onOpenChange(false)
    )
  }));
});
Object.assign($cb5cc270b50c6fcd$export$d6ac43ebaa40d53e, {
  displayName: $cb5cc270b50c6fcd$var$CLOSE_NAME
});
var $cb5cc270b50c6fcd$var$ARROW_NAME = "PopoverArrow";
var $cb5cc270b50c6fcd$export$3152841115e061b2 = (0, import_react5.forwardRef)((props, forwardedRef) => {
  const { __scopePopover, ...arrowProps } = props;
  const popperScope = $cb5cc270b50c6fcd$var$usePopperScope(__scopePopover);
  return (0, import_react5.createElement)($cf1ac5d9fe0e8206$export$21b07c8f274aebd5, _extends({}, popperScope, arrowProps, {
    ref: forwardedRef
  }));
});
Object.assign($cb5cc270b50c6fcd$export$3152841115e061b2, {
  displayName: $cb5cc270b50c6fcd$var$ARROW_NAME
});
function $cb5cc270b50c6fcd$var$getState(open) {
  return open ? "open" : "closed";
}
var $cb5cc270b50c6fcd$export$be92b6f5f03c0fe9 = $cb5cc270b50c6fcd$export$5b6b19405a83ff9d;
var $cb5cc270b50c6fcd$export$41fb9f06171c75f4 = $cb5cc270b50c6fcd$export$7dacb05d26466c3;
var $cb5cc270b50c6fcd$export$602eac185826482c = $cb5cc270b50c6fcd$export$dd679ffb4362d2d4;
var $cb5cc270b50c6fcd$export$7c6e2c02157bb7d2 = $cb5cc270b50c6fcd$export$d7e1f420b25549ff;
var $cb5cc270b50c6fcd$export$21b07c8f274aebd5 = $cb5cc270b50c6fcd$export$3152841115e061b2;

// node_modules/@thirdweb-dev/react/dist/useWalletConnect-36cbc580.browser.esm.js
var import_copy_to_clipboard = __toESM(require_copy_to_clipboard());

// node_modules/@radix-ui/react-tooltip/dist/index.mjs
init_shim();
var import_react7 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-visually-hidden/dist/index.mjs
init_shim();
var import_react6 = __toESM(require_react(), 1);
var $ea1ef594cf570d83$var$NAME = "VisuallyHidden";
var $ea1ef594cf570d83$export$439d29a4e110a164 = (0, import_react6.forwardRef)((props, forwardedRef) => {
  return (0, import_react6.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends({}, props, {
    ref: forwardedRef,
    style: {
      position: "absolute",
      border: 0,
      width: 1,
      height: 1,
      padding: 0,
      margin: -1,
      overflow: "hidden",
      clip: "rect(0, 0, 0, 0)",
      whiteSpace: "nowrap",
      wordWrap: "normal",
      ...props.style
    }
  }));
});
Object.assign($ea1ef594cf570d83$export$439d29a4e110a164, {
  displayName: $ea1ef594cf570d83$var$NAME
});
var $ea1ef594cf570d83$export$be92b6f5f03c0fe9 = $ea1ef594cf570d83$export$439d29a4e110a164;

// node_modules/@radix-ui/react-tooltip/dist/index.mjs
var [$a093c7e1ec25a057$var$createTooltipContext, $a093c7e1ec25a057$export$1c540a2224f0d865] = $c512c27ab02ef895$export$50c7b4e9d9f19c1("Tooltip", [
  $cf1ac5d9fe0e8206$export$722aac194ae923
]);
var $a093c7e1ec25a057$var$usePopperScope = $cf1ac5d9fe0e8206$export$722aac194ae923();
var $a093c7e1ec25a057$var$PROVIDER_NAME = "TooltipProvider";
var $a093c7e1ec25a057$var$DEFAULT_DELAY_DURATION = 700;
var $a093c7e1ec25a057$var$TOOLTIP_OPEN = "tooltip.open";
var [$a093c7e1ec25a057$var$TooltipProviderContextProvider, $a093c7e1ec25a057$var$useTooltipProviderContext] = $a093c7e1ec25a057$var$createTooltipContext($a093c7e1ec25a057$var$PROVIDER_NAME);
var $a093c7e1ec25a057$export$f78649fb9ca566b8 = (props) => {
  const { __scopeTooltip, delayDuration = $a093c7e1ec25a057$var$DEFAULT_DELAY_DURATION, skipDelayDuration = 300, disableHoverableContent = false, children } = props;
  const [isOpenDelayed, setIsOpenDelayed] = (0, import_react7.useState)(true);
  const isPointerInTransitRef = (0, import_react7.useRef)(false);
  const skipDelayTimerRef = (0, import_react7.useRef)(0);
  (0, import_react7.useEffect)(() => {
    const skipDelayTimer = skipDelayTimerRef.current;
    return () => window.clearTimeout(skipDelayTimer);
  }, []);
  return (0, import_react7.createElement)($a093c7e1ec25a057$var$TooltipProviderContextProvider, {
    scope: __scopeTooltip,
    isOpenDelayed,
    delayDuration,
    onOpen: (0, import_react7.useCallback)(() => {
      window.clearTimeout(skipDelayTimerRef.current);
      setIsOpenDelayed(false);
    }, []),
    onClose: (0, import_react7.useCallback)(() => {
      window.clearTimeout(skipDelayTimerRef.current);
      skipDelayTimerRef.current = window.setTimeout(
        () => setIsOpenDelayed(true),
        skipDelayDuration
      );
    }, [
      skipDelayDuration
    ]),
    isPointerInTransitRef,
    onPointerInTransitChange: (0, import_react7.useCallback)((inTransit) => {
      isPointerInTransitRef.current = inTransit;
    }, []),
    disableHoverableContent
  }, children);
};
Object.assign($a093c7e1ec25a057$export$f78649fb9ca566b8, {
  displayName: $a093c7e1ec25a057$var$PROVIDER_NAME
});
var $a093c7e1ec25a057$var$TOOLTIP_NAME = "Tooltip";
var [$a093c7e1ec25a057$var$TooltipContextProvider, $a093c7e1ec25a057$var$useTooltipContext] = $a093c7e1ec25a057$var$createTooltipContext($a093c7e1ec25a057$var$TOOLTIP_NAME);
var $a093c7e1ec25a057$export$28c660c63b792dea = (props) => {
  const { __scopeTooltip, children, open: openProp, defaultOpen = false, onOpenChange, disableHoverableContent: disableHoverableContentProp, delayDuration: delayDurationProp } = props;
  const providerContext = $a093c7e1ec25a057$var$useTooltipProviderContext($a093c7e1ec25a057$var$TOOLTIP_NAME, props.__scopeTooltip);
  const popperScope = $a093c7e1ec25a057$var$usePopperScope(__scopeTooltip);
  const [trigger, setTrigger] = (0, import_react7.useState)(null);
  const contentId = $1746a345f3d73bb7$export$f680877a34711e37();
  const openTimerRef = (0, import_react7.useRef)(0);
  const disableHoverableContent = disableHoverableContentProp !== null && disableHoverableContentProp !== void 0 ? disableHoverableContentProp : providerContext.disableHoverableContent;
  const delayDuration = delayDurationProp !== null && delayDurationProp !== void 0 ? delayDurationProp : providerContext.delayDuration;
  const wasOpenDelayedRef = (0, import_react7.useRef)(false);
  const [open1 = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: (open) => {
      if (open) {
        providerContext.onOpen();
        document.dispatchEvent(new CustomEvent($a093c7e1ec25a057$var$TOOLTIP_OPEN));
      } else
        providerContext.onClose();
      onOpenChange === null || onOpenChange === void 0 || onOpenChange(open);
    }
  });
  const stateAttribute = (0, import_react7.useMemo)(() => {
    return open1 ? wasOpenDelayedRef.current ? "delayed-open" : "instant-open" : "closed";
  }, [
    open1
  ]);
  const handleOpen = (0, import_react7.useCallback)(() => {
    window.clearTimeout(openTimerRef.current);
    wasOpenDelayedRef.current = false;
    setOpen(true);
  }, [
    setOpen
  ]);
  const handleClose = (0, import_react7.useCallback)(() => {
    window.clearTimeout(openTimerRef.current);
    setOpen(false);
  }, [
    setOpen
  ]);
  const handleDelayedOpen = (0, import_react7.useCallback)(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = window.setTimeout(() => {
      wasOpenDelayedRef.current = true;
      setOpen(true);
    }, delayDuration);
  }, [
    delayDuration,
    setOpen
  ]);
  (0, import_react7.useEffect)(() => {
    return () => window.clearTimeout(openTimerRef.current);
  }, []);
  return (0, import_react7.createElement)($cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9, popperScope, (0, import_react7.createElement)($a093c7e1ec25a057$var$TooltipContextProvider, {
    scope: __scopeTooltip,
    contentId,
    open: open1,
    stateAttribute,
    trigger,
    onTriggerChange: setTrigger,
    onTriggerEnter: (0, import_react7.useCallback)(() => {
      if (providerContext.isOpenDelayed)
        handleDelayedOpen();
      else
        handleOpen();
    }, [
      providerContext.isOpenDelayed,
      handleDelayedOpen,
      handleOpen
    ]),
    onTriggerLeave: (0, import_react7.useCallback)(() => {
      if (disableHoverableContent)
        handleClose();
      else
        window.clearTimeout(openTimerRef.current);
    }, [
      handleClose,
      disableHoverableContent
    ]),
    onOpen: handleOpen,
    onClose: handleClose,
    disableHoverableContent
  }, children));
};
Object.assign($a093c7e1ec25a057$export$28c660c63b792dea, {
  displayName: $a093c7e1ec25a057$var$TOOLTIP_NAME
});
var $a093c7e1ec25a057$var$TRIGGER_NAME = "TooltipTrigger";
var $a093c7e1ec25a057$export$8c610744efcf8a1d = (0, import_react7.forwardRef)((props, forwardedRef) => {
  const { __scopeTooltip, ...triggerProps } = props;
  const context = $a093c7e1ec25a057$var$useTooltipContext($a093c7e1ec25a057$var$TRIGGER_NAME, __scopeTooltip);
  const providerContext = $a093c7e1ec25a057$var$useTooltipProviderContext($a093c7e1ec25a057$var$TRIGGER_NAME, __scopeTooltip);
  const popperScope = $a093c7e1ec25a057$var$usePopperScope(__scopeTooltip);
  const ref = (0, import_react7.useRef)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref, context.onTriggerChange);
  const isPointerDownRef = (0, import_react7.useRef)(false);
  const hasPointerMoveOpenedRef = (0, import_react7.useRef)(false);
  const handlePointerUp = (0, import_react7.useCallback)(
    () => isPointerDownRef.current = false,
    []
  );
  (0, import_react7.useEffect)(() => {
    return () => document.removeEventListener("pointerup", handlePointerUp);
  }, [
    handlePointerUp
  ]);
  return (0, import_react7.createElement)($cf1ac5d9fe0e8206$export$b688253958b8dfe7, _extends({
    asChild: true
  }, popperScope), (0, import_react7.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends({
    "aria-describedby": context.open ? context.contentId : void 0,
    "data-state": context.stateAttribute
  }, triggerProps, {
    ref: composedRefs,
    onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerMove, (event) => {
      if (event.pointerType === "touch")
        return;
      if (!hasPointerMoveOpenedRef.current && !providerContext.isPointerInTransitRef.current) {
        context.onTriggerEnter();
        hasPointerMoveOpenedRef.current = true;
      }
    }),
    onPointerLeave: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerLeave, () => {
      context.onTriggerLeave();
      hasPointerMoveOpenedRef.current = false;
    }),
    onPointerDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDown, () => {
      isPointerDownRef.current = true;
      document.addEventListener("pointerup", handlePointerUp, {
        once: true
      });
    }),
    onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocus, () => {
      if (!isPointerDownRef.current)
        context.onOpen();
    }),
    onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onBlur, context.onClose),
    onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onClick, context.onClose)
  })));
});
Object.assign($a093c7e1ec25a057$export$8c610744efcf8a1d, {
  displayName: $a093c7e1ec25a057$var$TRIGGER_NAME
});
var $a093c7e1ec25a057$var$PORTAL_NAME = "TooltipPortal";
var [$a093c7e1ec25a057$var$PortalProvider, $a093c7e1ec25a057$var$usePortalContext] = $a093c7e1ec25a057$var$createTooltipContext($a093c7e1ec25a057$var$PORTAL_NAME, {
  forceMount: void 0
});
var $a093c7e1ec25a057$export$7b36b8f925ab7497 = (props) => {
  const { __scopeTooltip, forceMount, children, container } = props;
  const context = $a093c7e1ec25a057$var$useTooltipContext($a093c7e1ec25a057$var$PORTAL_NAME, __scopeTooltip);
  return (0, import_react7.createElement)($a093c7e1ec25a057$var$PortalProvider, {
    scope: __scopeTooltip,
    forceMount
  }, (0, import_react7.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
    present: forceMount || context.open
  }, (0, import_react7.createElement)($f1701beae083dbae$export$602eac185826482c, {
    asChild: true,
    container
  }, children)));
};
Object.assign($a093c7e1ec25a057$export$7b36b8f925ab7497, {
  displayName: $a093c7e1ec25a057$var$PORTAL_NAME
});
var $a093c7e1ec25a057$var$CONTENT_NAME = "TooltipContent";
var $a093c7e1ec25a057$export$e9003e2be37ec060 = (0, import_react7.forwardRef)((props, forwardedRef) => {
  const portalContext = $a093c7e1ec25a057$var$usePortalContext($a093c7e1ec25a057$var$CONTENT_NAME, props.__scopeTooltip);
  const { forceMount = portalContext.forceMount, side = "top", ...contentProps } = props;
  const context = $a093c7e1ec25a057$var$useTooltipContext($a093c7e1ec25a057$var$CONTENT_NAME, props.__scopeTooltip);
  return (0, import_react7.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
    present: forceMount || context.open
  }, context.disableHoverableContent ? (0, import_react7.createElement)($a093c7e1ec25a057$var$TooltipContentImpl, _extends({
    side
  }, contentProps, {
    ref: forwardedRef
  })) : (0, import_react7.createElement)($a093c7e1ec25a057$var$TooltipContentHoverable, _extends({
    side
  }, contentProps, {
    ref: forwardedRef
  })));
});
var $a093c7e1ec25a057$var$TooltipContentHoverable = (0, import_react7.forwardRef)((props, forwardedRef) => {
  const context = $a093c7e1ec25a057$var$useTooltipContext($a093c7e1ec25a057$var$CONTENT_NAME, props.__scopeTooltip);
  const providerContext = $a093c7e1ec25a057$var$useTooltipProviderContext($a093c7e1ec25a057$var$CONTENT_NAME, props.__scopeTooltip);
  const ref = (0, import_react7.useRef)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
  const [pointerGraceArea, setPointerGraceArea] = (0, import_react7.useState)(null);
  const { trigger, onClose } = context;
  const content = ref.current;
  const { onPointerInTransitChange } = providerContext;
  const handleRemoveGraceArea = (0, import_react7.useCallback)(() => {
    setPointerGraceArea(null);
    onPointerInTransitChange(false);
  }, [
    onPointerInTransitChange
  ]);
  const handleCreateGraceArea = (0, import_react7.useCallback)((event, hoverTarget) => {
    const currentTarget = event.currentTarget;
    const exitPoint = {
      x: event.clientX,
      y: event.clientY
    };
    const exitSide = $a093c7e1ec25a057$var$getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());
    const paddedExitPoints = $a093c7e1ec25a057$var$getPaddedExitPoints(exitPoint, exitSide);
    const hoverTargetPoints = $a093c7e1ec25a057$var$getPointsFromRect(hoverTarget.getBoundingClientRect());
    const graceArea = $a093c7e1ec25a057$var$getHull([
      ...paddedExitPoints,
      ...hoverTargetPoints
    ]);
    setPointerGraceArea(graceArea);
    onPointerInTransitChange(true);
  }, [
    onPointerInTransitChange
  ]);
  (0, import_react7.useEffect)(() => {
    return () => handleRemoveGraceArea();
  }, [
    handleRemoveGraceArea
  ]);
  (0, import_react7.useEffect)(() => {
    if (trigger && content) {
      const handleTriggerLeave = (event) => handleCreateGraceArea(event, content);
      const handleContentLeave = (event) => handleCreateGraceArea(event, trigger);
      trigger.addEventListener("pointerleave", handleTriggerLeave);
      content.addEventListener("pointerleave", handleContentLeave);
      return () => {
        trigger.removeEventListener("pointerleave", handleTriggerLeave);
        content.removeEventListener("pointerleave", handleContentLeave);
      };
    }
  }, [
    trigger,
    content,
    handleCreateGraceArea,
    handleRemoveGraceArea
  ]);
  (0, import_react7.useEffect)(() => {
    if (pointerGraceArea) {
      const handleTrackPointerGrace = (event) => {
        const target = event.target;
        const pointerPosition = {
          x: event.clientX,
          y: event.clientY
        };
        const hasEnteredTarget = (trigger === null || trigger === void 0 ? void 0 : trigger.contains(target)) || (content === null || content === void 0 ? void 0 : content.contains(target));
        const isPointerOutsideGraceArea = !$a093c7e1ec25a057$var$isPointInPolygon(pointerPosition, pointerGraceArea);
        if (hasEnteredTarget)
          handleRemoveGraceArea();
        else if (isPointerOutsideGraceArea) {
          handleRemoveGraceArea();
          onClose();
        }
      };
      document.addEventListener("pointermove", handleTrackPointerGrace);
      return () => document.removeEventListener("pointermove", handleTrackPointerGrace);
    }
  }, [
    trigger,
    content,
    pointerGraceArea,
    onClose,
    handleRemoveGraceArea
  ]);
  return (0, import_react7.createElement)($a093c7e1ec25a057$var$TooltipContentImpl, _extends({}, props, {
    ref: composedRefs
  }));
});
var [$a093c7e1ec25a057$var$VisuallyHiddenContentContextProvider, $a093c7e1ec25a057$var$useVisuallyHiddenContentContext] = $a093c7e1ec25a057$var$createTooltipContext($a093c7e1ec25a057$var$TOOLTIP_NAME, {
  isInside: false
});
var $a093c7e1ec25a057$var$TooltipContentImpl = (0, import_react7.forwardRef)((props, forwardedRef) => {
  const { __scopeTooltip, children, "aria-label": ariaLabel, onEscapeKeyDown, onPointerDownOutside, ...contentProps } = props;
  const context = $a093c7e1ec25a057$var$useTooltipContext($a093c7e1ec25a057$var$CONTENT_NAME, __scopeTooltip);
  const popperScope = $a093c7e1ec25a057$var$usePopperScope(__scopeTooltip);
  const { onClose } = context;
  (0, import_react7.useEffect)(() => {
    document.addEventListener($a093c7e1ec25a057$var$TOOLTIP_OPEN, onClose);
    return () => document.removeEventListener($a093c7e1ec25a057$var$TOOLTIP_OPEN, onClose);
  }, [
    onClose
  ]);
  (0, import_react7.useEffect)(() => {
    if (context.trigger) {
      const handleScroll = (event) => {
        const target = event.target;
        if (target !== null && target !== void 0 && target.contains(context.trigger))
          onClose();
      };
      window.addEventListener("scroll", handleScroll, {
        capture: true
      });
      return () => window.removeEventListener("scroll", handleScroll, {
        capture: true
      });
    }
  }, [
    context.trigger,
    onClose
  ]);
  return (0, import_react7.createElement)($5cb92bef7577960e$export$177fb62ff3ec1f22, {
    asChild: true,
    disableOutsidePointerEvents: false,
    onEscapeKeyDown,
    onPointerDownOutside,
    onFocusOutside: (event) => event.preventDefault(),
    onDismiss: onClose
  }, (0, import_react7.createElement)($cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2, _extends({
    "data-state": context.stateAttribute
  }, popperScope, contentProps, {
    ref: forwardedRef,
    style: {
      ...contentProps.style,
      "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
      "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
      "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
    }
  }), (0, import_react7.createElement)($5e63c961fc1ce211$export$d9f1ccf0bdb05d45, null, children), (0, import_react7.createElement)($a093c7e1ec25a057$var$VisuallyHiddenContentContextProvider, {
    scope: __scopeTooltip,
    isInside: true
  }, (0, import_react7.createElement)($ea1ef594cf570d83$export$be92b6f5f03c0fe9, {
    id: context.contentId,
    role: "tooltip"
  }, ariaLabel || children))));
});
Object.assign($a093c7e1ec25a057$export$e9003e2be37ec060, {
  displayName: $a093c7e1ec25a057$var$CONTENT_NAME
});
var $a093c7e1ec25a057$var$ARROW_NAME = "TooltipArrow";
var $a093c7e1ec25a057$export$c27ee0ad710f7559 = (0, import_react7.forwardRef)((props, forwardedRef) => {
  const { __scopeTooltip, ...arrowProps } = props;
  const popperScope = $a093c7e1ec25a057$var$usePopperScope(__scopeTooltip);
  const visuallyHiddenContentContext = $a093c7e1ec25a057$var$useVisuallyHiddenContentContext($a093c7e1ec25a057$var$ARROW_NAME, __scopeTooltip);
  return visuallyHiddenContentContext.isInside ? null : (0, import_react7.createElement)($cf1ac5d9fe0e8206$export$21b07c8f274aebd5, _extends({}, popperScope, arrowProps, {
    ref: forwardedRef
  }));
});
Object.assign($a093c7e1ec25a057$export$c27ee0ad710f7559, {
  displayName: $a093c7e1ec25a057$var$ARROW_NAME
});
function $a093c7e1ec25a057$var$getExitSideFromRect(point, rect) {
  const top = Math.abs(rect.top - point.y);
  const bottom = Math.abs(rect.bottom - point.y);
  const right = Math.abs(rect.right - point.x);
  const left = Math.abs(rect.left - point.x);
  switch (Math.min(top, bottom, right, left)) {
    case left:
      return "left";
    case right:
      return "right";
    case top:
      return "top";
    case bottom:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function $a093c7e1ec25a057$var$getPaddedExitPoints(exitPoint, exitSide, padding = 5) {
  const paddedExitPoints = [];
  switch (exitSide) {
    case "top":
      paddedExitPoints.push({
        x: exitPoint.x - padding,
        y: exitPoint.y + padding
      }, {
        x: exitPoint.x + padding,
        y: exitPoint.y + padding
      });
      break;
    case "bottom":
      paddedExitPoints.push({
        x: exitPoint.x - padding,
        y: exitPoint.y - padding
      }, {
        x: exitPoint.x + padding,
        y: exitPoint.y - padding
      });
      break;
    case "left":
      paddedExitPoints.push({
        x: exitPoint.x + padding,
        y: exitPoint.y - padding
      }, {
        x: exitPoint.x + padding,
        y: exitPoint.y + padding
      });
      break;
    case "right":
      paddedExitPoints.push({
        x: exitPoint.x - padding,
        y: exitPoint.y - padding
      }, {
        x: exitPoint.x - padding,
        y: exitPoint.y + padding
      });
      break;
  }
  return paddedExitPoints;
}
function $a093c7e1ec25a057$var$getPointsFromRect(rect) {
  const { top, right, bottom, left } = rect;
  return [
    {
      x: left,
      y: top
    },
    {
      x: right,
      y: top
    },
    {
      x: right,
      y: bottom
    },
    {
      x: left,
      y: bottom
    }
  ];
}
function $a093c7e1ec25a057$var$isPointInPolygon(point, polygon) {
  const { x, y } = point;
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i].x;
    const yi = polygon[i].y;
    const xj = polygon[j].x;
    const yj = polygon[j].y;
    const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect)
      inside = !inside;
  }
  return inside;
}
function $a093c7e1ec25a057$var$getHull(points) {
  const newPoints = points.slice();
  newPoints.sort((a, b) => {
    if (a.x < b.x)
      return -1;
    else if (a.x > b.x)
      return 1;
    else if (a.y < b.y)
      return -1;
    else if (a.y > b.y)
      return 1;
    else
      return 0;
  });
  return $a093c7e1ec25a057$var$getHullPresorted(newPoints);
}
function $a093c7e1ec25a057$var$getHullPresorted(points) {
  if (points.length <= 1)
    return points.slice();
  const upperHull = [];
  for (let i = 0; i < points.length; i++) {
    const p = points[i];
    while (upperHull.length >= 2) {
      const q = upperHull[upperHull.length - 1];
      const r = upperHull[upperHull.length - 2];
      if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x))
        upperHull.pop();
      else
        break;
    }
    upperHull.push(p);
  }
  upperHull.pop();
  const lowerHull = [];
  for (let i1 = points.length - 1; i1 >= 0; i1--) {
    const p = points[i1];
    while (lowerHull.length >= 2) {
      const q = lowerHull[lowerHull.length - 1];
      const r = lowerHull[lowerHull.length - 2];
      if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x))
        lowerHull.pop();
      else
        break;
    }
    lowerHull.push(p);
  }
  lowerHull.pop();
  if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y)
    return upperHull;
  else
    return upperHull.concat(lowerHull);
}
var $a093c7e1ec25a057$export$2881499e37b75b9a = $a093c7e1ec25a057$export$f78649fb9ca566b8;
var $a093c7e1ec25a057$export$be92b6f5f03c0fe9 = $a093c7e1ec25a057$export$28c660c63b792dea;
var $a093c7e1ec25a057$export$41fb9f06171c75f4 = $a093c7e1ec25a057$export$8c610744efcf8a1d;
var $a093c7e1ec25a057$export$602eac185826482c = $a093c7e1ec25a057$export$7b36b8f925ab7497;
var $a093c7e1ec25a057$export$7c6e2c02157bb7d2 = $a093c7e1ec25a057$export$e9003e2be37ec060;
var $a093c7e1ec25a057$export$21b07c8f274aebd5 = $a093c7e1ec25a057$export$c27ee0ad710f7559;

// node_modules/@thirdweb-dev/react/dist/useWalletConnect-36cbc580.browser.esm.js
init_lib();

// node_modules/@radix-ui/react-tabs/dist/index.mjs
init_shim();
var import_react11 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-roving-focus/dist/index.mjs
init_shim();
var import_react10 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-collection/dist/index.mjs
init_shim();
var import_react8 = __toESM(require_react(), 1);
function $e02a7d9cb1dc128c$export$c74125a8e3af6bb2(name) {
  const PROVIDER_NAME = name + "CollectionProvider";
  const [createCollectionContext, createCollectionScope] = $c512c27ab02ef895$export$50c7b4e9d9f19c1(PROVIDER_NAME);
  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(PROVIDER_NAME, {
    collectionRef: {
      current: null
    },
    itemMap: /* @__PURE__ */ new Map()
  });
  const CollectionProvider = (props) => {
    const { scope, children } = props;
    const ref = import_react8.default.useRef(null);
    const itemMap = import_react8.default.useRef(/* @__PURE__ */ new Map()).current;
    return import_react8.default.createElement(CollectionProviderImpl, {
      scope,
      itemMap,
      collectionRef: ref
    }, children);
  };
  Object.assign(CollectionProvider, {
    displayName: PROVIDER_NAME
  });
  const COLLECTION_SLOT_NAME = name + "CollectionSlot";
  const CollectionSlot = import_react8.default.forwardRef((props, forwardedRef) => {
    const { scope, children } = props;
    const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, context.collectionRef);
    return import_react8.default.createElement($5e63c961fc1ce211$export$8c6ed5c666ac1360, {
      ref: composedRefs
    }, children);
  });
  Object.assign(CollectionSlot, {
    displayName: COLLECTION_SLOT_NAME
  });
  const ITEM_SLOT_NAME = name + "CollectionItemSlot";
  const ITEM_DATA_ATTR = "data-radix-collection-item";
  const CollectionItemSlot = import_react8.default.forwardRef((props, forwardedRef) => {
    const { scope, children, ...itemData } = props;
    const ref = import_react8.default.useRef(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
    const context = useCollectionContext(ITEM_SLOT_NAME, scope);
    import_react8.default.useEffect(() => {
      context.itemMap.set(ref, {
        ref,
        ...itemData
      });
      return () => void context.itemMap.delete(ref);
    });
    return import_react8.default.createElement($5e63c961fc1ce211$export$8c6ed5c666ac1360, {
      [ITEM_DATA_ATTR]: "",
      ref: composedRefs
    }, children);
  });
  Object.assign(CollectionItemSlot, {
    displayName: ITEM_SLOT_NAME
  });
  function useCollection(scope) {
    const context = useCollectionContext(name + "CollectionConsumer", scope);
    const getItems = import_react8.default.useCallback(() => {
      const collectionNode = context.collectionRef.current;
      if (!collectionNode)
        return [];
      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
      const items = Array.from(context.itemMap.values());
      const orderedItems = items.sort(
        (a, b) => orderedNodes.indexOf(a.ref.current) - orderedNodes.indexOf(b.ref.current)
      );
      return orderedItems;
    }, [
      context.collectionRef,
      context.itemMap
    ]);
    return getItems;
  }
  return [
    {
      Provider: CollectionProvider,
      Slot: CollectionSlot,
      ItemSlot: CollectionItemSlot
    },
    useCollection,
    createCollectionScope
  ];
}

// node_modules/@radix-ui/react-direction/dist/index.mjs
init_shim();
var import_react9 = __toESM(require_react(), 1);
var $f631663db3294ace$var$DirectionContext = (0, import_react9.createContext)(void 0);
function $f631663db3294ace$export$b39126d51d94e6f3(localDir) {
  const globalDir = (0, import_react9.useContext)($f631663db3294ace$var$DirectionContext);
  return localDir || globalDir || "ltr";
}

// node_modules/@radix-ui/react-roving-focus/dist/index.mjs
var $d7bdfb9eb0fdf311$var$ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus";
var $d7bdfb9eb0fdf311$var$EVENT_OPTIONS = {
  bubbles: false,
  cancelable: true
};
var $d7bdfb9eb0fdf311$var$GROUP_NAME = "RovingFocusGroup";
var [$d7bdfb9eb0fdf311$var$Collection, $d7bdfb9eb0fdf311$var$useCollection, $d7bdfb9eb0fdf311$var$createCollectionScope] = $e02a7d9cb1dc128c$export$c74125a8e3af6bb2($d7bdfb9eb0fdf311$var$GROUP_NAME);
var [$d7bdfb9eb0fdf311$var$createRovingFocusGroupContext, $d7bdfb9eb0fdf311$export$c7109489551a4f4] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($d7bdfb9eb0fdf311$var$GROUP_NAME, [
  $d7bdfb9eb0fdf311$var$createCollectionScope
]);
var [$d7bdfb9eb0fdf311$var$RovingFocusProvider, $d7bdfb9eb0fdf311$var$useRovingFocusContext] = $d7bdfb9eb0fdf311$var$createRovingFocusGroupContext($d7bdfb9eb0fdf311$var$GROUP_NAME);
var $d7bdfb9eb0fdf311$export$8699f7c8af148338 = (0, import_react10.forwardRef)((props, forwardedRef) => {
  return (0, import_react10.createElement)($d7bdfb9eb0fdf311$var$Collection.Provider, {
    scope: props.__scopeRovingFocusGroup
  }, (0, import_react10.createElement)($d7bdfb9eb0fdf311$var$Collection.Slot, {
    scope: props.__scopeRovingFocusGroup
  }, (0, import_react10.createElement)($d7bdfb9eb0fdf311$var$RovingFocusGroupImpl, _extends({}, props, {
    ref: forwardedRef
  }))));
});
Object.assign($d7bdfb9eb0fdf311$export$8699f7c8af148338, {
  displayName: $d7bdfb9eb0fdf311$var$GROUP_NAME
});
var $d7bdfb9eb0fdf311$var$RovingFocusGroupImpl = (0, import_react10.forwardRef)((props, forwardedRef) => {
  const { __scopeRovingFocusGroup, orientation, loop = false, dir, currentTabStopId: currentTabStopIdProp, defaultCurrentTabStopId, onCurrentTabStopIdChange, onEntryFocus, ...groupProps } = props;
  const ref = (0, import_react10.useRef)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
  const direction = $f631663db3294ace$export$b39126d51d94e6f3(dir);
  const [currentTabStopId = null, setCurrentTabStopId] = $71cd76cc60e0454e$export$6f32135080cb4c3({
    prop: currentTabStopIdProp,
    defaultProp: defaultCurrentTabStopId,
    onChange: onCurrentTabStopIdChange
  });
  const [isTabbingBackOut, setIsTabbingBackOut] = (0, import_react10.useState)(false);
  const handleEntryFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onEntryFocus);
  const getItems = $d7bdfb9eb0fdf311$var$useCollection(__scopeRovingFocusGroup);
  const isClickFocusRef = (0, import_react10.useRef)(false);
  const [focusableItemsCount, setFocusableItemsCount] = (0, import_react10.useState)(0);
  (0, import_react10.useEffect)(() => {
    const node = ref.current;
    if (node) {
      node.addEventListener($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, handleEntryFocus);
      return () => node.removeEventListener($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, handleEntryFocus);
    }
  }, [
    handleEntryFocus
  ]);
  return (0, import_react10.createElement)($d7bdfb9eb0fdf311$var$RovingFocusProvider, {
    scope: __scopeRovingFocusGroup,
    orientation,
    dir: direction,
    loop,
    currentTabStopId,
    onItemFocus: (0, import_react10.useCallback)(
      (tabStopId) => setCurrentTabStopId(tabStopId),
      [
        setCurrentTabStopId
      ]
    ),
    onItemShiftTab: (0, import_react10.useCallback)(
      () => setIsTabbingBackOut(true),
      []
    ),
    onFocusableItemAdd: (0, import_react10.useCallback)(
      () => setFocusableItemsCount(
        (prevCount) => prevCount + 1
      ),
      []
    ),
    onFocusableItemRemove: (0, import_react10.useCallback)(
      () => setFocusableItemsCount(
        (prevCount) => prevCount - 1
      ),
      []
    )
  }, (0, import_react10.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
    tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,
    "data-orientation": orientation
  }, groupProps, {
    ref: composedRefs,
    style: {
      outline: "none",
      ...props.style
    },
    onMouseDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onMouseDown, () => {
      isClickFocusRef.current = true;
    }),
    onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocus, (event) => {
      const isKeyboardFocus = !isClickFocusRef.current;
      if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {
        const entryFocusEvent = new CustomEvent($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, $d7bdfb9eb0fdf311$var$EVENT_OPTIONS);
        event.currentTarget.dispatchEvent(entryFocusEvent);
        if (!entryFocusEvent.defaultPrevented) {
          const items = getItems().filter(
            (item) => item.focusable
          );
          const activeItem = items.find(
            (item) => item.active
          );
          const currentItem = items.find(
            (item) => item.id === currentTabStopId
          );
          const candidateItems = [
            activeItem,
            currentItem,
            ...items
          ].filter(Boolean);
          const candidateNodes = candidateItems.map(
            (item) => item.ref.current
          );
          $d7bdfb9eb0fdf311$var$focusFirst(candidateNodes);
        }
      }
      isClickFocusRef.current = false;
    }),
    onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      props.onBlur,
      () => setIsTabbingBackOut(false)
    )
  })));
});
var $d7bdfb9eb0fdf311$var$ITEM_NAME = "RovingFocusGroupItem";
var $d7bdfb9eb0fdf311$export$ab9df7c53fe8454 = (0, import_react10.forwardRef)((props, forwardedRef) => {
  const { __scopeRovingFocusGroup, focusable = true, active = false, tabStopId, ...itemProps } = props;
  const autoId = $1746a345f3d73bb7$export$f680877a34711e37();
  const id = tabStopId || autoId;
  const context = $d7bdfb9eb0fdf311$var$useRovingFocusContext($d7bdfb9eb0fdf311$var$ITEM_NAME, __scopeRovingFocusGroup);
  const isCurrentTabStop = context.currentTabStopId === id;
  const getItems = $d7bdfb9eb0fdf311$var$useCollection(__scopeRovingFocusGroup);
  const { onFocusableItemAdd, onFocusableItemRemove } = context;
  (0, import_react10.useEffect)(() => {
    if (focusable) {
      onFocusableItemAdd();
      return () => onFocusableItemRemove();
    }
  }, [
    focusable,
    onFocusableItemAdd,
    onFocusableItemRemove
  ]);
  return (0, import_react10.createElement)($d7bdfb9eb0fdf311$var$Collection.ItemSlot, {
    scope: __scopeRovingFocusGroup,
    id,
    focusable,
    active
  }, (0, import_react10.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends({
    tabIndex: isCurrentTabStop ? 0 : -1,
    "data-orientation": context.orientation
  }, itemProps, {
    ref: forwardedRef,
    onMouseDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onMouseDown, (event) => {
      if (!focusable)
        event.preventDefault();
      else
        context.onItemFocus(id);
    }),
    onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      props.onFocus,
      () => context.onItemFocus(id)
    ),
    onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
      if (event.key === "Tab" && event.shiftKey) {
        context.onItemShiftTab();
        return;
      }
      if (event.target !== event.currentTarget)
        return;
      const focusIntent = $d7bdfb9eb0fdf311$var$getFocusIntent(event, context.orientation, context.dir);
      if (focusIntent !== void 0) {
        event.preventDefault();
        const items = getItems().filter(
          (item) => item.focusable
        );
        let candidateNodes = items.map(
          (item) => item.ref.current
        );
        if (focusIntent === "last")
          candidateNodes.reverse();
        else if (focusIntent === "prev" || focusIntent === "next") {
          if (focusIntent === "prev")
            candidateNodes.reverse();
          const currentIndex = candidateNodes.indexOf(event.currentTarget);
          candidateNodes = context.loop ? $d7bdfb9eb0fdf311$var$wrapArray(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
        }
        setTimeout(
          () => $d7bdfb9eb0fdf311$var$focusFirst(candidateNodes)
        );
      }
    })
  })));
});
Object.assign($d7bdfb9eb0fdf311$export$ab9df7c53fe8454, {
  displayName: $d7bdfb9eb0fdf311$var$ITEM_NAME
});
var $d7bdfb9eb0fdf311$var$MAP_KEY_TO_FOCUS_INTENT = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function $d7bdfb9eb0fdf311$var$getDirectionAwareKey(key, dir) {
  if (dir !== "rtl")
    return key;
  return key === "ArrowLeft" ? "ArrowRight" : key === "ArrowRight" ? "ArrowLeft" : key;
}
function $d7bdfb9eb0fdf311$var$getFocusIntent(event, orientation, dir) {
  const key = $d7bdfb9eb0fdf311$var$getDirectionAwareKey(event.key, dir);
  if (orientation === "vertical" && [
    "ArrowLeft",
    "ArrowRight"
  ].includes(key))
    return void 0;
  if (orientation === "horizontal" && [
    "ArrowUp",
    "ArrowDown"
  ].includes(key))
    return void 0;
  return $d7bdfb9eb0fdf311$var$MAP_KEY_TO_FOCUS_INTENT[key];
}
function $d7bdfb9eb0fdf311$var$focusFirst(candidates) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)
      return;
    candidate.focus();
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT)
      return;
  }
}
function $d7bdfb9eb0fdf311$var$wrapArray(array, startIndex) {
  return array.map(
    (_, index2) => array[(startIndex + index2) % array.length]
  );
}
var $d7bdfb9eb0fdf311$export$be92b6f5f03c0fe9 = $d7bdfb9eb0fdf311$export$8699f7c8af148338;
var $d7bdfb9eb0fdf311$export$6d08773d2e66f8f2 = $d7bdfb9eb0fdf311$export$ab9df7c53fe8454;

// node_modules/@radix-ui/react-tabs/dist/index.mjs
var $69cb30bb0017df05$var$TABS_NAME = "Tabs";
var [$69cb30bb0017df05$var$createTabsContext, $69cb30bb0017df05$export$355f5bd209d7b13a] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($69cb30bb0017df05$var$TABS_NAME, [
  $d7bdfb9eb0fdf311$export$c7109489551a4f4
]);
var $69cb30bb0017df05$var$useRovingFocusGroupScope = $d7bdfb9eb0fdf311$export$c7109489551a4f4();
var [$69cb30bb0017df05$var$TabsProvider, $69cb30bb0017df05$var$useTabsContext] = $69cb30bb0017df05$var$createTabsContext($69cb30bb0017df05$var$TABS_NAME);
var $69cb30bb0017df05$export$b2539bed5023c21c = (0, import_react11.forwardRef)((props, forwardedRef) => {
  const { __scopeTabs, value: valueProp, onValueChange, defaultValue, orientation = "horizontal", dir, activationMode = "automatic", ...tabsProps } = props;
  const direction = $f631663db3294ace$export$b39126d51d94e6f3(dir);
  const [value, setValue] = $71cd76cc60e0454e$export$6f32135080cb4c3({
    prop: valueProp,
    onChange: onValueChange,
    defaultProp: defaultValue
  });
  return (0, import_react11.createElement)($69cb30bb0017df05$var$TabsProvider, {
    scope: __scopeTabs,
    baseId: $1746a345f3d73bb7$export$f680877a34711e37(),
    value,
    onValueChange: setValue,
    orientation,
    dir: direction,
    activationMode
  }, (0, import_react11.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
    dir: direction,
    "data-orientation": orientation
  }, tabsProps, {
    ref: forwardedRef
  })));
});
Object.assign($69cb30bb0017df05$export$b2539bed5023c21c, {
  displayName: $69cb30bb0017df05$var$TABS_NAME
});
var $69cb30bb0017df05$var$TAB_LIST_NAME = "TabsList";
var $69cb30bb0017df05$export$9712d22edc0d78c1 = (0, import_react11.forwardRef)((props, forwardedRef) => {
  const { __scopeTabs, loop = true, ...listProps } = props;
  const context = $69cb30bb0017df05$var$useTabsContext($69cb30bb0017df05$var$TAB_LIST_NAME, __scopeTabs);
  const rovingFocusGroupScope = $69cb30bb0017df05$var$useRovingFocusGroupScope(__scopeTabs);
  return (0, import_react11.createElement)($d7bdfb9eb0fdf311$export$be92b6f5f03c0fe9, _extends({
    asChild: true
  }, rovingFocusGroupScope, {
    orientation: context.orientation,
    dir: context.dir,
    loop
  }), (0, import_react11.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
    role: "tablist",
    "aria-orientation": context.orientation
  }, listProps, {
    ref: forwardedRef
  })));
});
Object.assign($69cb30bb0017df05$export$9712d22edc0d78c1, {
  displayName: $69cb30bb0017df05$var$TAB_LIST_NAME
});
var $69cb30bb0017df05$var$TRIGGER_NAME = "TabsTrigger";
var $69cb30bb0017df05$export$8114b9fdfdf9f3ba = (0, import_react11.forwardRef)((props, forwardedRef) => {
  const { __scopeTabs, value, disabled = false, ...triggerProps } = props;
  const context = $69cb30bb0017df05$var$useTabsContext($69cb30bb0017df05$var$TRIGGER_NAME, __scopeTabs);
  const rovingFocusGroupScope = $69cb30bb0017df05$var$useRovingFocusGroupScope(__scopeTabs);
  const triggerId = $69cb30bb0017df05$var$makeTriggerId(context.baseId, value);
  const contentId = $69cb30bb0017df05$var$makeContentId(context.baseId, value);
  const isSelected = value === context.value;
  return (0, import_react11.createElement)($d7bdfb9eb0fdf311$export$6d08773d2e66f8f2, _extends({
    asChild: true
  }, rovingFocusGroupScope, {
    focusable: !disabled,
    active: isSelected
  }), (0, import_react11.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends({
    type: "button",
    role: "tab",
    "aria-selected": isSelected,
    "aria-controls": contentId,
    "data-state": isSelected ? "active" : "inactive",
    "data-disabled": disabled ? "" : void 0,
    disabled,
    id: triggerId
  }, triggerProps, {
    ref: forwardedRef,
    onMouseDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onMouseDown, (event) => {
      if (!disabled && event.button === 0 && event.ctrlKey === false)
        context.onValueChange(value);
      else
        event.preventDefault();
    }),
    onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
      if ([
        " ",
        "Enter"
      ].includes(event.key))
        context.onValueChange(value);
    }),
    onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocus, () => {
      const isAutomaticActivation = context.activationMode !== "manual";
      if (!isSelected && !disabled && isAutomaticActivation)
        context.onValueChange(value);
    })
  })));
});
Object.assign($69cb30bb0017df05$export$8114b9fdfdf9f3ba, {
  displayName: $69cb30bb0017df05$var$TRIGGER_NAME
});
var $69cb30bb0017df05$var$CONTENT_NAME = "TabsContent";
var $69cb30bb0017df05$export$bd905d70e8fd2ebb = (0, import_react11.forwardRef)((props, forwardedRef) => {
  const { __scopeTabs, value, forceMount, children, ...contentProps } = props;
  const context = $69cb30bb0017df05$var$useTabsContext($69cb30bb0017df05$var$CONTENT_NAME, __scopeTabs);
  const triggerId = $69cb30bb0017df05$var$makeTriggerId(context.baseId, value);
  const contentId = $69cb30bb0017df05$var$makeContentId(context.baseId, value);
  const isSelected = value === context.value;
  const isMountAnimationPreventedRef = (0, import_react11.useRef)(isSelected);
  (0, import_react11.useEffect)(() => {
    const rAF = requestAnimationFrame(
      () => isMountAnimationPreventedRef.current = false
    );
    return () => cancelAnimationFrame(rAF);
  }, []);
  return (0, import_react11.createElement)(
    $921a889cee6df7e8$export$99c2b779aa4e8b8b,
    {
      present: forceMount || isSelected
    },
    ({ present }) => (0, import_react11.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
      "data-state": isSelected ? "active" : "inactive",
      "data-orientation": context.orientation,
      role: "tabpanel",
      "aria-labelledby": triggerId,
      hidden: !present,
      id: contentId,
      tabIndex: 0
    }, contentProps, {
      ref: forwardedRef,
      style: {
        ...props.style,
        animationDuration: isMountAnimationPreventedRef.current ? "0s" : void 0
      }
    }), present && children)
  );
});
Object.assign($69cb30bb0017df05$export$bd905d70e8fd2ebb, {
  displayName: $69cb30bb0017df05$var$CONTENT_NAME
});
function $69cb30bb0017df05$var$makeTriggerId(baseId, value) {
  return `${baseId}-trigger-${value}`;
}
function $69cb30bb0017df05$var$makeContentId(baseId, value) {
  return `${baseId}-content-${value}`;
}
var $69cb30bb0017df05$export$be92b6f5f03c0fe9 = $69cb30bb0017df05$export$b2539bed5023c21c;
var $69cb30bb0017df05$export$54c2e3dc7acea9f5 = $69cb30bb0017df05$export$9712d22edc0d78c1;
var $69cb30bb0017df05$export$41fb9f06171c75f4 = $69cb30bb0017df05$export$8114b9fdfdf9f3ba;
var $69cb30bb0017df05$export$7c6e2c02157bb7d2 = $69cb30bb0017df05$export$bd905d70e8fd2ebb;

// node_modules/fuse.js/dist/fuse.esm.js
init_shim();
function isArray(value) {
  return !Array.isArray ? getTag(value) === "[object Array]" : Array.isArray(value);
}
var INFINITY = 1 / 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  let result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function toString(value) {
  return value == null ? "" : baseToString(value);
}
function isString(value) {
  return typeof value === "string";
}
function isNumber(value) {
  return typeof value === "number";
}
function isBoolean(value) {
  return value === true || value === false || isObjectLike(value) && getTag(value) == "[object Boolean]";
}
function isObject(value) {
  return typeof value === "object";
}
function isObjectLike(value) {
  return isObject(value) && value !== null;
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isBlank(value) {
  return !value.trim().length;
}
function getTag(value) {
  return value == null ? value === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value);
}
var INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
var LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) => `Invalid value for key ${key}`;
var PATTERN_LENGTH_TOO_LARGE = (max3) => `Pattern length exceeds max of ${max3}.`;
var MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;
var INVALID_KEY_WEIGHT_VALUE = (key) => `Property 'weight' in key '${key}' must be a positive integer`;
var hasOwn = Object.prototype.hasOwnProperty;
var KeyStore = class {
  constructor(keys) {
    this._keys = [];
    this._keyMap = {};
    let totalWeight = 0;
    keys.forEach((key) => {
      let obj = createKey(key);
      totalWeight += obj.weight;
      this._keys.push(obj);
      this._keyMap[obj.id] = obj;
      totalWeight += obj.weight;
    });
    this._keys.forEach((key) => {
      key.weight /= totalWeight;
    });
  }
  get(keyId) {
    return this._keyMap[keyId];
  }
  keys() {
    return this._keys;
  }
  toJSON() {
    return JSON.stringify(this._keys);
  }
};
function createKey(key) {
  let path = null;
  let id = null;
  let src = null;
  let weight = 1;
  let getFn = null;
  if (isString(key) || isArray(key)) {
    src = key;
    path = createKeyPath(key);
    id = createKeyId(key);
  } else {
    if (!hasOwn.call(key, "name")) {
      throw new Error(MISSING_KEY_PROPERTY("name"));
    }
    const name = key.name;
    src = name;
    if (hasOwn.call(key, "weight")) {
      weight = key.weight;
      if (weight <= 0) {
        throw new Error(INVALID_KEY_WEIGHT_VALUE(name));
      }
    }
    path = createKeyPath(name);
    id = createKeyId(name);
    getFn = key.getFn;
  }
  return { path, id, weight, src, getFn };
}
function createKeyPath(key) {
  return isArray(key) ? key : key.split(".");
}
function createKeyId(key) {
  return isArray(key) ? key.join(".") : key;
}
function get(obj, path) {
  let list = [];
  let arr = false;
  const deepGet = (obj2, path2, index2) => {
    if (!isDefined(obj2)) {
      return;
    }
    if (!path2[index2]) {
      list.push(obj2);
    } else {
      let key = path2[index2];
      const value = obj2[key];
      if (!isDefined(value)) {
        return;
      }
      if (index2 === path2.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {
        list.push(toString(value));
      } else if (isArray(value)) {
        arr = true;
        for (let i = 0, len = value.length; i < len; i += 1) {
          deepGet(value[i], path2, index2 + 1);
        }
      } else if (path2.length) {
        deepGet(value, path2, index2 + 1);
      }
    }
  };
  deepGet(obj, isString(path) ? path.split(".") : path, 0);
  return arr ? list : list[0];
}
var MatchOptions = {
  includeMatches: false,
  findAllMatches: false,
  minMatchCharLength: 1
};
var BasicOptions = {
  isCaseSensitive: false,
  includeScore: false,
  keys: [],
  shouldSort: true,
  sortFn: (a, b) => a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1
};
var FuzzyOptions = {
  location: 0,
  threshold: 0.6,
  distance: 100
};
var AdvancedOptions = {
  useExtendedSearch: false,
  getFn: get,
  ignoreLocation: false,
  ignoreFieldNorm: false,
  fieldNormWeight: 1
};
var Config = {
  ...BasicOptions,
  ...MatchOptions,
  ...FuzzyOptions,
  ...AdvancedOptions
};
var SPACE = /[^ ]+/g;
function norm(weight = 1, mantissa = 3) {
  const cache = /* @__PURE__ */ new Map();
  const m = Math.pow(10, mantissa);
  return {
    get(value) {
      const numTokens = value.match(SPACE).length;
      if (cache.has(numTokens)) {
        return cache.get(numTokens);
      }
      const norm2 = 1 / Math.pow(numTokens, 0.5 * weight);
      const n = parseFloat(Math.round(norm2 * m) / m);
      cache.set(numTokens, n);
      return n;
    },
    clear() {
      cache.clear();
    }
  };
}
var FuseIndex = class {
  constructor({
    getFn = Config.getFn,
    fieldNormWeight = Config.fieldNormWeight
  } = {}) {
    this.norm = norm(fieldNormWeight, 3);
    this.getFn = getFn;
    this.isCreated = false;
    this.setIndexRecords();
  }
  setSources(docs = []) {
    this.docs = docs;
  }
  setIndexRecords(records = []) {
    this.records = records;
  }
  setKeys(keys = []) {
    this.keys = keys;
    this._keysMap = {};
    keys.forEach((key, idx) => {
      this._keysMap[key.id] = idx;
    });
  }
  create() {
    if (this.isCreated || !this.docs.length) {
      return;
    }
    this.isCreated = true;
    if (isString(this.docs[0])) {
      this.docs.forEach((doc, docIndex) => {
        this._addString(doc, docIndex);
      });
    } else {
      this.docs.forEach((doc, docIndex) => {
        this._addObject(doc, docIndex);
      });
    }
    this.norm.clear();
  }
  add(doc) {
    const idx = this.size();
    if (isString(doc)) {
      this._addString(doc, idx);
    } else {
      this._addObject(doc, idx);
    }
  }
  removeAt(idx) {
    this.records.splice(idx, 1);
    for (let i = idx, len = this.size(); i < len; i += 1) {
      this.records[i].i -= 1;
    }
  }
  getValueForItemAtKeyId(item, keyId) {
    return item[this._keysMap[keyId]];
  }
  size() {
    return this.records.length;
  }
  _addString(doc, docIndex) {
    if (!isDefined(doc) || isBlank(doc)) {
      return;
    }
    let record = {
      v: doc,
      i: docIndex,
      n: this.norm.get(doc)
    };
    this.records.push(record);
  }
  _addObject(doc, docIndex) {
    let record = { i: docIndex, $: {} };
    this.keys.forEach((key, keyIndex) => {
      let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);
      if (!isDefined(value)) {
        return;
      }
      if (isArray(value)) {
        let subRecords = [];
        const stack = [{ nestedArrIndex: -1, value }];
        while (stack.length) {
          const { nestedArrIndex, value: value2 } = stack.pop();
          if (!isDefined(value2)) {
            continue;
          }
          if (isString(value2) && !isBlank(value2)) {
            let subRecord = {
              v: value2,
              i: nestedArrIndex,
              n: this.norm.get(value2)
            };
            subRecords.push(subRecord);
          } else if (isArray(value2)) {
            value2.forEach((item, k) => {
              stack.push({
                nestedArrIndex: k,
                value: item
              });
            });
          } else
            ;
        }
        record.$[keyIndex] = subRecords;
      } else if (isString(value) && !isBlank(value)) {
        let subRecord = {
          v: value,
          n: this.norm.get(value)
        };
        record.$[keyIndex] = subRecord;
      }
    });
    this.records.push(record);
  }
  toJSON() {
    return {
      keys: this.keys,
      records: this.records
    };
  }
};
function createIndex(keys, docs, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys.map(createKey));
  myIndex.setSources(docs);
  myIndex.create();
  return myIndex;
}
function parseIndex(data, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const { keys, records } = data;
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys);
  myIndex.setIndexRecords(records);
  return myIndex;
}
function computeScore$1(pattern, {
  errors = 0,
  currentLocation = 0,
  expectedLocation = 0,
  distance = Config.distance,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  const accuracy = errors / pattern.length;
  if (ignoreLocation) {
    return accuracy;
  }
  const proximity = Math.abs(expectedLocation - currentLocation);
  if (!distance) {
    return proximity ? 1 : accuracy;
  }
  return accuracy + proximity / distance;
}
function convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {
  let indices = [];
  let start = -1;
  let end = -1;
  let i = 0;
  for (let len = matchmask.length; i < len; i += 1) {
    let match = matchmask[i];
    if (match && start === -1) {
      start = i;
    } else if (!match && start !== -1) {
      end = i - 1;
      if (end - start + 1 >= minMatchCharLength) {
        indices.push([start, end]);
      }
      start = -1;
    }
  }
  if (matchmask[i - 1] && i - start >= minMatchCharLength) {
    indices.push([start, i - 1]);
  }
  return indices;
}
var MAX_BITS = 32;
function search(text, pattern, patternAlphabet, {
  location = Config.location,
  distance = Config.distance,
  threshold = Config.threshold,
  findAllMatches = Config.findAllMatches,
  minMatchCharLength = Config.minMatchCharLength,
  includeMatches = Config.includeMatches,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  if (pattern.length > MAX_BITS) {
    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
  }
  const patternLen = pattern.length;
  const textLen = text.length;
  const expectedLocation = Math.max(0, Math.min(location, textLen));
  let currentThreshold = threshold;
  let bestLocation = expectedLocation;
  const computeMatches = minMatchCharLength > 1 || includeMatches;
  const matchMask = computeMatches ? Array(textLen) : [];
  let index2;
  while ((index2 = text.indexOf(pattern, bestLocation)) > -1) {
    let score = computeScore$1(pattern, {
      currentLocation: index2,
      expectedLocation,
      distance,
      ignoreLocation
    });
    currentThreshold = Math.min(score, currentThreshold);
    bestLocation = index2 + patternLen;
    if (computeMatches) {
      let i = 0;
      while (i < patternLen) {
        matchMask[index2 + i] = 1;
        i += 1;
      }
    }
  }
  bestLocation = -1;
  let lastBitArr = [];
  let finalScore = 1;
  let binMax = patternLen + textLen;
  const mask = 1 << patternLen - 1;
  for (let i = 0; i < patternLen; i += 1) {
    let binMin = 0;
    let binMid = binMax;
    while (binMin < binMid) {
      const score2 = computeScore$1(pattern, {
        errors: i,
        currentLocation: expectedLocation + binMid,
        expectedLocation,
        distance,
        ignoreLocation
      });
      if (score2 <= currentThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }
      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    }
    binMax = binMid;
    let start = Math.max(1, expectedLocation - binMid + 1);
    let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
    let bitArr = Array(finish + 2);
    bitArr[finish + 1] = (1 << i) - 1;
    for (let j = finish; j >= start; j -= 1) {
      let currentLocation = j - 1;
      let charMatch = patternAlphabet[text.charAt(currentLocation)];
      if (computeMatches) {
        matchMask[currentLocation] = +!!charMatch;
      }
      bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;
      if (i) {
        bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
      }
      if (bitArr[j] & mask) {
        finalScore = computeScore$1(pattern, {
          errors: i,
          currentLocation,
          expectedLocation,
          distance,
          ignoreLocation
        });
        if (finalScore <= currentThreshold) {
          currentThreshold = finalScore;
          bestLocation = currentLocation;
          if (bestLocation <= expectedLocation) {
            break;
          }
          start = Math.max(1, 2 * expectedLocation - bestLocation);
        }
      }
    }
    const score = computeScore$1(pattern, {
      errors: i + 1,
      currentLocation: expectedLocation,
      expectedLocation,
      distance,
      ignoreLocation
    });
    if (score > currentThreshold) {
      break;
    }
    lastBitArr = bitArr;
  }
  const result = {
    isMatch: bestLocation >= 0,
    score: Math.max(1e-3, finalScore)
  };
  if (computeMatches) {
    const indices = convertMaskToIndices(matchMask, minMatchCharLength);
    if (!indices.length) {
      result.isMatch = false;
    } else if (includeMatches) {
      result.indices = indices;
    }
  }
  return result;
}
function createPatternAlphabet(pattern) {
  let mask = {};
  for (let i = 0, len = pattern.length; i < len; i += 1) {
    const char = pattern.charAt(i);
    mask[char] = (mask[char] || 0) | 1 << len - i - 1;
  }
  return mask;
}
var BitapSearch = class {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    this.options = {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.chunks = [];
    if (!this.pattern.length) {
      return;
    }
    const addChunk = (pattern2, startIndex) => {
      this.chunks.push({
        pattern: pattern2,
        alphabet: createPatternAlphabet(pattern2),
        startIndex
      });
    };
    const len = this.pattern.length;
    if (len > MAX_BITS) {
      let i = 0;
      const remainder = len % MAX_BITS;
      const end = len - remainder;
      while (i < end) {
        addChunk(this.pattern.substr(i, MAX_BITS), i);
        i += MAX_BITS;
      }
      if (remainder) {
        const startIndex = len - MAX_BITS;
        addChunk(this.pattern.substr(startIndex), startIndex);
      }
    } else {
      addChunk(this.pattern, 0);
    }
  }
  searchIn(text) {
    const { isCaseSensitive, includeMatches } = this.options;
    if (!isCaseSensitive) {
      text = text.toLowerCase();
    }
    if (this.pattern === text) {
      let result2 = {
        isMatch: true,
        score: 0
      };
      if (includeMatches) {
        result2.indices = [[0, text.length - 1]];
      }
      return result2;
    }
    const {
      location,
      distance,
      threshold,
      findAllMatches,
      minMatchCharLength,
      ignoreLocation
    } = this.options;
    let allIndices = [];
    let totalScore = 0;
    let hasMatches = false;
    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
      const { isMatch, score, indices } = search(text, pattern, alphabet, {
        location: location + startIndex,
        distance,
        threshold,
        findAllMatches,
        minMatchCharLength,
        includeMatches,
        ignoreLocation
      });
      if (isMatch) {
        hasMatches = true;
      }
      totalScore += score;
      if (isMatch && indices) {
        allIndices = [...allIndices, ...indices];
      }
    });
    let result = {
      isMatch: hasMatches,
      score: hasMatches ? totalScore / this.chunks.length : 1
    };
    if (hasMatches && includeMatches) {
      result.indices = allIndices;
    }
    return result;
  }
};
var BaseMatch = class {
  constructor(pattern) {
    this.pattern = pattern;
  }
  static isMultiMatch(pattern) {
    return getMatch(pattern, this.multiRegex);
  }
  static isSingleMatch(pattern) {
    return getMatch(pattern, this.singleRegex);
  }
  search() {
  }
};
function getMatch(pattern, exp) {
  const matches = pattern.match(exp);
  return matches ? matches[1] : null;
}
var ExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "exact";
  }
  static get multiRegex() {
    return /^="(.*)"$/;
  }
  static get singleRegex() {
    return /^=(.*)$/;
  }
  search(text) {
    const isMatch = text === this.pattern;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
};
var InverseExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"$/;
  }
  static get singleRegex() {
    return /^!(.*)$/;
  }
  search(text) {
    const index2 = text.indexOf(this.pattern);
    const isMatch = index2 === -1;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
};
var PrefixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "prefix-exact";
  }
  static get multiRegex() {
    return /^\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^\^(.*)$/;
  }
  search(text) {
    const isMatch = text.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
};
var InversePrefixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-prefix-exact";
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^!\^(.*)$/;
  }
  search(text) {
    const isMatch = !text.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
};
var SuffixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "suffix-exact";
  }
  static get multiRegex() {
    return /^"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^(.*)\$$/;
  }
  search(text) {
    const isMatch = text.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [text.length - this.pattern.length, text.length - 1]
    };
  }
};
var InverseSuffixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-suffix-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^!(.*)\$$/;
  }
  search(text) {
    const isMatch = !text.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
};
var FuzzyMatch = class extends BaseMatch {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    super(pattern);
    this._bitapSearch = new BitapSearch(pattern, {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    });
  }
  static get type() {
    return "fuzzy";
  }
  static get multiRegex() {
    return /^"(.*)"$/;
  }
  static get singleRegex() {
    return /^(.*)$/;
  }
  search(text) {
    return this._bitapSearch.searchIn(text);
  }
};
var IncludeMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "include";
  }
  static get multiRegex() {
    return /^'"(.*)"$/;
  }
  static get singleRegex() {
    return /^'(.*)$/;
  }
  search(text) {
    let location = 0;
    let index2;
    const indices = [];
    const patternLen = this.pattern.length;
    while ((index2 = text.indexOf(this.pattern, location)) > -1) {
      location = index2 + patternLen;
      indices.push([index2, location - 1]);
    }
    const isMatch = !!indices.length;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices
    };
  }
};
var searchers = [
  ExactMatch,
  IncludeMatch,
  PrefixExactMatch,
  InversePrefixExactMatch,
  InverseSuffixExactMatch,
  SuffixExactMatch,
  InverseExactMatch,
  FuzzyMatch
];
var searchersLen = searchers.length;
var SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
var OR_TOKEN = "|";
function parseQuery(pattern, options = {}) {
  return pattern.split(OR_TOKEN).map((item) => {
    let query = item.trim().split(SPACE_RE).filter((item2) => item2 && !!item2.trim());
    let results = [];
    for (let i = 0, len = query.length; i < len; i += 1) {
      const queryItem = query[i];
      let found = false;
      let idx = -1;
      while (!found && ++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isMultiMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          found = true;
        }
      }
      if (found) {
        continue;
      }
      idx = -1;
      while (++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isSingleMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          break;
        }
      }
    }
    return results;
  });
}
var MultiMatchSet = /* @__PURE__ */ new Set([FuzzyMatch.type, IncludeMatch.type]);
var ExtendedSearch = class {
  constructor(pattern, {
    isCaseSensitive = Config.isCaseSensitive,
    includeMatches = Config.includeMatches,
    minMatchCharLength = Config.minMatchCharLength,
    ignoreLocation = Config.ignoreLocation,
    findAllMatches = Config.findAllMatches,
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance
  } = {}) {
    this.query = null;
    this.options = {
      isCaseSensitive,
      includeMatches,
      minMatchCharLength,
      findAllMatches,
      ignoreLocation,
      location,
      threshold,
      distance
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.query = parseQuery(this.pattern, this.options);
  }
  static condition(_, options) {
    return options.useExtendedSearch;
  }
  searchIn(text) {
    const query = this.query;
    if (!query) {
      return {
        isMatch: false,
        score: 1
      };
    }
    const { includeMatches, isCaseSensitive } = this.options;
    text = isCaseSensitive ? text : text.toLowerCase();
    let numMatches = 0;
    let allIndices = [];
    let totalScore = 0;
    for (let i = 0, qLen = query.length; i < qLen; i += 1) {
      const searchers2 = query[i];
      allIndices.length = 0;
      numMatches = 0;
      for (let j = 0, pLen = searchers2.length; j < pLen; j += 1) {
        const searcher = searchers2[j];
        const { isMatch, indices, score } = searcher.search(text);
        if (isMatch) {
          numMatches += 1;
          totalScore += score;
          if (includeMatches) {
            const type = searcher.constructor.type;
            if (MultiMatchSet.has(type)) {
              allIndices = [...allIndices, ...indices];
            } else {
              allIndices.push(indices);
            }
          }
        } else {
          totalScore = 0;
          numMatches = 0;
          allIndices.length = 0;
          break;
        }
      }
      if (numMatches) {
        let result = {
          isMatch: true,
          score: totalScore / numMatches
        };
        if (includeMatches) {
          result.indices = allIndices;
        }
        return result;
      }
    }
    return {
      isMatch: false,
      score: 1
    };
  }
};
var registeredSearchers = [];
function register(...args) {
  registeredSearchers.push(...args);
}
function createSearcher(pattern, options) {
  for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {
    let searcherClass = registeredSearchers[i];
    if (searcherClass.condition(pattern, options)) {
      return new searcherClass(pattern, options);
    }
  }
  return new BitapSearch(pattern, options);
}
var LogicalOperator = {
  AND: "$and",
  OR: "$or"
};
var KeyType = {
  PATH: "$path",
  PATTERN: "$val"
};
var isExpression = (query) => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
var isPath = (query) => !!query[KeyType.PATH];
var isLeaf = (query) => !isArray(query) && isObject(query) && !isExpression(query);
var convertToExplicit = (query) => ({
  [LogicalOperator.AND]: Object.keys(query).map((key) => ({
    [key]: query[key]
  }))
});
function parse(query, options, { auto = true } = {}) {
  const next = (query2) => {
    let keys = Object.keys(query2);
    const isQueryPath = isPath(query2);
    if (!isQueryPath && keys.length > 1 && !isExpression(query2)) {
      return next(convertToExplicit(query2));
    }
    if (isLeaf(query2)) {
      const key = isQueryPath ? query2[KeyType.PATH] : keys[0];
      const pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key];
      if (!isString(pattern)) {
        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
      }
      const obj = {
        keyId: createKeyId(key),
        pattern
      };
      if (auto) {
        obj.searcher = createSearcher(pattern, options);
      }
      return obj;
    }
    let node = {
      children: [],
      operator: keys[0]
    };
    keys.forEach((key) => {
      const value = query2[key];
      if (isArray(value)) {
        value.forEach((item) => {
          node.children.push(next(item));
        });
      }
    });
    return node;
  };
  if (!isExpression(query)) {
    query = convertToExplicit(query);
  }
  return next(query);
}
function computeScore(results, { ignoreFieldNorm = Config.ignoreFieldNorm }) {
  results.forEach((result) => {
    let totalScore = 1;
    result.matches.forEach(({ key, norm: norm2, score }) => {
      const weight = key ? key.weight : null;
      totalScore *= Math.pow(
        score === 0 && weight ? Number.EPSILON : score,
        (weight || 1) * (ignoreFieldNorm ? 1 : norm2)
      );
    });
    result.score = totalScore;
  });
}
function transformMatches(result, data) {
  const matches = result.matches;
  data.matches = [];
  if (!isDefined(matches)) {
    return;
  }
  matches.forEach((match) => {
    if (!isDefined(match.indices) || !match.indices.length) {
      return;
    }
    const { indices, value } = match;
    let obj = {
      indices,
      value
    };
    if (match.key) {
      obj.key = match.key.src;
    }
    if (match.idx > -1) {
      obj.refIndex = match.idx;
    }
    data.matches.push(obj);
  });
}
function transformScore(result, data) {
  data.score = result.score;
}
function format(results, docs, {
  includeMatches = Config.includeMatches,
  includeScore = Config.includeScore
} = {}) {
  const transformers = [];
  if (includeMatches)
    transformers.push(transformMatches);
  if (includeScore)
    transformers.push(transformScore);
  return results.map((result) => {
    const { idx } = result;
    const data = {
      item: docs[idx],
      refIndex: idx
    };
    if (transformers.length) {
      transformers.forEach((transformer) => {
        transformer(result, data);
      });
    }
    return data;
  });
}
var Fuse = class {
  constructor(docs, options = {}, index2) {
    this.options = { ...Config, ...options };
    if (this.options.useExtendedSearch && false) {
      throw new Error(EXTENDED_SEARCH_UNAVAILABLE);
    }
    this._keyStore = new KeyStore(this.options.keys);
    this.setCollection(docs, index2);
  }
  setCollection(docs, index2) {
    this._docs = docs;
    if (index2 && !(index2 instanceof FuseIndex)) {
      throw new Error(INCORRECT_INDEX_TYPE);
    }
    this._myIndex = index2 || createIndex(this.options.keys, this._docs, {
      getFn: this.options.getFn,
      fieldNormWeight: this.options.fieldNormWeight
    });
  }
  add(doc) {
    if (!isDefined(doc)) {
      return;
    }
    this._docs.push(doc);
    this._myIndex.add(doc);
  }
  remove(predicate = () => false) {
    const results = [];
    for (let i = 0, len = this._docs.length; i < len; i += 1) {
      const doc = this._docs[i];
      if (predicate(doc, i)) {
        this.removeAt(i);
        i -= 1;
        len -= 1;
        results.push(doc);
      }
    }
    return results;
  }
  removeAt(idx) {
    this._docs.splice(idx, 1);
    this._myIndex.removeAt(idx);
  }
  getIndex() {
    return this._myIndex;
  }
  search(query, { limit = -1 } = {}) {
    const {
      includeMatches,
      includeScore,
      shouldSort,
      sortFn,
      ignoreFieldNorm
    } = this.options;
    let results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
    computeScore(results, { ignoreFieldNorm });
    if (shouldSort) {
      results.sort(sortFn);
    }
    if (isNumber(limit) && limit > -1) {
      results = results.slice(0, limit);
    }
    return format(results, this._docs, {
      includeMatches,
      includeScore
    });
  }
  _searchStringList(query) {
    const searcher = createSearcher(query, this.options);
    const { records } = this._myIndex;
    const results = [];
    records.forEach(({ v: text, i: idx, n: norm2 }) => {
      if (!isDefined(text)) {
        return;
      }
      const { isMatch, score, indices } = searcher.searchIn(text);
      if (isMatch) {
        results.push({
          item: text,
          idx,
          matches: [{ score, value: text, norm: norm2, indices }]
        });
      }
    });
    return results;
  }
  _searchLogical(query) {
    const expression = parse(query, this.options);
    const evaluate2 = (node, item, idx) => {
      if (!node.children) {
        const { keyId, searcher } = node;
        const matches = this._findMatches({
          key: this._keyStore.get(keyId),
          value: this._myIndex.getValueForItemAtKeyId(item, keyId),
          searcher
        });
        if (matches && matches.length) {
          return [
            {
              idx,
              item,
              matches
            }
          ];
        }
        return [];
      }
      const res = [];
      for (let i = 0, len = node.children.length; i < len; i += 1) {
        const child = node.children[i];
        const result = evaluate2(child, item, idx);
        if (result.length) {
          res.push(...result);
        } else if (node.operator === LogicalOperator.AND) {
          return [];
        }
      }
      return res;
    };
    const records = this._myIndex.records;
    const resultMap = {};
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (isDefined(item)) {
        let expResults = evaluate2(expression, item, idx);
        if (expResults.length) {
          if (!resultMap[idx]) {
            resultMap[idx] = { idx, item, matches: [] };
            results.push(resultMap[idx]);
          }
          expResults.forEach(({ matches }) => {
            resultMap[idx].matches.push(...matches);
          });
        }
      }
    });
    return results;
  }
  _searchObjectList(query) {
    const searcher = createSearcher(query, this.options);
    const { keys, records } = this._myIndex;
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (!isDefined(item)) {
        return;
      }
      let matches = [];
      keys.forEach((key, keyIndex) => {
        matches.push(
          ...this._findMatches({
            key,
            value: item[keyIndex],
            searcher
          })
        );
      });
      if (matches.length) {
        results.push({
          idx,
          item,
          matches
        });
      }
    });
    return results;
  }
  _findMatches({ key, value, searcher }) {
    if (!isDefined(value)) {
      return [];
    }
    let matches = [];
    if (isArray(value)) {
      value.forEach(({ v: text, i: idx, n: norm2 }) => {
        if (!isDefined(text)) {
          return;
        }
        const { isMatch, score, indices } = searcher.searchIn(text);
        if (isMatch) {
          matches.push({
            score,
            key,
            value: text,
            idx,
            norm: norm2,
            indices
          });
        }
      });
    } else {
      const { v: text, n: norm2 } = value;
      const { isMatch, score, indices } = searcher.searchIn(text);
      if (isMatch) {
        matches.push({ score, key, value: text, norm: norm2, indices });
      }
    }
    return matches;
  }
};
Fuse.version = "6.6.2";
Fuse.createIndex = createIndex;
Fuse.parseIndex = parseIndex;
Fuse.config = Config;
{
  Fuse.parseQuery = parse;
}
{
  register(ExtendedSearch);
}

// node_modules/@radix-ui/react-dropdown-menu/dist/index.mjs
init_shim();
var import_react13 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-menu/dist/index.mjs
init_shim();
var import_react12 = __toESM(require_react(), 1);
var $6cc32821e9371a1c$var$SELECTION_KEYS = [
  "Enter",
  " "
];
var $6cc32821e9371a1c$var$FIRST_KEYS = [
  "ArrowDown",
  "PageUp",
  "Home"
];
var $6cc32821e9371a1c$var$LAST_KEYS = [
  "ArrowUp",
  "PageDown",
  "End"
];
var $6cc32821e9371a1c$var$FIRST_LAST_KEYS = [
  ...$6cc32821e9371a1c$var$FIRST_KEYS,
  ...$6cc32821e9371a1c$var$LAST_KEYS
];
var $6cc32821e9371a1c$var$SUB_OPEN_KEYS = {
  ltr: [
    ...$6cc32821e9371a1c$var$SELECTION_KEYS,
    "ArrowRight"
  ],
  rtl: [
    ...$6cc32821e9371a1c$var$SELECTION_KEYS,
    "ArrowLeft"
  ]
};
var $6cc32821e9371a1c$var$SUB_CLOSE_KEYS = {
  ltr: [
    "ArrowLeft"
  ],
  rtl: [
    "ArrowRight"
  ]
};
var $6cc32821e9371a1c$var$MENU_NAME = "Menu";
var [$6cc32821e9371a1c$var$Collection, $6cc32821e9371a1c$var$useCollection, $6cc32821e9371a1c$var$createCollectionScope] = $e02a7d9cb1dc128c$export$c74125a8e3af6bb2($6cc32821e9371a1c$var$MENU_NAME);
var [$6cc32821e9371a1c$var$createMenuContext, $6cc32821e9371a1c$export$4027731b685e72eb] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($6cc32821e9371a1c$var$MENU_NAME, [
  $6cc32821e9371a1c$var$createCollectionScope,
  $cf1ac5d9fe0e8206$export$722aac194ae923,
  $d7bdfb9eb0fdf311$export$c7109489551a4f4
]);
var $6cc32821e9371a1c$var$usePopperScope = $cf1ac5d9fe0e8206$export$722aac194ae923();
var $6cc32821e9371a1c$var$useRovingFocusGroupScope = $d7bdfb9eb0fdf311$export$c7109489551a4f4();
var [$6cc32821e9371a1c$var$MenuProvider, $6cc32821e9371a1c$var$useMenuContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$MENU_NAME);
var [$6cc32821e9371a1c$var$MenuRootProvider, $6cc32821e9371a1c$var$useMenuRootContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$MENU_NAME);
var $6cc32821e9371a1c$export$d9b273488cd8ce6f = (props) => {
  const { __scopeMenu, open = false, children, dir, onOpenChange, modal = true } = props;
  const popperScope = $6cc32821e9371a1c$var$usePopperScope(__scopeMenu);
  const [content, setContent] = (0, import_react12.useState)(null);
  const isUsingKeyboardRef = (0, import_react12.useRef)(false);
  const handleOpenChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onOpenChange);
  const direction = $f631663db3294ace$export$b39126d51d94e6f3(dir);
  (0, import_react12.useEffect)(() => {
    const handleKeyDown = () => {
      isUsingKeyboardRef.current = true;
      document.addEventListener("pointerdown", handlePointer, {
        capture: true,
        once: true
      });
      document.addEventListener("pointermove", handlePointer, {
        capture: true,
        once: true
      });
    };
    const handlePointer = () => isUsingKeyboardRef.current = false;
    document.addEventListener("keydown", handleKeyDown, {
      capture: true
    });
    return () => {
      document.removeEventListener("keydown", handleKeyDown, {
        capture: true
      });
      document.removeEventListener("pointerdown", handlePointer, {
        capture: true
      });
      document.removeEventListener("pointermove", handlePointer, {
        capture: true
      });
    };
  }, []);
  return (0, import_react12.createElement)($cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9, popperScope, (0, import_react12.createElement)($6cc32821e9371a1c$var$MenuProvider, {
    scope: __scopeMenu,
    open,
    onOpenChange: handleOpenChange,
    content,
    onContentChange: setContent
  }, (0, import_react12.createElement)($6cc32821e9371a1c$var$MenuRootProvider, {
    scope: __scopeMenu,
    onClose: (0, import_react12.useCallback)(
      () => handleOpenChange(false),
      [
        handleOpenChange
      ]
    ),
    isUsingKeyboardRef,
    dir: direction,
    modal
  }, children)));
};
Object.assign($6cc32821e9371a1c$export$d9b273488cd8ce6f, {
  displayName: $6cc32821e9371a1c$var$MENU_NAME
});
var $6cc32821e9371a1c$var$ANCHOR_NAME = "MenuAnchor";
var $6cc32821e9371a1c$export$9fa5ebd18bee4d43 = (0, import_react12.forwardRef)((props, forwardedRef) => {
  const { __scopeMenu, ...anchorProps } = props;
  const popperScope = $6cc32821e9371a1c$var$usePopperScope(__scopeMenu);
  return (0, import_react12.createElement)($cf1ac5d9fe0e8206$export$b688253958b8dfe7, _extends({}, popperScope, anchorProps, {
    ref: forwardedRef
  }));
});
Object.assign($6cc32821e9371a1c$export$9fa5ebd18bee4d43, {
  displayName: $6cc32821e9371a1c$var$ANCHOR_NAME
});
var $6cc32821e9371a1c$var$PORTAL_NAME = "MenuPortal";
var [$6cc32821e9371a1c$var$PortalProvider, $6cc32821e9371a1c$var$usePortalContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$PORTAL_NAME, {
  forceMount: void 0
});
var $6cc32821e9371a1c$export$793392f970497feb = (props) => {
  const { __scopeMenu, forceMount, children, container } = props;
  const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$PORTAL_NAME, __scopeMenu);
  return (0, import_react12.createElement)($6cc32821e9371a1c$var$PortalProvider, {
    scope: __scopeMenu,
    forceMount
  }, (0, import_react12.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
    present: forceMount || context.open
  }, (0, import_react12.createElement)($f1701beae083dbae$export$602eac185826482c, {
    asChild: true,
    container
  }, children)));
};
Object.assign($6cc32821e9371a1c$export$793392f970497feb, {
  displayName: $6cc32821e9371a1c$var$PORTAL_NAME
});
var $6cc32821e9371a1c$var$CONTENT_NAME = "MenuContent";
var [$6cc32821e9371a1c$var$MenuContentProvider, $6cc32821e9371a1c$var$useMenuContentContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$CONTENT_NAME);
var $6cc32821e9371a1c$export$479f0f2f71193efe = (0, import_react12.forwardRef)((props, forwardedRef) => {
  const portalContext = $6cc32821e9371a1c$var$usePortalContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
  const { forceMount = portalContext.forceMount, ...contentProps } = props;
  const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
  const rootContext = $6cc32821e9371a1c$var$useMenuRootContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
  return (0, import_react12.createElement)($6cc32821e9371a1c$var$Collection.Provider, {
    scope: props.__scopeMenu
  }, (0, import_react12.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
    present: forceMount || context.open
  }, (0, import_react12.createElement)($6cc32821e9371a1c$var$Collection.Slot, {
    scope: props.__scopeMenu
  }, rootContext.modal ? (0, import_react12.createElement)($6cc32821e9371a1c$var$MenuRootContentModal, _extends({}, contentProps, {
    ref: forwardedRef
  })) : (0, import_react12.createElement)($6cc32821e9371a1c$var$MenuRootContentNonModal, _extends({}, contentProps, {
    ref: forwardedRef
  })))));
});
var $6cc32821e9371a1c$var$MenuRootContentModal = (0, import_react12.forwardRef)((props, forwardedRef) => {
  const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
  const ref = (0, import_react12.useRef)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
  (0, import_react12.useEffect)(() => {
    const content = ref.current;
    if (content)
      return hideOthers(content);
  }, []);
  return (0, import_react12.createElement)($6cc32821e9371a1c$var$MenuContentImpl, _extends({}, props, {
    ref: composedRefs,
    trapFocus: context.open,
    disableOutsidePointerEvents: context.open,
    disableOutsideScroll: true,
    onFocusOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      props.onFocusOutside,
      (event) => event.preventDefault(),
      {
        checkForDefaultPrevented: false
      }
    ),
    onDismiss: () => context.onOpenChange(false)
  }));
});
var $6cc32821e9371a1c$var$MenuRootContentNonModal = (0, import_react12.forwardRef)((props, forwardedRef) => {
  const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
  return (0, import_react12.createElement)($6cc32821e9371a1c$var$MenuContentImpl, _extends({}, props, {
    ref: forwardedRef,
    trapFocus: false,
    disableOutsidePointerEvents: false,
    disableOutsideScroll: false,
    onDismiss: () => context.onOpenChange(false)
  }));
});
var $6cc32821e9371a1c$var$MenuContentImpl = (0, import_react12.forwardRef)((props, forwardedRef) => {
  const { __scopeMenu, loop = false, trapFocus, onOpenAutoFocus, onCloseAutoFocus, disableOutsidePointerEvents, onEntryFocus, onEscapeKeyDown, onPointerDownOutside, onFocusOutside, onInteractOutside, onDismiss, disableOutsideScroll, ...contentProps } = props;
  const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$CONTENT_NAME, __scopeMenu);
  const rootContext = $6cc32821e9371a1c$var$useMenuRootContext($6cc32821e9371a1c$var$CONTENT_NAME, __scopeMenu);
  const popperScope = $6cc32821e9371a1c$var$usePopperScope(__scopeMenu);
  const rovingFocusGroupScope = $6cc32821e9371a1c$var$useRovingFocusGroupScope(__scopeMenu);
  const getItems = $6cc32821e9371a1c$var$useCollection(__scopeMenu);
  const [currentItemId, setCurrentItemId] = (0, import_react12.useState)(null);
  const contentRef = (0, import_react12.useRef)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, contentRef, context.onContentChange);
  const timerRef = (0, import_react12.useRef)(0);
  const searchRef = (0, import_react12.useRef)("");
  const pointerGraceTimerRef = (0, import_react12.useRef)(0);
  const pointerGraceIntentRef = (0, import_react12.useRef)(null);
  const pointerDirRef = (0, import_react12.useRef)("right");
  const lastPointerXRef = (0, import_react12.useRef)(0);
  const ScrollLockWrapper = disableOutsideScroll ? Combination_default : import_react12.Fragment;
  const scrollLockWrapperProps = disableOutsideScroll ? {
    as: $5e63c961fc1ce211$export$8c6ed5c666ac1360,
    allowPinchZoom: true
  } : void 0;
  const handleTypeaheadSearch = (key) => {
    var _items$find, _items$find2;
    const search2 = searchRef.current + key;
    const items = getItems().filter(
      (item) => !item.disabled
    );
    const currentItem = document.activeElement;
    const currentMatch = (_items$find = items.find(
      (item) => item.ref.current === currentItem
    )) === null || _items$find === void 0 ? void 0 : _items$find.textValue;
    const values = items.map(
      (item) => item.textValue
    );
    const nextMatch = $6cc32821e9371a1c$var$getNextMatch(values, search2, currentMatch);
    const newItem = (_items$find2 = items.find(
      (item) => item.textValue === nextMatch
    )) === null || _items$find2 === void 0 ? void 0 : _items$find2.ref.current;
    (function updateSearch(value) {
      searchRef.current = value;
      window.clearTimeout(timerRef.current);
      if (value !== "")
        timerRef.current = window.setTimeout(
          () => updateSearch(""),
          1e3
        );
    })(search2);
    if (newItem)
      setTimeout(
        () => newItem.focus()
      );
  };
  (0, import_react12.useEffect)(() => {
    return () => window.clearTimeout(timerRef.current);
  }, []);
  $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c();
  const isPointerMovingToSubmenu = (0, import_react12.useCallback)((event) => {
    var _pointerGraceIntentRe, _pointerGraceIntentRe2;
    const isMovingTowards = pointerDirRef.current === ((_pointerGraceIntentRe = pointerGraceIntentRef.current) === null || _pointerGraceIntentRe === void 0 ? void 0 : _pointerGraceIntentRe.side);
    return isMovingTowards && $6cc32821e9371a1c$var$isPointerInGraceArea(event, (_pointerGraceIntentRe2 = pointerGraceIntentRef.current) === null || _pointerGraceIntentRe2 === void 0 ? void 0 : _pointerGraceIntentRe2.area);
  }, []);
  return (0, import_react12.createElement)($6cc32821e9371a1c$var$MenuContentProvider, {
    scope: __scopeMenu,
    searchRef,
    onItemEnter: (0, import_react12.useCallback)((event) => {
      if (isPointerMovingToSubmenu(event))
        event.preventDefault();
    }, [
      isPointerMovingToSubmenu
    ]),
    onItemLeave: (0, import_react12.useCallback)((event) => {
      var _contentRef$current;
      if (isPointerMovingToSubmenu(event))
        return;
      (_contentRef$current = contentRef.current) === null || _contentRef$current === void 0 || _contentRef$current.focus();
      setCurrentItemId(null);
    }, [
      isPointerMovingToSubmenu
    ]),
    onTriggerLeave: (0, import_react12.useCallback)((event) => {
      if (isPointerMovingToSubmenu(event))
        event.preventDefault();
    }, [
      isPointerMovingToSubmenu
    ]),
    pointerGraceTimerRef,
    onPointerGraceIntentChange: (0, import_react12.useCallback)((intent) => {
      pointerGraceIntentRef.current = intent;
    }, [])
  }, (0, import_react12.createElement)(ScrollLockWrapper, scrollLockWrapperProps, (0, import_react12.createElement)($d3863c46a17e8a28$export$20e40289641fbbb6, {
    asChild: true,
    trapped: trapFocus,
    onMountAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(onOpenAutoFocus, (event) => {
      var _contentRef$current2;
      event.preventDefault();
      (_contentRef$current2 = contentRef.current) === null || _contentRef$current2 === void 0 || _contentRef$current2.focus();
    }),
    onUnmountAutoFocus: onCloseAutoFocus
  }, (0, import_react12.createElement)($5cb92bef7577960e$export$177fb62ff3ec1f22, {
    asChild: true,
    disableOutsidePointerEvents,
    onEscapeKeyDown,
    onPointerDownOutside,
    onFocusOutside,
    onInteractOutside,
    onDismiss
  }, (0, import_react12.createElement)($d7bdfb9eb0fdf311$export$be92b6f5f03c0fe9, _extends({
    asChild: true
  }, rovingFocusGroupScope, {
    dir: rootContext.dir,
    orientation: "vertical",
    loop,
    currentTabStopId: currentItemId,
    onCurrentTabStopIdChange: setCurrentItemId,
    onEntryFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(onEntryFocus, (event) => {
      if (!rootContext.isUsingKeyboardRef.current)
        event.preventDefault();
    })
  }), (0, import_react12.createElement)($cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2, _extends({
    role: "menu",
    "aria-orientation": "vertical",
    "data-state": $6cc32821e9371a1c$var$getOpenState(context.open),
    "data-radix-menu-content": "",
    dir: rootContext.dir
  }, popperScope, contentProps, {
    ref: composedRefs,
    style: {
      outline: "none",
      ...contentProps.style
    },
    onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(contentProps.onKeyDown, (event) => {
      const target = event.target;
      const isKeyDownInside = target.closest("[data-radix-menu-content]") === event.currentTarget;
      const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
      const isCharacterKey = event.key.length === 1;
      if (isKeyDownInside) {
        if (event.key === "Tab")
          event.preventDefault();
        if (!isModifierKey && isCharacterKey)
          handleTypeaheadSearch(event.key);
      }
      const content = contentRef.current;
      if (event.target !== content)
        return;
      if (!$6cc32821e9371a1c$var$FIRST_LAST_KEYS.includes(event.key))
        return;
      event.preventDefault();
      const items = getItems().filter(
        (item) => !item.disabled
      );
      const candidateNodes = items.map(
        (item) => item.ref.current
      );
      if ($6cc32821e9371a1c$var$LAST_KEYS.includes(event.key))
        candidateNodes.reverse();
      $6cc32821e9371a1c$var$focusFirst(candidateNodes);
    }),
    onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onBlur, (event) => {
      if (!event.currentTarget.contains(event.target)) {
        window.clearTimeout(timerRef.current);
        searchRef.current = "";
      }
    }),
    onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerMove, $6cc32821e9371a1c$var$whenMouse((event) => {
      const target = event.target;
      const pointerXHasChanged = lastPointerXRef.current !== event.clientX;
      if (event.currentTarget.contains(target) && pointerXHasChanged) {
        const newDir = event.clientX > lastPointerXRef.current ? "right" : "left";
        pointerDirRef.current = newDir;
        lastPointerXRef.current = event.clientX;
      }
    }))
  })))))));
});
Object.assign($6cc32821e9371a1c$export$479f0f2f71193efe, {
  displayName: $6cc32821e9371a1c$var$CONTENT_NAME
});
var $6cc32821e9371a1c$var$GROUP_NAME = "MenuGroup";
var $6cc32821e9371a1c$export$22a631d1f72787bb = (0, import_react12.forwardRef)((props, forwardedRef) => {
  const { __scopeMenu, ...groupProps } = props;
  return (0, import_react12.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
    role: "group"
  }, groupProps, {
    ref: forwardedRef
  }));
});
Object.assign($6cc32821e9371a1c$export$22a631d1f72787bb, {
  displayName: $6cc32821e9371a1c$var$GROUP_NAME
});
var $6cc32821e9371a1c$var$LABEL_NAME = "MenuLabel";
var $6cc32821e9371a1c$export$dd37bec0e8a99143 = (0, import_react12.forwardRef)((props, forwardedRef) => {
  const { __scopeMenu, ...labelProps } = props;
  return (0, import_react12.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, labelProps, {
    ref: forwardedRef
  }));
});
Object.assign($6cc32821e9371a1c$export$dd37bec0e8a99143, {
  displayName: $6cc32821e9371a1c$var$LABEL_NAME
});
var $6cc32821e9371a1c$var$ITEM_NAME = "MenuItem";
var $6cc32821e9371a1c$var$ITEM_SELECT = "menu.itemSelect";
var $6cc32821e9371a1c$export$2ce376c2cc3355c8 = (0, import_react12.forwardRef)((props, forwardedRef) => {
  const { disabled = false, onSelect, ...itemProps } = props;
  const ref = (0, import_react12.useRef)(null);
  const rootContext = $6cc32821e9371a1c$var$useMenuRootContext($6cc32821e9371a1c$var$ITEM_NAME, props.__scopeMenu);
  const contentContext = $6cc32821e9371a1c$var$useMenuContentContext($6cc32821e9371a1c$var$ITEM_NAME, props.__scopeMenu);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
  const isPointerDownRef = (0, import_react12.useRef)(false);
  const handleSelect = () => {
    const menuItem = ref.current;
    if (!disabled && menuItem) {
      const itemSelectEvent = new CustomEvent($6cc32821e9371a1c$var$ITEM_SELECT, {
        bubbles: true,
        cancelable: true
      });
      menuItem.addEventListener(
        $6cc32821e9371a1c$var$ITEM_SELECT,
        (event) => onSelect === null || onSelect === void 0 ? void 0 : onSelect(event),
        {
          once: true
        }
      );
      $8927f6f2acc4f386$export$6d1a0317bde7de7f(menuItem, itemSelectEvent);
      if (itemSelectEvent.defaultPrevented)
        isPointerDownRef.current = false;
      else
        rootContext.onClose();
    }
  };
  return (0, import_react12.createElement)($6cc32821e9371a1c$var$MenuItemImpl, _extends({}, itemProps, {
    ref: composedRefs,
    disabled,
    onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onClick, handleSelect),
    onPointerDown: (event) => {
      var _props$onPointerDown;
      (_props$onPointerDown = props.onPointerDown) === null || _props$onPointerDown === void 0 || _props$onPointerDown.call(props, event);
      isPointerDownRef.current = true;
    },
    onPointerUp: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerUp, (event) => {
      var _event$currentTarget;
      if (!isPointerDownRef.current)
        (_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 || _event$currentTarget.click();
    }),
    onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
      const isTypingAhead = contentContext.searchRef.current !== "";
      if (disabled || isTypingAhead && event.key === " ")
        return;
      if ($6cc32821e9371a1c$var$SELECTION_KEYS.includes(event.key)) {
        event.currentTarget.click();
        event.preventDefault();
      }
    })
  }));
});
Object.assign($6cc32821e9371a1c$export$2ce376c2cc3355c8, {
  displayName: $6cc32821e9371a1c$var$ITEM_NAME
});
var $6cc32821e9371a1c$var$MenuItemImpl = (0, import_react12.forwardRef)((props, forwardedRef) => {
  const { __scopeMenu, disabled = false, textValue, ...itemProps } = props;
  const contentContext = $6cc32821e9371a1c$var$useMenuContentContext($6cc32821e9371a1c$var$ITEM_NAME, __scopeMenu);
  const rovingFocusGroupScope = $6cc32821e9371a1c$var$useRovingFocusGroupScope(__scopeMenu);
  const ref = (0, import_react12.useRef)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
  const [isFocused, setIsFocused] = (0, import_react12.useState)(false);
  const [textContent, setTextContent] = (0, import_react12.useState)("");
  (0, import_react12.useEffect)(() => {
    const menuItem = ref.current;
    if (menuItem) {
      var _menuItem$textContent;
      setTextContent(((_menuItem$textContent = menuItem.textContent) !== null && _menuItem$textContent !== void 0 ? _menuItem$textContent : "").trim());
    }
  }, [
    itemProps.children
  ]);
  return (0, import_react12.createElement)($6cc32821e9371a1c$var$Collection.ItemSlot, {
    scope: __scopeMenu,
    disabled,
    textValue: textValue !== null && textValue !== void 0 ? textValue : textContent
  }, (0, import_react12.createElement)($d7bdfb9eb0fdf311$export$6d08773d2e66f8f2, _extends({
    asChild: true
  }, rovingFocusGroupScope, {
    focusable: !disabled
  }), (0, import_react12.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
    role: "menuitem",
    "data-highlighted": isFocused ? "" : void 0,
    "aria-disabled": disabled || void 0,
    "data-disabled": disabled ? "" : void 0
  }, itemProps, {
    ref: composedRefs,
    onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerMove, $6cc32821e9371a1c$var$whenMouse((event) => {
      if (disabled)
        contentContext.onItemLeave(event);
      else {
        contentContext.onItemEnter(event);
        if (!event.defaultPrevented) {
          const item = event.currentTarget;
          item.focus();
        }
      }
    })),
    onPointerLeave: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerLeave, $6cc32821e9371a1c$var$whenMouse(
      (event) => contentContext.onItemLeave(event)
    )),
    onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      props.onFocus,
      () => setIsFocused(true)
    ),
    onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      props.onBlur,
      () => setIsFocused(false)
    )
  }))));
});
var $6cc32821e9371a1c$var$CHECKBOX_ITEM_NAME = "MenuCheckboxItem";
var $6cc32821e9371a1c$export$f6f243521332502d = (0, import_react12.forwardRef)((props, forwardedRef) => {
  const { checked = false, onCheckedChange, ...checkboxItemProps } = props;
  return (0, import_react12.createElement)($6cc32821e9371a1c$var$ItemIndicatorProvider, {
    scope: props.__scopeMenu,
    checked
  }, (0, import_react12.createElement)($6cc32821e9371a1c$export$2ce376c2cc3355c8, _extends({
    role: "menuitemcheckbox",
    "aria-checked": $6cc32821e9371a1c$var$isIndeterminate(checked) ? "mixed" : checked
  }, checkboxItemProps, {
    ref: forwardedRef,
    "data-state": $6cc32821e9371a1c$var$getCheckedState(checked),
    onSelect: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      checkboxItemProps.onSelect,
      () => onCheckedChange === null || onCheckedChange === void 0 ? void 0 : onCheckedChange($6cc32821e9371a1c$var$isIndeterminate(checked) ? true : !checked),
      {
        checkForDefaultPrevented: false
      }
    )
  })));
});
Object.assign($6cc32821e9371a1c$export$f6f243521332502d, {
  displayName: $6cc32821e9371a1c$var$CHECKBOX_ITEM_NAME
});
var $6cc32821e9371a1c$var$RADIO_GROUP_NAME = "MenuRadioGroup";
var [$6cc32821e9371a1c$var$RadioGroupProvider, $6cc32821e9371a1c$var$useRadioGroupContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$RADIO_GROUP_NAME, {
  value: void 0,
  onValueChange: () => {
  }
});
var $6cc32821e9371a1c$export$ea2200c9eee416b3 = (0, import_react12.forwardRef)((props, forwardedRef) => {
  const { value, onValueChange, ...groupProps } = props;
  const handleValueChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onValueChange);
  return (0, import_react12.createElement)($6cc32821e9371a1c$var$RadioGroupProvider, {
    scope: props.__scopeMenu,
    value,
    onValueChange: handleValueChange
  }, (0, import_react12.createElement)($6cc32821e9371a1c$export$22a631d1f72787bb, _extends({}, groupProps, {
    ref: forwardedRef
  })));
});
Object.assign($6cc32821e9371a1c$export$ea2200c9eee416b3, {
  displayName: $6cc32821e9371a1c$var$RADIO_GROUP_NAME
});
var $6cc32821e9371a1c$var$RADIO_ITEM_NAME = "MenuRadioItem";
var $6cc32821e9371a1c$export$69bd225e9817f6d0 = (0, import_react12.forwardRef)((props, forwardedRef) => {
  const { value, ...radioItemProps } = props;
  const context = $6cc32821e9371a1c$var$useRadioGroupContext($6cc32821e9371a1c$var$RADIO_ITEM_NAME, props.__scopeMenu);
  const checked = value === context.value;
  return (0, import_react12.createElement)($6cc32821e9371a1c$var$ItemIndicatorProvider, {
    scope: props.__scopeMenu,
    checked
  }, (0, import_react12.createElement)($6cc32821e9371a1c$export$2ce376c2cc3355c8, _extends({
    role: "menuitemradio",
    "aria-checked": checked
  }, radioItemProps, {
    ref: forwardedRef,
    "data-state": $6cc32821e9371a1c$var$getCheckedState(checked),
    onSelect: $e42e1063c40fb3ef$export$b9ecd428b558ff10(radioItemProps.onSelect, () => {
      var _context$onValueChang;
      return (_context$onValueChang = context.onValueChange) === null || _context$onValueChang === void 0 ? void 0 : _context$onValueChang.call(context, value);
    }, {
      checkForDefaultPrevented: false
    })
  })));
});
Object.assign($6cc32821e9371a1c$export$69bd225e9817f6d0, {
  displayName: $6cc32821e9371a1c$var$RADIO_ITEM_NAME
});
var $6cc32821e9371a1c$var$ITEM_INDICATOR_NAME = "MenuItemIndicator";
var [$6cc32821e9371a1c$var$ItemIndicatorProvider, $6cc32821e9371a1c$var$useItemIndicatorContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$ITEM_INDICATOR_NAME, {
  checked: false
});
var $6cc32821e9371a1c$export$a2593e23056970a3 = (0, import_react12.forwardRef)((props, forwardedRef) => {
  const { __scopeMenu, forceMount, ...itemIndicatorProps } = props;
  const indicatorContext = $6cc32821e9371a1c$var$useItemIndicatorContext($6cc32821e9371a1c$var$ITEM_INDICATOR_NAME, __scopeMenu);
  return (0, import_react12.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
    present: forceMount || $6cc32821e9371a1c$var$isIndeterminate(indicatorContext.checked) || indicatorContext.checked === true
  }, (0, import_react12.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends({}, itemIndicatorProps, {
    ref: forwardedRef,
    "data-state": $6cc32821e9371a1c$var$getCheckedState(indicatorContext.checked)
  })));
});
Object.assign($6cc32821e9371a1c$export$a2593e23056970a3, {
  displayName: $6cc32821e9371a1c$var$ITEM_INDICATOR_NAME
});
var $6cc32821e9371a1c$var$SEPARATOR_NAME = "MenuSeparator";
var $6cc32821e9371a1c$export$1cec7dcdd713e220 = (0, import_react12.forwardRef)((props, forwardedRef) => {
  const { __scopeMenu, ...separatorProps } = props;
  return (0, import_react12.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
    role: "separator",
    "aria-orientation": "horizontal"
  }, separatorProps, {
    ref: forwardedRef
  }));
});
Object.assign($6cc32821e9371a1c$export$1cec7dcdd713e220, {
  displayName: $6cc32821e9371a1c$var$SEPARATOR_NAME
});
var $6cc32821e9371a1c$var$ARROW_NAME = "MenuArrow";
var $6cc32821e9371a1c$export$bcdda4773debf5fa = (0, import_react12.forwardRef)((props, forwardedRef) => {
  const { __scopeMenu, ...arrowProps } = props;
  const popperScope = $6cc32821e9371a1c$var$usePopperScope(__scopeMenu);
  return (0, import_react12.createElement)($cf1ac5d9fe0e8206$export$21b07c8f274aebd5, _extends({}, popperScope, arrowProps, {
    ref: forwardedRef
  }));
});
Object.assign($6cc32821e9371a1c$export$bcdda4773debf5fa, {
  displayName: $6cc32821e9371a1c$var$ARROW_NAME
});
var $6cc32821e9371a1c$var$SUB_NAME = "MenuSub";
var [$6cc32821e9371a1c$var$MenuSubProvider, $6cc32821e9371a1c$var$useMenuSubContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$SUB_NAME);
var $6cc32821e9371a1c$export$71bdb9d1e2909932 = (props) => {
  const { __scopeMenu, children, open = false, onOpenChange } = props;
  const parentMenuContext = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$SUB_NAME, __scopeMenu);
  const popperScope = $6cc32821e9371a1c$var$usePopperScope(__scopeMenu);
  const [trigger, setTrigger] = (0, import_react12.useState)(null);
  const [content, setContent] = (0, import_react12.useState)(null);
  const handleOpenChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onOpenChange);
  (0, import_react12.useEffect)(() => {
    if (parentMenuContext.open === false)
      handleOpenChange(false);
    return () => handleOpenChange(false);
  }, [
    parentMenuContext.open,
    handleOpenChange
  ]);
  return (0, import_react12.createElement)($cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9, popperScope, (0, import_react12.createElement)($6cc32821e9371a1c$var$MenuProvider, {
    scope: __scopeMenu,
    open,
    onOpenChange: handleOpenChange,
    content,
    onContentChange: setContent
  }, (0, import_react12.createElement)($6cc32821e9371a1c$var$MenuSubProvider, {
    scope: __scopeMenu,
    contentId: $1746a345f3d73bb7$export$f680877a34711e37(),
    triggerId: $1746a345f3d73bb7$export$f680877a34711e37(),
    trigger,
    onTriggerChange: setTrigger
  }, children)));
};
Object.assign($6cc32821e9371a1c$export$71bdb9d1e2909932, {
  displayName: $6cc32821e9371a1c$var$SUB_NAME
});
var $6cc32821e9371a1c$var$SUB_TRIGGER_NAME = "MenuSubTrigger";
var $6cc32821e9371a1c$export$5fbbb3ba7297405f = (0, import_react12.forwardRef)((props, forwardedRef) => {
  const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$SUB_TRIGGER_NAME, props.__scopeMenu);
  const rootContext = $6cc32821e9371a1c$var$useMenuRootContext($6cc32821e9371a1c$var$SUB_TRIGGER_NAME, props.__scopeMenu);
  const subContext = $6cc32821e9371a1c$var$useMenuSubContext($6cc32821e9371a1c$var$SUB_TRIGGER_NAME, props.__scopeMenu);
  const contentContext = $6cc32821e9371a1c$var$useMenuContentContext($6cc32821e9371a1c$var$SUB_TRIGGER_NAME, props.__scopeMenu);
  const openTimerRef = (0, import_react12.useRef)(null);
  const { pointerGraceTimerRef, onPointerGraceIntentChange } = contentContext;
  const scope = {
    __scopeMenu: props.__scopeMenu
  };
  const clearOpenTimer = (0, import_react12.useCallback)(() => {
    if (openTimerRef.current)
      window.clearTimeout(openTimerRef.current);
    openTimerRef.current = null;
  }, []);
  (0, import_react12.useEffect)(
    () => clearOpenTimer,
    [
      clearOpenTimer
    ]
  );
  (0, import_react12.useEffect)(() => {
    const pointerGraceTimer = pointerGraceTimerRef.current;
    return () => {
      window.clearTimeout(pointerGraceTimer);
      onPointerGraceIntentChange(null);
    };
  }, [
    pointerGraceTimerRef,
    onPointerGraceIntentChange
  ]);
  return (0, import_react12.createElement)($6cc32821e9371a1c$export$9fa5ebd18bee4d43, _extends({
    asChild: true
  }, scope), (0, import_react12.createElement)($6cc32821e9371a1c$var$MenuItemImpl, _extends({
    id: subContext.triggerId,
    "aria-haspopup": "menu",
    "aria-expanded": context.open,
    "aria-controls": subContext.contentId,
    "data-state": $6cc32821e9371a1c$var$getOpenState(context.open)
  }, props, {
    ref: $6ed0406888f73fc4$export$43e446d32b3d21af(forwardedRef, subContext.onTriggerChange),
    onClick: (event) => {
      var _props$onClick;
      (_props$onClick = props.onClick) === null || _props$onClick === void 0 || _props$onClick.call(props, event);
      if (props.disabled || event.defaultPrevented)
        return;
      event.currentTarget.focus();
      if (!context.open)
        context.onOpenChange(true);
    },
    onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerMove, $6cc32821e9371a1c$var$whenMouse((event) => {
      contentContext.onItemEnter(event);
      if (event.defaultPrevented)
        return;
      if (!props.disabled && !context.open && !openTimerRef.current) {
        contentContext.onPointerGraceIntentChange(null);
        openTimerRef.current = window.setTimeout(() => {
          context.onOpenChange(true);
          clearOpenTimer();
        }, 100);
      }
    })),
    onPointerLeave: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerLeave, $6cc32821e9371a1c$var$whenMouse((event) => {
      var _context$content;
      clearOpenTimer();
      const contentRect = (_context$content = context.content) === null || _context$content === void 0 ? void 0 : _context$content.getBoundingClientRect();
      if (contentRect) {
        var _context$content2;
        const side = (_context$content2 = context.content) === null || _context$content2 === void 0 ? void 0 : _context$content2.dataset.side;
        const rightSide = side === "right";
        const bleed = rightSide ? -5 : 5;
        const contentNearEdge = contentRect[rightSide ? "left" : "right"];
        const contentFarEdge = contentRect[rightSide ? "right" : "left"];
        contentContext.onPointerGraceIntentChange({
          area: [
            {
              x: event.clientX + bleed,
              y: event.clientY
            },
            {
              x: contentNearEdge,
              y: contentRect.top
            },
            {
              x: contentFarEdge,
              y: contentRect.top
            },
            {
              x: contentFarEdge,
              y: contentRect.bottom
            },
            {
              x: contentNearEdge,
              y: contentRect.bottom
            }
          ],
          side
        });
        window.clearTimeout(pointerGraceTimerRef.current);
        pointerGraceTimerRef.current = window.setTimeout(
          () => contentContext.onPointerGraceIntentChange(null),
          300
        );
      } else {
        contentContext.onTriggerLeave(event);
        if (event.defaultPrevented)
          return;
        contentContext.onPointerGraceIntentChange(null);
      }
    })),
    onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
      const isTypingAhead = contentContext.searchRef.current !== "";
      if (props.disabled || isTypingAhead && event.key === " ")
        return;
      if ($6cc32821e9371a1c$var$SUB_OPEN_KEYS[rootContext.dir].includes(event.key)) {
        var _context$content3;
        context.onOpenChange(true);
        (_context$content3 = context.content) === null || _context$content3 === void 0 || _context$content3.focus();
        event.preventDefault();
      }
    })
  })));
});
Object.assign($6cc32821e9371a1c$export$5fbbb3ba7297405f, {
  displayName: $6cc32821e9371a1c$var$SUB_TRIGGER_NAME
});
var $6cc32821e9371a1c$var$SUB_CONTENT_NAME = "MenuSubContent";
var $6cc32821e9371a1c$export$e7142ab31822bde6 = (0, import_react12.forwardRef)((props, forwardedRef) => {
  const portalContext = $6cc32821e9371a1c$var$usePortalContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
  const { forceMount = portalContext.forceMount, ...subContentProps } = props;
  const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
  const rootContext = $6cc32821e9371a1c$var$useMenuRootContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
  const subContext = $6cc32821e9371a1c$var$useMenuSubContext($6cc32821e9371a1c$var$SUB_CONTENT_NAME, props.__scopeMenu);
  const ref = (0, import_react12.useRef)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
  return (0, import_react12.createElement)($6cc32821e9371a1c$var$Collection.Provider, {
    scope: props.__scopeMenu
  }, (0, import_react12.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
    present: forceMount || context.open
  }, (0, import_react12.createElement)($6cc32821e9371a1c$var$Collection.Slot, {
    scope: props.__scopeMenu
  }, (0, import_react12.createElement)($6cc32821e9371a1c$var$MenuContentImpl, _extends({
    id: subContext.contentId,
    "aria-labelledby": subContext.triggerId
  }, subContentProps, {
    ref: composedRefs,
    align: "start",
    side: rootContext.dir === "rtl" ? "left" : "right",
    disableOutsidePointerEvents: false,
    disableOutsideScroll: false,
    trapFocus: false,
    onOpenAutoFocus: (event) => {
      var _ref$current;
      if (rootContext.isUsingKeyboardRef.current)
        (_ref$current = ref.current) === null || _ref$current === void 0 || _ref$current.focus();
      event.preventDefault();
    },
    onCloseAutoFocus: (event) => event.preventDefault(),
    onFocusOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocusOutside, (event) => {
      if (event.target !== subContext.trigger)
        context.onOpenChange(false);
    }),
    onEscapeKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onEscapeKeyDown, (event) => {
      rootContext.onClose();
      event.preventDefault();
    }),
    onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
      const isKeyDownInside = event.currentTarget.contains(event.target);
      const isCloseKey = $6cc32821e9371a1c$var$SUB_CLOSE_KEYS[rootContext.dir].includes(event.key);
      if (isKeyDownInside && isCloseKey) {
        var _subContext$trigger;
        context.onOpenChange(false);
        (_subContext$trigger = subContext.trigger) === null || _subContext$trigger === void 0 || _subContext$trigger.focus();
        event.preventDefault();
      }
    })
  })))));
});
Object.assign($6cc32821e9371a1c$export$e7142ab31822bde6, {
  displayName: $6cc32821e9371a1c$var$SUB_CONTENT_NAME
});
function $6cc32821e9371a1c$var$getOpenState(open) {
  return open ? "open" : "closed";
}
function $6cc32821e9371a1c$var$isIndeterminate(checked) {
  return checked === "indeterminate";
}
function $6cc32821e9371a1c$var$getCheckedState(checked) {
  return $6cc32821e9371a1c$var$isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
function $6cc32821e9371a1c$var$focusFirst(candidates) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)
      return;
    candidate.focus();
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT)
      return;
  }
}
function $6cc32821e9371a1c$var$wrapArray(array, startIndex) {
  return array.map(
    (_, index2) => array[(startIndex + index2) % array.length]
  );
}
function $6cc32821e9371a1c$var$getNextMatch(values, search2, currentMatch) {
  const isRepeated = search2.length > 1 && Array.from(search2).every(
    (char) => char === search2[0]
  );
  const normalizedSearch = isRepeated ? search2[0] : search2;
  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;
  let wrappedValues = $6cc32821e9371a1c$var$wrapArray(values, Math.max(currentMatchIndex, 0));
  const excludeCurrentMatch = normalizedSearch.length === 1;
  if (excludeCurrentMatch)
    wrappedValues = wrappedValues.filter(
      (v) => v !== currentMatch
    );
  const nextMatch = wrappedValues.find(
    (value) => value.toLowerCase().startsWith(normalizedSearch.toLowerCase())
  );
  return nextMatch !== currentMatch ? nextMatch : void 0;
}
function $6cc32821e9371a1c$var$isPointInPolygon(point, polygon) {
  const { x, y } = point;
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i].x;
    const yi = polygon[i].y;
    const xj = polygon[j].x;
    const yj = polygon[j].y;
    const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect)
      inside = !inside;
  }
  return inside;
}
function $6cc32821e9371a1c$var$isPointerInGraceArea(event, area) {
  if (!area)
    return false;
  const cursorPos = {
    x: event.clientX,
    y: event.clientY
  };
  return $6cc32821e9371a1c$var$isPointInPolygon(cursorPos, area);
}
function $6cc32821e9371a1c$var$whenMouse(handler) {
  return (event) => event.pointerType === "mouse" ? handler(event) : void 0;
}
var $6cc32821e9371a1c$export$be92b6f5f03c0fe9 = $6cc32821e9371a1c$export$d9b273488cd8ce6f;
var $6cc32821e9371a1c$export$b688253958b8dfe7 = $6cc32821e9371a1c$export$9fa5ebd18bee4d43;
var $6cc32821e9371a1c$export$602eac185826482c = $6cc32821e9371a1c$export$793392f970497feb;
var $6cc32821e9371a1c$export$7c6e2c02157bb7d2 = $6cc32821e9371a1c$export$479f0f2f71193efe;
var $6cc32821e9371a1c$export$eb2fcfdbd7ba97d4 = $6cc32821e9371a1c$export$22a631d1f72787bb;
var $6cc32821e9371a1c$export$b04be29aa201d4f5 = $6cc32821e9371a1c$export$dd37bec0e8a99143;
var $6cc32821e9371a1c$export$6d08773d2e66f8f2 = $6cc32821e9371a1c$export$2ce376c2cc3355c8;
var $6cc32821e9371a1c$export$16ce288f89fa631c = $6cc32821e9371a1c$export$f6f243521332502d;
var $6cc32821e9371a1c$export$a98f0dcb43a68a25 = $6cc32821e9371a1c$export$ea2200c9eee416b3;
var $6cc32821e9371a1c$export$371ab307eab489c0 = $6cc32821e9371a1c$export$69bd225e9817f6d0;
var $6cc32821e9371a1c$export$c3468e2714d175fa = $6cc32821e9371a1c$export$a2593e23056970a3;
var $6cc32821e9371a1c$export$1ff3c3f08ae963c0 = $6cc32821e9371a1c$export$1cec7dcdd713e220;
var $6cc32821e9371a1c$export$21b07c8f274aebd5 = $6cc32821e9371a1c$export$bcdda4773debf5fa;
var $6cc32821e9371a1c$export$2ea8a7a591ac5eac = $6cc32821e9371a1c$export$5fbbb3ba7297405f;
var $6cc32821e9371a1c$export$6d4de93b380beddf = $6cc32821e9371a1c$export$e7142ab31822bde6;

// node_modules/@radix-ui/react-dropdown-menu/dist/index.mjs
var $d08ef79370b62062$var$DROPDOWN_MENU_NAME = "DropdownMenu";
var [$d08ef79370b62062$var$createDropdownMenuContext, $d08ef79370b62062$export$c0623cd925aeb687] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($d08ef79370b62062$var$DROPDOWN_MENU_NAME, [
  $6cc32821e9371a1c$export$4027731b685e72eb
]);
var $d08ef79370b62062$var$useMenuScope = $6cc32821e9371a1c$export$4027731b685e72eb();
var [$d08ef79370b62062$var$DropdownMenuProvider, $d08ef79370b62062$var$useDropdownMenuContext] = $d08ef79370b62062$var$createDropdownMenuContext($d08ef79370b62062$var$DROPDOWN_MENU_NAME);
var $d08ef79370b62062$export$e44a253a59704894 = (props) => {
  const { __scopeDropdownMenu, children, dir, open: openProp, defaultOpen, onOpenChange, modal = true } = props;
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  const triggerRef = (0, import_react13.useRef)(null);
  const [open = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return (0, import_react13.createElement)($d08ef79370b62062$var$DropdownMenuProvider, {
    scope: __scopeDropdownMenu,
    triggerId: $1746a345f3d73bb7$export$f680877a34711e37(),
    triggerRef,
    contentId: $1746a345f3d73bb7$export$f680877a34711e37(),
    open,
    onOpenChange: setOpen,
    onOpenToggle: (0, import_react13.useCallback)(
      () => setOpen(
        (prevOpen) => !prevOpen
      ),
      [
        setOpen
      ]
    ),
    modal
  }, (0, import_react13.createElement)($6cc32821e9371a1c$export$be92b6f5f03c0fe9, _extends({}, menuScope, {
    open,
    onOpenChange: setOpen,
    dir,
    modal
  }), children));
};
Object.assign($d08ef79370b62062$export$e44a253a59704894, {
  displayName: $d08ef79370b62062$var$DROPDOWN_MENU_NAME
});
var $d08ef79370b62062$var$TRIGGER_NAME = "DropdownMenuTrigger";
var $d08ef79370b62062$export$d2469213b3befba9 = (0, import_react13.forwardRef)((props, forwardedRef) => {
  const { __scopeDropdownMenu, disabled = false, ...triggerProps } = props;
  const context = $d08ef79370b62062$var$useDropdownMenuContext($d08ef79370b62062$var$TRIGGER_NAME, __scopeDropdownMenu);
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  return (0, import_react13.createElement)($6cc32821e9371a1c$export$b688253958b8dfe7, _extends({
    asChild: true
  }, menuScope), (0, import_react13.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends({
    type: "button",
    id: context.triggerId,
    "aria-haspopup": "menu",
    "aria-expanded": context.open,
    "aria-controls": context.open ? context.contentId : void 0,
    "data-state": context.open ? "open" : "closed",
    "data-disabled": disabled ? "" : void 0,
    disabled
  }, triggerProps, {
    ref: $6ed0406888f73fc4$export$43e446d32b3d21af(forwardedRef, context.triggerRef),
    onPointerDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDown, (event) => {
      if (!disabled && event.button === 0 && event.ctrlKey === false) {
        context.onOpenToggle();
        if (!context.open)
          event.preventDefault();
      }
    }),
    onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
      if (disabled)
        return;
      if ([
        "Enter",
        " "
      ].includes(event.key))
        context.onOpenToggle();
      if (event.key === "ArrowDown")
        context.onOpenChange(true);
      if ([
        "Enter",
        " ",
        "ArrowDown"
      ].includes(event.key))
        event.preventDefault();
    })
  })));
});
Object.assign($d08ef79370b62062$export$d2469213b3befba9, {
  displayName: $d08ef79370b62062$var$TRIGGER_NAME
});
var $d08ef79370b62062$var$PORTAL_NAME = "DropdownMenuPortal";
var $d08ef79370b62062$export$cd369b4d4d54efc9 = (props) => {
  const { __scopeDropdownMenu, ...portalProps } = props;
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  return (0, import_react13.createElement)($6cc32821e9371a1c$export$602eac185826482c, _extends({}, menuScope, portalProps));
};
Object.assign($d08ef79370b62062$export$cd369b4d4d54efc9, {
  displayName: $d08ef79370b62062$var$PORTAL_NAME
});
var $d08ef79370b62062$var$CONTENT_NAME = "DropdownMenuContent";
var $d08ef79370b62062$export$6e76d93a37c01248 = (0, import_react13.forwardRef)((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...contentProps } = props;
  const context = $d08ef79370b62062$var$useDropdownMenuContext($d08ef79370b62062$var$CONTENT_NAME, __scopeDropdownMenu);
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  const hasInteractedOutsideRef = (0, import_react13.useRef)(false);
  return (0, import_react13.createElement)($6cc32821e9371a1c$export$7c6e2c02157bb7d2, _extends({
    id: context.contentId,
    "aria-labelledby": context.triggerId
  }, menuScope, contentProps, {
    ref: forwardedRef,
    onCloseAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onCloseAutoFocus, (event) => {
      var _context$triggerRef$c;
      if (!hasInteractedOutsideRef.current)
        (_context$triggerRef$c = context.triggerRef.current) === null || _context$triggerRef$c === void 0 || _context$triggerRef$c.focus();
      hasInteractedOutsideRef.current = false;
      event.preventDefault();
    }),
    onInteractOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onInteractOutside, (event) => {
      const originalEvent = event.detail.originalEvent;
      const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
      const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
      if (!context.modal || isRightClick)
        hasInteractedOutsideRef.current = true;
    }),
    style: {
      ...props.style,
      "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
      "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
      "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
    }
  }));
});
Object.assign($d08ef79370b62062$export$6e76d93a37c01248, {
  displayName: $d08ef79370b62062$var$CONTENT_NAME
});
var $d08ef79370b62062$var$GROUP_NAME = "DropdownMenuGroup";
var $d08ef79370b62062$export$246bebaba3a2f70e = (0, import_react13.forwardRef)((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...groupProps } = props;
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  return (0, import_react13.createElement)($6cc32821e9371a1c$export$eb2fcfdbd7ba97d4, _extends({}, menuScope, groupProps, {
    ref: forwardedRef
  }));
});
Object.assign($d08ef79370b62062$export$246bebaba3a2f70e, {
  displayName: $d08ef79370b62062$var$GROUP_NAME
});
var $d08ef79370b62062$var$LABEL_NAME = "DropdownMenuLabel";
var $d08ef79370b62062$export$76e48c5b57f24495 = (0, import_react13.forwardRef)((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...labelProps } = props;
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  return (0, import_react13.createElement)($6cc32821e9371a1c$export$b04be29aa201d4f5, _extends({}, menuScope, labelProps, {
    ref: forwardedRef
  }));
});
Object.assign($d08ef79370b62062$export$76e48c5b57f24495, {
  displayName: $d08ef79370b62062$var$LABEL_NAME
});
var $d08ef79370b62062$var$ITEM_NAME = "DropdownMenuItem";
var $d08ef79370b62062$export$ed97964d1871885d = (0, import_react13.forwardRef)((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...itemProps } = props;
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  return (0, import_react13.createElement)($6cc32821e9371a1c$export$6d08773d2e66f8f2, _extends({}, menuScope, itemProps, {
    ref: forwardedRef
  }));
});
Object.assign($d08ef79370b62062$export$ed97964d1871885d, {
  displayName: $d08ef79370b62062$var$ITEM_NAME
});
var $d08ef79370b62062$var$CHECKBOX_ITEM_NAME = "DropdownMenuCheckboxItem";
var $d08ef79370b62062$export$53a69729da201fa9 = (0, import_react13.forwardRef)((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...checkboxItemProps } = props;
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  return (0, import_react13.createElement)($6cc32821e9371a1c$export$16ce288f89fa631c, _extends({}, menuScope, checkboxItemProps, {
    ref: forwardedRef
  }));
});
Object.assign($d08ef79370b62062$export$53a69729da201fa9, {
  displayName: $d08ef79370b62062$var$CHECKBOX_ITEM_NAME
});
var $d08ef79370b62062$var$RADIO_GROUP_NAME = "DropdownMenuRadioGroup";
var $d08ef79370b62062$export$3323ad73d55f587e = (0, import_react13.forwardRef)((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...radioGroupProps } = props;
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  return (0, import_react13.createElement)($6cc32821e9371a1c$export$a98f0dcb43a68a25, _extends({}, menuScope, radioGroupProps, {
    ref: forwardedRef
  }));
});
Object.assign($d08ef79370b62062$export$3323ad73d55f587e, {
  displayName: $d08ef79370b62062$var$RADIO_GROUP_NAME
});
var $d08ef79370b62062$var$RADIO_ITEM_NAME = "DropdownMenuRadioItem";
var $d08ef79370b62062$export$e4f69b41b1637536 = (0, import_react13.forwardRef)((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...radioItemProps } = props;
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  return (0, import_react13.createElement)($6cc32821e9371a1c$export$371ab307eab489c0, _extends({}, menuScope, radioItemProps, {
    ref: forwardedRef
  }));
});
Object.assign($d08ef79370b62062$export$e4f69b41b1637536, {
  displayName: $d08ef79370b62062$var$RADIO_ITEM_NAME
});
var $d08ef79370b62062$var$INDICATOR_NAME = "DropdownMenuItemIndicator";
var $d08ef79370b62062$export$42355ae145153fb6 = (0, import_react13.forwardRef)((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...itemIndicatorProps } = props;
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  return (0, import_react13.createElement)($6cc32821e9371a1c$export$c3468e2714d175fa, _extends({}, menuScope, itemIndicatorProps, {
    ref: forwardedRef
  }));
});
Object.assign($d08ef79370b62062$export$42355ae145153fb6, {
  displayName: $d08ef79370b62062$var$INDICATOR_NAME
});
var $d08ef79370b62062$var$SEPARATOR_NAME = "DropdownMenuSeparator";
var $d08ef79370b62062$export$da160178fd3bc7e9 = (0, import_react13.forwardRef)((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...separatorProps } = props;
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  return (0, import_react13.createElement)($6cc32821e9371a1c$export$1ff3c3f08ae963c0, _extends({}, menuScope, separatorProps, {
    ref: forwardedRef
  }));
});
Object.assign($d08ef79370b62062$export$da160178fd3bc7e9, {
  displayName: $d08ef79370b62062$var$SEPARATOR_NAME
});
var $d08ef79370b62062$var$ARROW_NAME = "DropdownMenuArrow";
var $d08ef79370b62062$export$34b8980744021ec5 = (0, import_react13.forwardRef)((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...arrowProps } = props;
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  return (0, import_react13.createElement)($6cc32821e9371a1c$export$21b07c8f274aebd5, _extends({}, menuScope, arrowProps, {
    ref: forwardedRef
  }));
});
Object.assign($d08ef79370b62062$export$34b8980744021ec5, {
  displayName: $d08ef79370b62062$var$ARROW_NAME
});
var $d08ef79370b62062$var$SUB_TRIGGER_NAME = "DropdownMenuSubTrigger";
var $d08ef79370b62062$export$21dcb7ec56f874cf = (0, import_react13.forwardRef)((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...subTriggerProps } = props;
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  return (0, import_react13.createElement)($6cc32821e9371a1c$export$2ea8a7a591ac5eac, _extends({}, menuScope, subTriggerProps, {
    ref: forwardedRef
  }));
});
Object.assign($d08ef79370b62062$export$21dcb7ec56f874cf, {
  displayName: $d08ef79370b62062$var$SUB_TRIGGER_NAME
});
var $d08ef79370b62062$var$SUB_CONTENT_NAME = "DropdownMenuSubContent";
var $d08ef79370b62062$export$f34ec8bc2482cc5f = (0, import_react13.forwardRef)((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...subContentProps } = props;
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  return (0, import_react13.createElement)($6cc32821e9371a1c$export$6d4de93b380beddf, _extends({}, menuScope, subContentProps, {
    ref: forwardedRef,
    style: {
      ...props.style,
      "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
      "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
      "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
    }
  }));
});
Object.assign($d08ef79370b62062$export$f34ec8bc2482cc5f, {
  displayName: $d08ef79370b62062$var$SUB_CONTENT_NAME
});
var $d08ef79370b62062$export$be92b6f5f03c0fe9 = $d08ef79370b62062$export$e44a253a59704894;
var $d08ef79370b62062$export$41fb9f06171c75f4 = $d08ef79370b62062$export$d2469213b3befba9;
var $d08ef79370b62062$export$602eac185826482c = $d08ef79370b62062$export$cd369b4d4d54efc9;
var $d08ef79370b62062$export$7c6e2c02157bb7d2 = $d08ef79370b62062$export$6e76d93a37c01248;
var $d08ef79370b62062$export$6d08773d2e66f8f2 = $d08ef79370b62062$export$ed97964d1871885d;

// node_modules/@thirdweb-dev/react/dist/useWalletConnect-36cbc580.browser.esm.js
function shortenString(str, extraShort) {
  return `${str.substring(0, extraShort ? 4 : 6)}...${str.substring(str.length - (extraShort ? 3 : 4))}`;
}
function shortenAddress(address, extraShort) {
  try {
    const formattedAddress = utils_exports.getAddress(address);
    return shortenString(formattedAddress, extraShort);
  } catch {
    return address;
  }
}
var SecondaryText = newStyled.span`
  font-size: ${fontSize.md};
  color: ${(p) => p.theme.text.secondary};
  margin: 0;
`;
newStyled.span`
  font-size: ${fontSize.md};
  color: ${(p) => p.theme.text.neutral};
  margin: 0;
`;
newStyled.span`
  font-size: ${fontSize.md};
  color: ${(p) => p.theme.text.danger};
  margin: 0;
`;
var localWalletIcon = "ipfs://QmbQzSNGvmNYZzem9jZRuYeLe9K2W4pqbdnVUp7Y6edQ8Y/local-wallet.svg";
var ExportLocalWallet = (props) => {
  const [password, setPassword] = (0, import_react14.useState)("");
  const [showPassword, setShowPassword] = (0, import_react14.useState)(false);
  const [isWrongPassword, setIsWrongPassword] = (0, import_react14.useState)(false);
  const [passwordIsRequired, setPasswordIsRequired] = (0, import_react14.useState)(false);
  const wallet = useWallet();
  const address = useAddress();
  const [savedAddress, setSavedAddress] = (0, import_react14.useState)("");
  const createWalletInstance = useCreateWalletInstance();
  const mounted = (0, import_react14.useRef)(false);
  (0, import_react14.useEffect)(() => {
    if (mounted.current) {
      return;
    }
    mounted.current = true;
    (async () => {
      if (wallet && wallet instanceof LocalWallet) {
        if (address) {
          setSavedAddress(address);
        }
        const savedData = await wallet.getSavedData();
        if ((savedData == null ? void 0 : savedData.address) !== address) {
          setPasswordIsRequired(true);
        }
      } else {
        const localWallet2 = createWalletInstance(props.localWalletConfig);
        const data = await localWallet2.getSavedData();
        if (data) {
          setSavedAddress(data.address);
        }
      }
    })();
  }, [wallet, props.localWalletConfig, createWalletInstance, password, address]);
  const exportFromLocalStorage = async () => {
    if (wallet && wallet instanceof LocalWallet) {
      const savedData = await wallet.getSavedData();
      if (savedData && savedData.address === address) {
        downloadJsonWalletFile(savedData.data);
        props.onExport();
      } else {
        try {
          const dataStr = await wallet.export({
            password,
            strategy: "encryptedJson"
          });
          downloadJsonWalletFile(dataStr);
          props.onExport();
        } catch (e) {
          console.error(e);
          setIsWrongPassword(true);
        }
      }
    } else {
      const localWallet2 = createWalletInstance(props.localWalletConfig);
      const savedData = await localWallet2.getSavedData();
      downloadJsonWalletFile(savedData.data);
      props.onExport();
    }
  };
  if (!savedAddress) {
    return (0, import_jsx_runtime.jsx)(Flex, {
      justifyContent: "center",
      alignItems: "center",
      style: {
        height: "300px"
      },
      children: (0, import_jsx_runtime.jsx)(Spinner, {
        size: "md",
        color: "link"
      })
    });
  }
  const exportDisabled = isWrongPassword;
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
    children: [(0, import_jsx_runtime.jsx)(Img, {
      src: localWalletIcon,
      width: iconSize.xl,
      height: iconSize.xl
    }), (0, import_jsx_runtime.jsx)(Spacer, {
      y: "lg"
    }), (0, import_jsx_runtime.jsx)(ModalTitle, {
      style: {
        textAlign: "left"
      },
      children: "Backup Wallet"
    }), (0, import_jsx_runtime.jsx)(Spacer, {
      y: "md"
    }), (0, import_jsx_runtime.jsx)(ModalDescription, {
      children: "This will download a JSON file containing the wallet information onto your device encrypted with the password"
    }), (0, import_jsx_runtime.jsx)(Spacer, {
      y: "sm"
    }), (0, import_jsx_runtime.jsx)(ModalDescription, {
      children: "You can use this JSON file to import the account in MetaMask using the same password"
    }), (0, import_jsx_runtime.jsx)(Spacer, {
      y: "xl"
    }), (0, import_jsx_runtime.jsxs)("form", {
      onSubmit: (e) => {
        e.preventDefault();
        exportFromLocalStorage();
      },
      children: [(0, import_jsx_runtime.jsx)(Label, {
        children: "Wallet Address"
      }), (0, import_jsx_runtime.jsx)(Spacer, {
        y: "sm"
      }), (0, import_jsx_runtime.jsx)(SavedWalletAddress, {
        children: shortenAddress(savedAddress)
      }), (0, import_jsx_runtime.jsx)(Spacer, {
        y: "lg"
      }), passwordIsRequired && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
        children: [(0, import_jsx_runtime.jsx)("input", {
          type: "text",
          name: "username",
          autoComplete: "off",
          value: address,
          disabled: true,
          style: {
            display: "none"
          }
        }), (0, import_jsx_runtime.jsx)(FormFieldWithIconButton, {
          noSave: true,
          required: true,
          name: "current-password",
          autocomplete: "current-password",
          id: "current-password",
          onChange: (value) => {
            setPassword(value);
            setIsWrongPassword(false);
          },
          right: {
            onClick: () => setShowPassword(!showPassword),
            icon: showPassword ? (0, import_jsx_runtime.jsx)(EyeClosedIcon, {}) : (0, import_jsx_runtime.jsx)(EyeOpenIcon, {})
          },
          label: "Password",
          type: showPassword ? "text" : "password",
          value: password,
          error: isWrongPassword ? "Wrong Password" : "",
          dataTest: "current-password"
        }), (0, import_jsx_runtime.jsx)(Spacer, {
          y: "xl"
        })]
      }), (0, import_jsx_runtime.jsx)(FormFooter, {
        children: (0, import_jsx_runtime.jsx)(Button, {
          disabled: exportDisabled,
          variant: "inverted",
          style: {
            opacity: exportDisabled ? 0.5 : 1
          },
          type: "submit",
          children: "Backup"
        })
      })]
    })]
  });
};
function downloadJsonWalletFile(data) {
  const dataObj = JSON.parse(data);
  const blob = new Blob([JSON.stringify(dataObj, null, 2)], {
    type: "application/json"
  });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "wallet.json";
  document.body.appendChild(a);
  a.style.display = "none";
  a.click();
  URL.revokeObjectURL(a.href);
}
var SavedWalletAddress = newStyled.p`
  font-size: ${fontSize.md};
  color: ${(props) => props.theme.text.secondary};
  margin: 0;
`;
var defaultChainIcon = resolveIpfsUri("ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/ethereum/512.png");
var ChainIcon = (props) => {
  var _a, _b;
  const url = (_b = (_a = props.chain) == null ? void 0 : _a.icon) == null ? void 0 : _b.url;
  const src = url ? resolveIpfsUri(url) : defaultChainIcon;
  return (0, import_jsx_runtime.jsxs)("div", {
    style: {
      position: "relative",
      display: "flex",
      flexShrink: 0,
      alignItems: "center"
    },
    children: [(0, import_jsx_runtime.jsx)("img", {
      src: src || defaultChainIcon,
      onError: (e) => {
        if (defaultChainIcon && e.currentTarget.src !== defaultChainIcon) {
          e.currentTarget.src = defaultChainIcon;
        }
      },
      alt: "",
      width: props.size,
      height: props.size,
      className: props.className,
      loading: props.loading,
      style: {
        objectFit: "contain",
        width: props.size + "px",
        height: props.size + "px"
      }
    }), props.active && (0, import_jsx_runtime.jsx)(ActiveDot, {})]
  });
};
var ActiveDot = newStyled.div`
  width: 28%;
  height: 28%;
  border-radius: 50%;
  position: absolute;
  top: 60%;
  right: 0px;
  background-color: #00d395;
  box-shadow: 0 0 0 2px ${(p) => p.theme.bg.elevated};
`;
function useClipboard(text) {
  let optionsOrTimeout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const [hasCopied, setHasCopied] = (0, import_react14.useState)(false);
  const {
    timeout = 1500,
    ...copyOptions
  } = typeof optionsOrTimeout === "number" ? {
    timeout: optionsOrTimeout
  } : optionsOrTimeout;
  const onCopy = (0, import_react14.useCallback)(() => {
    const didCopy = (0, import_copy_to_clipboard.default)(text, copyOptions);
    setHasCopied(didCopy);
  }, [text, copyOptions]);
  (0, import_react14.useEffect)(() => {
    let timeoutId = null;
    if (hasCopied) {
      timeoutId = window.setTimeout(() => {
        setHasCopied(false);
      }, timeout);
    }
    return () => {
      if (timeoutId) {
        window.clearTimeout(timeoutId);
      }
    };
  }, [timeout, hasCopied]);
  return {
    value: text,
    onCopy,
    hasCopied
  };
}
var ToolTip = (props) => {
  return (0, import_jsx_runtime.jsx)($a093c7e1ec25a057$export$2881499e37b75b9a, {
    delayDuration: 200,
    children: (0, import_jsx_runtime.jsxs)($a093c7e1ec25a057$export$be92b6f5f03c0fe9, {
      children: [(0, import_jsx_runtime.jsx)($a093c7e1ec25a057$export$41fb9f06171c75f4, {
        asChild: true,
        children: props.children
      }), (0, import_jsx_runtime.jsx)($a093c7e1ec25a057$export$602eac185826482c, {
        children: (0, import_jsx_runtime.jsxs)(TooltipContent, {
          sideOffset: props.sideOffset || 6,
          align: props.align,
          side: props.side,
          children: [props.tip, (0, import_jsx_runtime.jsx)(TooltipArrow, {})]
        })
      })]
    })
  });
};
var slideUpAndFade$1 = keyframes`
from {
  opacity: 0;
  transform: translateY(2px);
}
to {
  opacity: 1;
  transform: translateY(0);
}
`;
var TooltipContent = newStyled($a093c7e1ec25a057$export$7c6e2c02157bb7d2)`
  background: ${(p) => p.theme.tooltip.bg};
  color: ${(p) => p.theme.tooltip.text};
  border-radius: ${radius.sm};
  line-height: 1;
  padding: ${spacing.sm} ${spacing.md};
  font-size: ${fontSize.sm};
  box-shadow: ${shadow.sm};
  user-select: none;
  will-change: transform, opacity;
  animation: ${slideUpAndFade$1} 200ms cubic-bezier(0.16, 1, 0.3, 1);
  z-index: 999999999999999;
  max-width: 300px;
  line-height: 1.5;
`;
var TooltipArrow = newStyled($a093c7e1ec25a057$export$21b07c8f274aebd5)`
  fill: ${(p) => p.theme.tooltip.bg};
`;
var CopyIcon2 = (props) => {
  const {
    hasCopied,
    onCopy
  } = useClipboard(props.text);
  return (0, import_jsx_runtime.jsx)("div", {
    onClick: onCopy,
    style: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center"
    },
    children: (0, import_jsx_runtime.jsx)(ToolTip, {
      tip: props.tip,
      side: props.side,
      align: props.align,
      children: hasCopied ? (0, import_jsx_runtime.jsx)(CheckIconStyled, {}) : (0, import_jsx_runtime.jsx)(CopyIcon, {})
    })
  });
};
var CheckIconStyled = newStyled(CheckIcon)`
  color: ${(p) => p.theme.icon.success};
`;
var scrollbar = (_ref) => {
  let {
    track,
    thumb,
    hover
  } = _ref;
  return `
&::-webkit-scrollbar {
  width: 6px;
}

&::-webkit-scrollbar-track {
  box-shadow: inset 0 0 5px ${track};
  border-radius: ${radius.md};
}

&::-webkit-scrollbar-thumb {
  background: ${thumb};
  border-radius: ${radius.md};
}

&::-webkit-scrollbar-thumb:hover {
  background: ${hover};
}`;
};
var overlayEnter = keyframes`
 from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
`;
var Overlay = newStyled.div`
  background-color: ${(p) => p.theme.overlay.subdued};
  z-index: 9999;
  position: fixed;
  inset: 0;
  animation: ${overlayEnter} 400ms cubic-bezier(0.16, 1, 0.3, 1);
`;
var Modal = (props) => {
  return (0, import_jsx_runtime.jsxs)($5d3850c4d0b4e6c7$export$be92b6f5f03c0fe9, {
    open: props.open,
    onOpenChange: props.setOpen,
    children: [props.trigger && (0, import_jsx_runtime.jsx)($5d3850c4d0b4e6c7$export$41fb9f06171c75f4, {
      asChild: true,
      children: props.trigger
    }), (0, import_jsx_runtime.jsxs)($5d3850c4d0b4e6c7$export$602eac185826482c, {
      children: [(0, import_jsx_runtime.jsx)($5d3850c4d0b4e6c7$export$c6fdb837b070b4ff, {
        asChild: true,
        children: (0, import_jsx_runtime.jsx)(Overlay, {})
      }), (0, import_jsx_runtime.jsx)($5d3850c4d0b4e6c7$export$7c6e2c02157bb7d2, {
        asChild: true,
        children: (0, import_jsx_runtime.jsxs)(DialogContent, {
          style: props.style,
          children: [props.title && (0, import_jsx_runtime.jsxs)(DialogTitle, {
            children: [" ", props.title]
          }), props.children, !props.hideCloseIcon && (0, import_jsx_runtime.jsx)(CrossContainer, {
            children: (0, import_jsx_runtime.jsx)($5d3850c4d0b4e6c7$export$f39c2d165cd861fe, {
              asChild: true,
              children: (0, import_jsx_runtime.jsx)(IconButton, {
                variant: "secondary",
                type: "button",
                "aria-label": "Close",
                children: (0, import_jsx_runtime.jsx)(Cross2Icon, {
                  style: {
                    width: iconSize.md,
                    height: iconSize.md,
                    color: "inherit"
                  }
                })
              })
            })
          })]
        })
      })]
    })]
  });
};
var CrossContainer = newStyled.div`
  position: absolute;
  top: ${spacing.lg};
  right: ${spacing.lg};

  ${media.mobile} {
    right: ${spacing.md};
  }
`;
var modalAnimationDesktop = keyframes`
  from {
    opacity: 0;
    transform: translate(-50%, -48%) scale(0.96);
  }
  to {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
  }
`;
var modalAnimationMobile = keyframes`
  from {
    opacity: 0;
    transform: translate(0, 50%);
  }
  to {
    opacity: 1;
    transform: translate(0, 0);
  }
`;
var DialogContent = newStyled.div`
  z-index: 10000;
  background-color: ${(p) => p.theme.bg.base};
  border-radius: ${radius.xl};
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: calc(100vw - 40px);
  box-sizing: border-box;
  overflow-y: auto;
  padding: ${spacing.lg};
  padding-bottom: ${spacing.xl};
  animation: ${modalAnimationDesktop} 200ms ease;
  box-shadow: ${shadow.lg};
  line-height: 1;

  &:focus {
    outline: none;
  }

  ${(p) => scrollbar({
  track: "transparent",
  thumb: p.theme.bg.elevated,
  hover: p.theme.bg.highlighted
})}

  /* open from bottom on mobile */
  ${media.mobile} {
    top: auto;
    bottom: 0;
    left: 0;
    right: 0;
    max-width: 100vw;
    transform: none;
    width: 100vw;
    animation: ${modalAnimationMobile} 0.35s cubic-bezier(0.15, 1.15, 0.6, 1);
    border-radius: ${radius.xxl};
    border-bottom-right-radius: 0;
    border-bottom-left-radius: 0;
    max-width: none !important;
  }

  & *::selection {
    background-color: ${(p) => p.theme.bg.inverted};
    color: ${(p) => p.theme.text.inverted};
  }
`;
var DialogTitle = newStyled($5d3850c4d0b4e6c7$export$f99233281efd08a0)`
  margin: 0;
  font-weight: 500;
  color: ${(p) => p.theme.text.neutral};
  font-size: ${fontSize.lg};
`;
var fuseConfig = {
  threshold: 0.4,
  keys: [{
    name: "name",
    weight: 1
  }, {
    name: "chainId",
    weight: 1
  }]
};
var NetworkSelector = (props) => {
  var _a;
  const [searchTerm, setSearchTerm] = (0, import_react14.useState)("");
  const deferredSearchTerm = (0, import_react14.useDeferredValue)(searchTerm);
  const themeFromProvider = (0, import_react14.useContext)(ThirdwebThemeContext);
  const theme = props.theme || themeFromProvider || "dark";
  const supportedChains = useSupportedChains();
  const chains = props.chains || supportedChains;
  const _recentChains = props.recentChains;
  const cleanedPopularChains = !_recentChains ? props.popularChains : (_a = props.popularChains) == null ? void 0 : _a.filter((chain) => {
    return !_recentChains.some((recentChain) => recentChain.chainId === chain.chainId);
  });
  const fuseAllChains = (0, import_react14.useMemo)(() => {
    return new Fuse(chains, fuseConfig);
  }, [chains]);
  const fusePopularChains = (0, import_react14.useMemo)(() => {
    return new Fuse(cleanedPopularChains || [], fuseConfig);
  }, [cleanedPopularChains]);
  const fuseRecentChains = (0, import_react14.useMemo)(() => {
    return new Fuse(props.recentChains || [], fuseConfig);
  }, [props.recentChains]);
  const allChains = (0, import_react14.useMemo)(() => {
    if (deferredSearchTerm === "") {
      return chains;
    }
    return fuseAllChains.search(deferredSearchTerm).map((r) => r.item);
  }, [fuseAllChains, deferredSearchTerm, chains]);
  const popularChains = (0, import_react14.useMemo)(() => {
    if (deferredSearchTerm === "") {
      return cleanedPopularChains || [];
    }
    return fusePopularChains.search(deferredSearchTerm).map((r) => r.item);
  }, [fusePopularChains, deferredSearchTerm, cleanedPopularChains]);
  const recentChains = (0, import_react14.useMemo)(() => {
    if (deferredSearchTerm === "") {
      return props.recentChains || [];
    }
    return fuseRecentChains.search(deferredSearchTerm).map((r) => r.item);
  }, [fuseRecentChains, deferredSearchTerm, props.recentChains]);
  const {
    onClose,
    onSwitch,
    onCustomClick
  } = props;
  const handleSwitch = (0, import_react14.useCallback)((chain) => {
    if (onSwitch) {
      onSwitch(chain);
    }
    if (onClose) {
      onClose();
    }
  }, [onSwitch, onClose]);
  return (0, import_jsx_runtime.jsx)(ThemeProvider, {
    theme: theme === "dark" ? darkTheme : lightTheme,
    children: (0, import_jsx_runtime.jsxs)(Modal, {
      open: true,
      setOpen: (value) => {
        if (!value && onClose) {
          onClose();
        }
      },
      title: "Select Network",
      style: {
        maxWidth: "480px",
        paddingBottom: props.onCustomClick ? spacing.md : "0px"
      },
      children: [(0, import_jsx_runtime.jsx)(Spacer, {
        y: "xl"
      }), (0, import_jsx_runtime.jsxs)($69cb30bb0017df05$export$be92b6f5f03c0fe9, {
        className: "TabsRoot",
        defaultValue: "all",
        children: [(0, import_jsx_runtime.jsxs)($69cb30bb0017df05$export$54c2e3dc7acea9f5, {
          className: "TabsList",
          "aria-label": "Manage your account",
          style: {
            display: "flex",
            gap: spacing.xxs
          },
          children: [(0, import_jsx_runtime.jsx)(TabButton, {
            className: "TabsTrigger",
            value: "all",
            children: "All"
          }), (0, import_jsx_runtime.jsx)(TabButton, {
            className: "TabsTrigger",
            value: "mainnet",
            children: "Mainnets"
          }), (0, import_jsx_runtime.jsx)(TabButton, {
            className: "TabsTrigger",
            value: "testnet",
            children: "Testnets"
          })]
        }), (0, import_jsx_runtime.jsx)(Spacer, {
          y: "lg"
        }), (0, import_jsx_runtime.jsxs)("div", {
          style: {
            display: "flex",
            alignItems: "center",
            position: "relative"
          },
          children: [(0, import_jsx_runtime.jsx)(StyledMagnifyingGlassIcon, {
            width: iconSize.md,
            height: iconSize.md
          }), (0, import_jsx_runtime.jsx)(SearchInput, {
            style: {
              boxShadow: "none"
            },
            tabIndex: isMobile() ? -1 : 0,
            variant: "secondary",
            placeholder: "Search Network or Chain ID",
            value: searchTerm,
            onChange: (e) => {
              setSearchTerm(e.target.value);
            }
          }), deferredSearchTerm !== searchTerm && (0, import_jsx_runtime.jsx)("div", {
            style: {
              position: "absolute",
              right: spacing.md
            },
            children: (0, import_jsx_runtime.jsx)(Spinner, {
              size: "md",
              color: "link"
            })
          })]
        }), (0, import_jsx_runtime.jsx)(Spacer, {
          y: "lg"
        }), (0, import_jsx_runtime.jsx)($69cb30bb0017df05$export$7c6e2c02157bb7d2, {
          className: "TabsContent",
          value: "all",
          children: (0, import_jsx_runtime.jsx)(NetworkTab, {
            allChains,
            type: "all",
            popularChains,
            recentChains,
            onSwitch: handleSwitch,
            renderChain: props.renderChain,
            close: props.onClose
          })
        }), (0, import_jsx_runtime.jsx)($69cb30bb0017df05$export$7c6e2c02157bb7d2, {
          className: "TabsContent",
          value: "mainnet",
          children: (0, import_jsx_runtime.jsx)(NetworkTab, {
            allChains,
            type: "mainnet",
            popularChains,
            recentChains,
            onSwitch: handleSwitch,
            renderChain: props.renderChain,
            close: props.onClose
          })
        }), (0, import_jsx_runtime.jsx)($69cb30bb0017df05$export$7c6e2c02157bb7d2, {
          className: "TabsContent",
          value: "testnet",
          children: (0, import_jsx_runtime.jsx)(NetworkTab, {
            allChains,
            type: "testnet",
            popularChains,
            recentChains,
            onSwitch: handleSwitch,
            renderChain: props.renderChain,
            close: props.onClose
          })
        }), onCustomClick && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
          children: [(0, import_jsx_runtime.jsx)(Spacer, {
            y: "sm"
          }), (0, import_jsx_runtime.jsx)(Button, {
            variant: "link",
            onClick: () => {
              onCustomClick();
              if (onClose) {
                onClose();
              }
            },
            style: {
              display: "flex",
              width: "100%",
              fontSize: fontSize.sm,
              boxShadow: "none"
            },
            children: "Add Custom Network"
          })]
        })]
      })]
    })
  });
};
var filterChainByType = (chains, type) => {
  if (type === "all") {
    return chains;
  }
  if (type === "testnet") {
    return chains.filter((c) => c.testnet);
  }
  return chains.filter((c) => !c.testnet);
};
var NetworkTab = (props) => {
  const allChains = (0, import_react14.useMemo)(() => filterChainByType(props.allChains, props.type), [props.type, props.allChains]);
  const recentChains = (0, import_react14.useMemo)(() => filterChainByType(props.recentChains || [], props.type), [props.type, props.recentChains]);
  const popularChains = (0, import_react14.useMemo)(() => filterChainByType(props.popularChains || [], props.type), [props.type, props.popularChains]);
  return (0, import_jsx_runtime.jsxs)(ScrollContainer, {
    style: {
      height: "330px"
    },
    children: [recentChains.length > 0 && (0, import_jsx_runtime.jsxs)("div", {
      children: [(0, import_jsx_runtime.jsx)(SectionLabel, {
        children: "Recently Used"
      }), (0, import_jsx_runtime.jsx)(Spacer, {
        y: "sm"
      }), (0, import_jsx_runtime.jsx)(NetworkList, {
        chains: recentChains,
        onSwitch: props.onSwitch,
        renderChain: props.renderChain,
        close: props.close
      }), (0, import_jsx_runtime.jsx)(Spacer, {
        y: "lg"
      })]
    }), popularChains.length > 0 && (0, import_jsx_runtime.jsxs)("div", {
      children: [(0, import_jsx_runtime.jsx)(SectionLabel, {
        children: "Popular"
      }), (0, import_jsx_runtime.jsx)(Spacer, {
        y: "sm"
      }), (0, import_jsx_runtime.jsx)(NetworkList, {
        chains: popularChains,
        onSwitch: props.onSwitch,
        renderChain: props.renderChain,
        close: props.close
      }), (0, import_jsx_runtime.jsx)(Spacer, {
        y: "lg"
      })]
    }), (popularChains.length > 0 || recentChains.length > 0) && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
      children: [(0, import_jsx_runtime.jsx)(SectionLabel, {
        children: "All Networks"
      }), (0, import_jsx_runtime.jsx)(Spacer, {
        y: "sm"
      })]
    }), (0, import_jsx_runtime.jsx)(NetworkList, {
      chains: allChains,
      onSwitch: props.onSwitch,
      renderChain: props.renderChain,
      close: props.close
    })]
  });
};
var NetworkList = (0, import_react14.memo)(function NetworkList2(props) {
  const switchChain = useSwitchChain();
  const activeChainId = useChainId();
  const [switchingChainId, setSwitchingChainId] = (0, import_react14.useState)(-1);
  const [errorSwitchingChainId, setErrorSwitchingChainId] = (0, import_react14.useState)(-1);
  const handleSwitch = async (chain) => {
    setErrorSwitchingChainId(-1);
    setSwitchingChainId(chain.chainId);
    try {
      await switchChain(chain.chainId);
      props.onSwitch(chain);
    } catch (e) {
      setErrorSwitchingChainId(chain.chainId);
      console.error(e);
    } finally {
      setSwitchingChainId(-1);
    }
  };
  const RenderChain = props.renderChain;
  const [isLoading, setIsLoading] = (0, import_react14.useState)(props.chains.length > 100);
  (0, import_react14.useEffect)(() => {
    if (isLoading) {
      setIsLoading(false);
    }
  }, [isLoading]);
  if (isLoading) {
    return (0, import_jsx_runtime.jsx)(Flex, {
      justifyContent: "center",
      alignItems: "center",
      style: {
        height: "250px"
      },
      children: (0, import_jsx_runtime.jsx)(SecondaryText, {
        children: "Loading"
      })
    });
  }
  return (0, import_jsx_runtime.jsx)(NetworkListUl, {
    children: props.chains.map((chain) => {
      const confirming = switchingChainId === chain.chainId;
      const switchingFailed = errorSwitchingChainId === chain.chainId;
      const chainName = (0, import_jsx_runtime.jsxs)("span", {
        children: [chain.name, " "]
      });
      if (RenderChain) {
        return (0, import_jsx_runtime.jsx)("li", {
          children: (0, import_jsx_runtime.jsx)(RenderChain, {
            switchChain: () => {
              handleSwitch(chain);
            },
            chain,
            switching: switchingChainId === chain.chainId,
            switchFailed: errorSwitchingChainId === chain.chainId,
            close: props.close
          })
        }, chain.chainId);
      }
      return (0, import_jsx_runtime.jsx)("li", {
        children: (0, import_jsx_runtime.jsxs)(NetworkButton, {
          "data-active": activeChainId === chain.chainId,
          onClick: () => {
            handleSwitch(chain);
          },
          children: [(0, import_jsx_runtime.jsx)(ChainIcon, {
            chain,
            size: iconSize.lg,
            active: activeChainId === chain.chainId,
            loading: "lazy"
          }), confirming || switchingFailed ? (0, import_jsx_runtime.jsxs)("div", {
            style: {
              display: "flex",
              flexDirection: "column",
              gap: spacing.xs
            },
            children: [chainName, (0, import_jsx_runtime.jsxs)("div", {
              style: {
                display: "flex",
                gap: spacing.xs
              },
              children: [confirming && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
                children: [(0, import_jsx_runtime.jsx)(ConfirmMessage, {
                  children: "Confirm in Wallet"
                }), (0, import_jsx_runtime.jsx)(Spinner, {
                  size: "sm",
                  color: "link"
                })]
              }), switchingFailed && (0, import_jsx_runtime.jsx)(ErrorMessage2, {
                children: "Error: Could not Switch Network"
              })]
            })]
          }) : chainName]
        })
      }, chain.chainId);
    })
  });
});
var TabButton = newStyled($69cb30bb0017df05$export$41fb9f06171c75f4)`
  all: unset;
  font-size: ${fontSize.md};
  font-weight: 500;
  color: ${(p) => p.theme.text.secondary};
  cursor: pointer;
  padding: ${spacing.sm} ${spacing.sm};
  -webkit-tap-highlight-color: transparent;
  border-radius: ${radius.lg};
  transition: background 0.2s ease, color 0.2s ease;
  &[data-state="active"] {
    background: ${(p) => p.theme.bg.elevated};
    color: ${(p) => p.theme.text.neutral};
  }
`;
var SectionLabel = newStyled.p`
  font-size: ${fontSize.sm};
  color: ${(p) => p.theme.text.secondary};
  margin: 0;
`;
var ScrollContainer = newStyled.div`
  box-sizing: border-box;
  overflow: auto;
  padding-right: 10px;
  padding-bottom: ${spacing.lg};
  width: calc(100% + 16px);
  -webkit-mask-image: linear-gradient(to bottom, black 90%, transparent 100%);
  mask-image: linear-gradient(to bottom, black 90%, transparent 100%);
  ${(p) => scrollbar({
  track: "transparent",
  thumb: p.theme.bg.elevated,
  hover: p.theme.bg.highlighted
})}
`;
var NetworkListUl = newStyled.ul`
  padding: 0;
  margin: 0;
  list-style: none;
  display: flex;
  flex-direction: column;
  gap: ${spacing.xs};
  box-sizing: border-box;
`;
var NetworkButton = newStyled.button`
  all: unset;
  display: flex;
  width: 100%;
  box-sizing: border-box;
  align-items: center;
  gap: ${spacing.md};
  padding: ${spacing.sm} ${spacing.md};
  border-radius: ${radius.md};
  cursor: pointer;
  transition: background 0.2s ease;
  background: ${(p) => p.theme.bg.elevated};
  color: ${(p) => p.theme.text.neutral};
  font-weight: 600;
  font-size: ${fontSize.md};
  &:hover {
    background: ${(p) => p.theme.bg.highlighted};
  }

  ${media.mobile} {
    font-size: ${fontSize.sm};
  }
`;
var StyledMagnifyingGlassIcon = newStyled(MagnifyingGlassIcon)`
  color: ${(p) => p.theme.text.secondary};
  position: absolute;
  left: 18px;
`;
var SearchInput = newStyled(Input)`
  padding: ${spacing.sm} ${spacing.md} ${spacing.sm} 60px;
`;
var ConfirmMessage = newStyled.div`
  font-size: ${fontSize.sm};
  color: ${(p) => p.theme.link.primary};
`;
var ErrorMessage2 = newStyled.div`
  font-size: ${fontSize.sm};
  color: ${(p) => p.theme.text.danger};
`;
var ExitIcon = (_ref) => {
  let {
    size: size2
  } = _ref;
  return (0, import_jsx_runtime.jsx)("svg", {
    width: size2,
    height: size2,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: (0, import_jsx_runtime.jsx)("path", {
      fill: "currentColor",
      d: "M10.79 16.29C11.18 16.68 11.81 16.68 12.2 16.29L15.79 12.7C15.8827 12.6075 15.9563 12.4976 16.0064 12.3766C16.0566 12.2557 16.0824 12.126 16.0824 11.995C16.0824 11.864 16.0566 11.7343 16.0064 11.6134C15.9563 11.4924 15.8827 11.3825 15.79 11.29L12.2 7.7C12.013 7.51302 11.7594 7.40798 11.495 7.40798C11.2306 7.40798 10.977 7.51302 10.79 7.7C10.603 7.88698 10.498 8.14057 10.498 8.405C10.498 8.66943 10.603 8.92302 10.79 9.11L12.67 11H4C3.45 11 3 11.45 3 12C3 12.55 3.45 13 4 13H12.67L10.79 14.88C10.4 15.27 10.41 15.91 10.79 16.29ZM19 3H5C4.46957 3 3.96086 3.21071 3.58579 3.58579C3.21071 3.96086 3 4.46957 3 5V8C3 8.55 3.45 9 4 9C4.55 9 5 8.55 5 8V6C5 5.45 5.45 5 6 5H18C18.55 5 19 5.45 19 6V18C19 18.55 18.55 19 18 19H6C5.45 19 5 18.55 5 18V16C5 15.45 4.55 15 4 15C3.45 15 3 15.45 3 16V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3Z"
    })
  });
};
var FundsIcon = (_ref) => {
  let {
    size: size2
  } = _ref;
  return (0, import_jsx_runtime.jsxs)("svg", {
    width: size2,
    height: size2,
    viewBox: "0 0 12 12",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: [(0, import_jsx_runtime.jsx)("circle", {
      cx: "6",
      cy: "6",
      r: "5.335",
      stroke: "currentColor",
      strokeWidth: "1.33"
    }), (0, import_jsx_runtime.jsx)("path", {
      fill: "currentColor",
      d: "M5.85378 8.54545V3.09091H6.20321V8.54545H5.85378ZM6.78063 4.89134C6.76358 4.71946 6.69043 4.58594 6.56117 4.49077C6.43191 4.3956 6.25648 4.34801 6.03489 4.34801C5.88432 4.34801 5.75719 4.36932 5.6535 4.41193C5.5498 4.45312 5.47026 4.51065 5.41486 4.58452C5.36088 4.65838 5.3339 4.74219 5.3339 4.83594C5.33105 4.91406 5.34739 4.98224 5.3829 5.04048C5.41983 5.09872 5.47026 5.14915 5.53418 5.19176C5.5981 5.23295 5.67196 5.26918 5.75577 5.30043C5.83958 5.33026 5.92907 5.35582 6.02424 5.37713L6.41628 5.47088C6.60662 5.51349 6.78134 5.57031 6.94043 5.64134C7.09952 5.71236 7.2373 5.79972 7.35378 5.90341C7.47026 6.0071 7.56046 6.12926 7.62438 6.26989C7.68972 6.41051 7.7231 6.57173 7.72452 6.75355C7.7231 7.0206 7.65492 7.25213 7.51998 7.44815C7.38645 7.64276 7.19327 7.79403 6.94043 7.90199C6.68901 8.00852 6.38574 8.06179 6.03063 8.06179C5.67836 8.06179 5.37154 8.00781 5.11017 7.89986C4.85023 7.7919 4.64711 7.6321 4.5008 7.42045C4.35591 7.20739 4.27992 6.94389 4.27282 6.62997H5.16557C5.17551 6.77628 5.21742 6.89844 5.29128 6.99645C5.36657 7.09304 5.46671 7.16619 5.59171 7.21591C5.71813 7.2642 5.86088 7.28835 6.01998 7.28835C6.17623 7.28835 6.31188 7.26562 6.42694 7.22017C6.54341 7.17472 6.63361 7.11151 6.69753 7.03054C6.76145 6.94957 6.79341 6.85653 6.79341 6.75142C6.79341 6.65341 6.76429 6.57102 6.70605 6.50426C6.64924 6.4375 6.56543 6.38068 6.45463 6.33381C6.34526 6.28693 6.21103 6.24432 6.05194 6.20597L5.57679 6.08665C5.2089 5.99716 4.91841 5.85724 4.70534 5.6669C4.49228 5.47656 4.38645 5.22017 4.38787 4.89773C4.38645 4.63352 4.45676 4.4027 4.59881 4.20526C4.74228 4.00781 4.93901 3.85369 5.18901 3.7429C5.43901 3.6321 5.7231 3.5767 6.04128 3.5767C6.36515 3.5767 6.64782 3.6321 6.88929 3.7429C7.13219 3.85369 7.32111 4.00781 7.45605 4.20526C7.591 4.4027 7.6606 4.63139 7.66486 4.89134H6.78063Z"
    })]
  });
};
var TW_CONNECTED_WALLET = "tw-connected-wallet";
var ConnectedWalletDetails = (props) => {
  var _a, _b, _c;
  const disconnect = useDisconnect();
  const chains = useSupportedChains();
  const walletChainId = useChainId();
  const address = useAddress();
  const balanceQuery = useBalance();
  const activeWallet = useWallet();
  const activeWalletConfig = useWalletConfig();
  const [showExportModal, setShowExportModal] = (0, import_react14.useState)(false);
  const [wrapperWallet, setWrapperWallet] = (0, import_react14.useState)();
  const walletContext = useWalletContext();
  const chain = useChain();
  const activeWalletIconURL = (activeWalletConfig == null ? void 0 : activeWalletConfig.meta.iconURL) || "";
  const [showNetworkSelector, setShowNetworkSelector] = (0, import_react14.useState)(false);
  const [open, setOpen] = (0, import_react14.useState)(false);
  const sdk = useSDK();
  const personalWallet = activeWallet == null ? void 0 : activeWallet.getPersonalWallet();
  const personalWalletConfig = personalWallet && walletContext.getWalletConfig(personalWallet);
  const wrapperWalletConfig = wrapperWallet && walletContext.getWalletConfig(wrapperWallet);
  const disableSwitchChain = !!personalWallet;
  const trigger = props.detailsBtn ? (0, import_jsx_runtime.jsx)("div", {
    children: (0, import_jsx_runtime.jsx)(props.detailsBtn, {})
  }) : (0, import_jsx_runtime.jsxs)(WalletInfoButton, {
    type: "button",
    className: `${TW_CONNECTED_WALLET} ${props.className || ""}`,
    "data-theme": props.theme,
    style: props.style,
    "data-test": "connected-wallet-details",
    children: [(0, import_jsx_runtime.jsx)(ChainIcon, {
      chain,
      size: iconSize.lg,
      className: `${TW_CONNECTED_WALLET}__network-icon`
    }), (0, import_jsx_runtime.jsxs)(ColFlex, {
      children: [balanceQuery.data ? (0, import_jsx_runtime.jsxs)(WalletBalance, {
        className: `${TW_CONNECTED_WALLET}__balance`,
        children: [Number(balanceQuery.data.displayValue).toFixed(3), " ", balanceQuery.data.symbol]
      }) : (0, import_jsx_runtime.jsx)(Skeleton, {
        height: fontSize.sm,
        width: "82px"
      }), (0, import_jsx_runtime.jsx)(Spacer, {
        y: "xs"
      }), (activeWallet == null ? void 0 : activeWallet.walletId) === walletIds.localWallet ? (0, import_jsx_runtime.jsx)(ErrorMessage, {
        style: {
          lineHeight: 1,
          minWidth: "70px",
          fontSize: fontSize.xs
        },
        children: "Guest"
      }) : address ? (0, import_jsx_runtime.jsx)(WalletAddress, {
        className: `${TW_CONNECTED_WALLET}__address`,
        children: shortenString(address || "")
      }) : (0, import_jsx_runtime.jsx)(Skeleton, {
        height: fontSize.xs,
        width: "88px"
      })]
    }), (0, import_jsx_runtime.jsx)(Img, {
      width: iconSize.lg,
      height: iconSize.lg,
      src: activeWalletIconURL,
      className: `${TW_CONNECTED_WALLET}__wallet-icon`
    })]
  });
  const networkSwitcherButton = (0, import_jsx_runtime.jsx)(ToolTip, {
    tip: disableSwitchChain ? "Network Switching is disabled" : "Switch Network",
    children: (0, import_jsx_runtime.jsxs)(MenuButton, {
      type: "button",
      disabled: disableSwitchChain,
      onClick: () => {
        setOpen(false);
        setShowNetworkSelector(true);
      },
      children: [(0, import_jsx_runtime.jsx)("div", {
        style: {
          display: "flex",
          alignItems: "center",
          position: "relative"
        },
        children: (0, import_jsx_runtime.jsx)(ChainIcon, {
          chain,
          size: iconSize.lg,
          active: true
        })
      }), (chain == null ? void 0 : chain.name) || `Unknown chain #${walletChainId}`, (0, import_jsx_runtime.jsx)(StyledChevronRightIcon, {
        width: iconSize.sm,
        height: iconSize.sm,
        style: {
          flexShrink: 0,
          marginLeft: "auto"
        }
      })]
    })
  });
  const content = (0, import_jsx_runtime.jsxs)("div", {
    children: [(0, import_jsx_runtime.jsxs)(Flex, {
      gap: "md",
      children: [(0, import_jsx_runtime.jsx)(Img, {
        width: iconSize.xl,
        height: iconSize.xl,
        src: activeWalletIconURL,
        alt: ""
      }), (0, import_jsx_runtime.jsxs)("div", {
        style: {
          flexGrow: 1
        },
        children: [(0, import_jsx_runtime.jsxs)(Flex, {
          gap: "xs",
          alignItems: "center",
          children: [(0, import_jsx_runtime.jsxs)("div", {
            style: {
              display: "flex",
              gap: spacing.xs,
              alignItems: "center"
            },
            "data-test": "connected-wallet-address",
            "data-address": address,
            children: [(0, import_jsx_runtime.jsxs)(AccountAddress, {
              children: [" ", shortenString(address || "")]
            }), (0, import_jsx_runtime.jsx)(IconButton, {
              variant: "secondary",
              style: {
                padding: "3px"
              },
              "data-test": "copy-address",
              children: (0, import_jsx_runtime.jsx)(CopyIcon2, {
                text: address || "",
                tip: "Copy Address",
                side: "bottom"
              })
            })]
          }), (0, import_jsx_runtime.jsx)(ToolTip, {
            tip: "Disconnect Wallet",
            side: "bottom",
            align: "end",
            sideOffset: 10,
            children: (0, import_jsx_runtime.jsx)(DisconnectIconButton, {
              type: "button",
              variant: "secondary",
              onClick: () => {
                disconnect();
                props.onDisconnect();
              },
              children: (0, import_jsx_runtime.jsx)(ExitIcon, {
                size: iconSize.md
              })
            })
          })]
        }), (0, import_jsx_runtime.jsxs)(AccountBalance, {
          children: [" ", balanceQuery.data ? Number(balanceQuery.data.displayValue).toFixed(3) : (0, import_jsx_runtime.jsx)(Skeleton, {
            height: "1em",
            width: "100px"
          }), " ", (_a = balanceQuery.data) == null ? void 0 : _a.symbol, " "]
        })]
      })]
    }), (0, import_jsx_runtime.jsx)(Spacer, {
      y: "lg"
    }), (0, import_jsx_runtime.jsxs)("div", {
      children: [(0, import_jsx_runtime.jsx)(DropdownLabel, {
        children: "Current Network"
      }), (0, import_jsx_runtime.jsx)(Spacer, {
        y: "xs"
      }), networkSwitcherButton]
    }), (0, import_jsx_runtime.jsx)(Spacer, {
      y: "md"
    }), (0, import_jsx_runtime.jsxs)(Flex, {
      flexDirection: "column",
      gap: "sm",
      children: [personalWallet && personalWalletConfig && (0, import_jsx_runtime.jsx)(WalletSwitcher, {
        wallet: personalWallet,
        name: "Personal Wallet",
        onSwitch: () => {
          setWrapperWallet(activeWallet);
        }
      }), wrapperWalletConfig && wrapperWallet && (0, import_jsx_runtime.jsx)(WalletSwitcher, {
        name: wrapperWalletConfig.meta.name,
        wallet: wrapperWallet,
        onSwitch: () => {
          setWrapperWallet(void 0);
        }
      }), activeWalletConfig && activeWalletConfig.id === walletIds.metamask && activeWalletConfig.isInstalled && activeWalletConfig.isInstalled() && (0, import_jsx_runtime.jsxs)(MenuButton, {
        type: "button",
        onClick: () => {
          activeWallet.switchAccount();
          setOpen(false);
        },
        style: {
          fontSize: fontSize.sm
        },
        children: [(0, import_jsx_runtime.jsx)(ShuffleIcon, {
          width: iconSize.sm,
          height: iconSize.sm
        }), "Switch Account"]
      }), ((chain == null ? void 0 : chain.faucets) && chain.faucets.length > 0 || (chain == null ? void 0 : chain.chainId) === c1337.chainId) && (0, import_jsx_runtime.jsxs)(MenuLink, {
        href: (chain == null ? void 0 : chain.faucets) ? chain.faucets[0] : "#",
        target: "_blank",
        as: "a",
        onClick: async (e) => {
          if (chain.chainId === c1337.chainId) {
            e.preventDefault();
            setOpen(false);
            await (sdk == null ? void 0 : sdk.wallet.requestFunds(10));
            await balanceQuery.refetch();
          }
        },
        style: {
          textDecoration: "none",
          color: "inherit",
          fontSize: fontSize.sm
        },
        children: [(0, import_jsx_runtime.jsx)(SecondaryIconContainer, {
          children: (0, import_jsx_runtime.jsx)(FundsIcon, {
            size: iconSize.sm
          })
        }), "Request Testnet Funds"]
      }), (activeWallet == null ? void 0 : activeWallet.walletId) === walletIds.localWallet && (0, import_jsx_runtime.jsxs)("div", {
        children: [(0, import_jsx_runtime.jsxs)(MenuButton, {
          onClick: () => {
            setShowExportModal(true);
            setOpen(false);
          },
          style: {
            fontSize: fontSize.sm
          },
          children: [(0, import_jsx_runtime.jsx)(SecondaryIconContainer, {
            children: (0, import_jsx_runtime.jsx)(PinBottomIcon, {
              width: iconSize.sm,
              height: iconSize.sm
            })
          }), "Backup wallet", " "]
        }), (0, import_jsx_runtime.jsx)(Spacer, {
          y: "sm"
        }), (0, import_jsx_runtime.jsxs)(ErrorMessage, {
          style: {
            fontSize: fontSize.xs,
            textAlign: "center"
          },
          children: ["This is a temporary guest wallet ", (0, import_jsx_runtime.jsx)("br", {}), "Backup if you ", `don't `, "want to lose access to it"]
        })]
      })]
    })]
  });
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
    children: [isMobile() ? (0, import_jsx_runtime.jsx)(Modal, {
      trigger,
      open,
      setOpen,
      hideCloseIcon: true,
      children: (0, import_jsx_runtime.jsx)("div", {
        style: {
          minHeight: "200px"
        },
        children: content
      })
    }) : (0, import_jsx_runtime.jsxs)($d08ef79370b62062$export$be92b6f5f03c0fe9, {
      open,
      onOpenChange: setOpen,
      children: [(0, import_jsx_runtime.jsx)($d08ef79370b62062$export$41fb9f06171c75f4, {
        asChild: true,
        children: trigger
      }), (0, import_jsx_runtime.jsx)($d08ef79370b62062$export$602eac185826482c, {
        children: (0, import_jsx_runtime.jsx)(DropDownContent, {
          asChild: true,
          side: ((_b = props.dropdownPosition) == null ? void 0 : _b.side) || "bottom",
          align: ((_c = props.dropdownPosition) == null ? void 0 : _c.align) || "end",
          sideOffset: 10,
          children: content
        })
      })]
    }), showNetworkSelector && (0, import_jsx_runtime.jsx)(NetworkSelector, {
      theme: props.theme,
      chains,
      ...props.networkSelector,
      onClose: () => setShowNetworkSelector(false)
    }), showExportModal && (0, import_jsx_runtime.jsx)(Modal, {
      open: true,
      setOpen: setShowExportModal,
      style: {
        maxWidth: "480px"
      },
      children: (0, import_jsx_runtime.jsx)(ExportLocalWallet, {
        localWalletConfig: activeWalletConfig,
        onBack: () => {
          setShowExportModal(false);
        },
        onExport: () => {
          setShowExportModal(false);
        }
      })
    })]
  });
};
var dropdownContentFade = keyframes`
  from {
    opacity: 0;
    transform: scale(0.95);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
`;
var DropDownContent = newStyled($d08ef79370b62062$export$7c6e2c02157bb7d2)`
  width: 360px;
  box-sizing: border-box;
  max-width: 100%;
  border-radius: ${radius.lg};
  padding: ${spacing.lg};
  animation: ${dropdownContentFade} 400ms cubic-bezier(0.16, 1, 0.3, 1);
  will-change: transform, opacity;
  border: 1px solid ${(props) => props.theme.border.base};
  background-color: ${(props) => props.theme.bg.base};
  z-index: 1000000;
  line-height: 1;
`;
var WalletInfoButton = newStyled.button`
  all: unset;
  background: ${(props) => props.theme.bg.base};
  border: 1px solid ${(props) => props.theme.border.base};
  padding: ${spacing.sm} ${spacing.sm};
  border-radius: ${radius.lg};
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  gap: ${spacing.md};
  box-sizing: border-box;
  -webkit-tap-highlight-color: transparent;
  line-height: 1;
  animation: ${fadeInAnimation} 300ms ease;

  ${media.mobile} {
    gap: ${spacing.sm};
    padding: ${spacing.xs} ${spacing.sm};
    img {
      width: ${iconSize.md}px;
      height: ${iconSize.md}px;
    }
  }

  &:hover {
    transition: background 250ms ease;
    background: ${(props) => props.theme.bg.baseHover};
    border-color: ${(props) => props.theme.bg.highlighted};
  }
`;
var WalletAddress = newStyled.span`
  color: ${(props) => props.theme.text.secondary};
  font-size: ${fontSize.xs};
  font-weight: 500;
`;
var ColFlex = newStyled.div`
  display: flex;
  flex-direction: column;
`;
var WalletBalance = newStyled.span`
  color: ${(props) => props.theme.text.neutral};
  font-size: ${fontSize.sm};
  font-weight: 500;
`;
var AccountAddress = newStyled.span`
  font-size: ${fontSize.md};
  color: ${(props) => props.theme.text.neutral};
  font-weight: 500;
`;
var AccountBalance = newStyled.span`
  font-size: ${fontSize.sm};
  color: ${(props) => props.theme.text.secondary};
  font-weight: 500;
`;
var DropdownLabel = newStyled.label`
  font-size: ${fontSize.sm};
  color: ${(props) => props.theme.text.secondary};
  font-weight: 500;
`;
var MenuButton = newStyled.button`
  all: unset;
  padding: ${spacing.sm} ${spacing.sm};
  border-radius: ${radius.md};
  background-color: ${(props) => props.theme.bg.base};
  border: 1px solid ${(props) => props.theme.border.elevated};
  box-sizing: border-box;
  display: flex;
  align-items: center;
  width: 100%;
  cursor: pointer;
  font-size: ${fontSize.md};
  font-weight: 500;
  color: ${(props) => props.theme.text.neutral} !important;
  gap: ${spacing.sm};
  -webkit-tap-highlight-color: transparent;
  line-height: 1.3;

  &:not([disabled]):hover {
    transition: box-shadow 250ms ease, border-color 250ms ease;
    border: 1px solid ${(props) => props.theme.link.primary};
    box-shadow: 0 0 0 1px ${(props) => props.theme.link.primary};
  }

  &[disabled] {
    cursor: not-allowed;
    svg {
      display: none;
    }
  }

  &[disabled]:hover {
    transition: box-shadow 250ms ease, border-color 250ms ease;
    border: 1px solid ${(props) => props.theme.text.danger};
    box-shadow: 0 0 0 1px ${(props) => props.theme.text.danger};
  }
`;
var MenuLink = MenuButton.withComponent("a");
newStyled($d08ef79370b62062$export$6d08773d2e66f8f2)`
  outline: none;
`;
var StyledChevronRightIcon = newStyled(ChevronRightIcon)`
  color: ${(props) => props.theme.text.secondary};
`;
var DisconnectIconButton = newStyled(IconButton)`
  margin-right: -${spacing.xxs};
  margin-left: auto;
  color: ${(props) => props.theme.icon.secondary};
  &:hover {
    color: ${(props) => props.theme.icon.danger};
    background: none;
  }
`;
var SecondaryIconContainer = newStyled.div`
  display: flex;
  align-items: center;
  justify-content: center;
  color: ${(props) => props.theme.icon.secondary};
`;
function WalletSwitcher(_ref) {
  let {
    wallet,
    onSwitch,
    name
  } = _ref;
  const walletContext = useWalletContext();
  return (0, import_jsx_runtime.jsxs)(MenuButton, {
    type: "button",
    onClick: () => {
      walletContext.setConnectedWallet(wallet);
      onSwitch();
    },
    style: {
      fontSize: fontSize.sm
    },
    children: [(0, import_jsx_runtime.jsx)(EnterIcon, {
      width: iconSize.sm,
      height: iconSize.sm
    }), "Switch to ", name]
  });
}
var LockIcon = (props) => {
  return (0, import_jsx_runtime.jsx)("svg", {
    width: props.size,
    height: props.size,
    viewBox: "0 0 16 21",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M2 21C1.45 21 0.979333 20.8043 0.588 20.413C0.196 20.021 0 19.55 0 19V9C0 8.45 0.196 7.979 0.588 7.587C0.979333 7.19567 1.45 7 2 7H3V5C3 3.61667 3.48767 2.43733 4.463 1.462C5.43767 0.487333 6.61667 0 8 0C9.38333 0 10.5627 0.487333 11.538 1.462C12.5127 2.43733 13 3.61667 13 5V7H14C14.55 7 15.021 7.19567 15.413 7.587C15.8043 7.979 16 8.45 16 9V19C16 19.55 15.8043 20.021 15.413 20.413C15.021 20.8043 14.55 21 14 21H2ZM8 16C8.55 16 9.021 15.8043 9.413 15.413C9.80433 15.021 10 14.55 10 14C10 13.45 9.80433 12.979 9.413 12.587C9.021 12.1957 8.55 12 8 12C7.45 12 6.97933 12.1957 6.588 12.587C6.196 12.979 6 13.45 6 14C6 14.55 6.196 15.021 6.588 15.413C6.97933 15.8043 7.45 16 8 16ZM5 7H11V5C11 4.16667 10.7083 3.45833 10.125 2.875C9.54167 2.29167 8.83333 2 8 2C7.16667 2 6.45833 2.29167 5.875 2.875C5.29167 3.45833 5 4.16667 5 5V7Z",
      fill: "currentColor"
    })
  });
};
var SignatureModal = (props) => {
  const walletConfig = useWalletConfig();
  return (0, import_jsx_runtime.jsx)(Modal, {
    open: props.open,
    style: {
      maxWidth: "450px"
    },
    setOpen: props.setOpen,
    children: (0, import_jsx_runtime.jsxs)(Container, {
      children: [walletConfig && (0, import_jsx_runtime.jsx)(Img, {
        height: iconSize.xl,
        src: walletConfig.meta.iconURL,
        width: iconSize.xl
      }), (0, import_jsx_runtime.jsx)(Spacer, {
        y: "xl"
      }), (0, import_jsx_runtime.jsxs)(TitleContainer, {
        children: [(0, import_jsx_runtime.jsx)(ModalTitle, {
          children: "Signature Request"
        }), (0, import_jsx_runtime.jsx)(Spinner, {
          size: "md",
          color: "link"
        })]
      }), (0, import_jsx_runtime.jsx)(Spacer, {
        y: "md"
      }), (0, import_jsx_runtime.jsx)(Desc, {
        children: "Sign the signature request pop-up in your wallet"
      }), (0, import_jsx_runtime.jsx)(Spacer, {
        y: "xxl"
      }), (0, import_jsx_runtime.jsx)(HelperLink, {
        target: "_blank",
        href: "https://support.thirdweb.com/contact",
        children: "Having troubles connecting to wallet"
      })]
    })
  });
};
var TitleContainer = newStyled.div`
  display: flex;
  align-items: center;
  gap: ${spacing.sm};

  ${media.mobile} {
    justify-content: center;
    flex-direction: column;
    gap: ${spacing.md};
  }
`;
var Desc = newStyled(ModalDescription)`
  ${media.mobile} {
    max-width: 240px;
    margin: 0 auto;
  }
`;
var Container = newStyled.div`
  ${media.mobile} {
    display: flex;
    flex-direction: column;
    align-items: center;
  }
`;
var TW_CONNECT_WALLET = "tw-connect-wallet";
var ConnectWallet = (props) => {
  var _a;
  const activeWallet = useWallet();
  const themeFromProvider = (0, import_react14.useContext)(ThirdwebThemeContext);
  const theme = props.theme || themeFromProvider || "dark";
  const connectionStatus = useConnectionStatus();
  const isLoading = connectionStatus === "connecting" || connectionStatus === "unknown";
  const btnTitle = props.btnTitle || "Connect Wallet";
  const setIsWalletModalOpen = useSetIsWalletModalOpen();
  const setModalConfig = (0, import_react14.useContext)(SetModalConfigCtx);
  const address = useAddress();
  const [showSignatureModal, setShowSignatureModal] = (0, import_react14.useState)(false);
  const authConfig = useThirdwebAuthContext();
  const {
    user
  } = useUser();
  const {
    login
  } = useLogin();
  const {
    logout
  } = useLogout();
  const requiresSignIn = ((_a = props.auth) == null ? void 0 : _a.loginOptional) ? false : !!(authConfig == null ? void 0 : authConfig.authUrl) && !!address && !(user == null ? void 0 : user.address);
  const signIn = async () => {
    var _a2, _b;
    try {
      setShowSignatureModal(true);
      const token = await login();
      (_b = (_a2 = props == null ? void 0 : props.auth) == null ? void 0 : _a2.onLogin) == null ? void 0 : _b.call(_a2, token);
    } catch (err) {
      console.error("failed to log in", err);
    }
    setShowSignatureModal(false);
  };
  return (0, import_jsx_runtime.jsxs)(ThemeProvider, {
    theme: theme === "dark" ? darkTheme : lightTheme,
    children: [showSignatureModal && (0, import_jsx_runtime.jsx)(SignatureModal, {
      open: showSignatureModal,
      setOpen: setShowSignatureModal
    }), requiresSignIn && (0, import_jsx_runtime.jsxs)(Button, {
      variant: "inverted",
      onClick: signIn,
      "data-theme": theme,
      className: `${TW_CONNECT_WALLET}--sign-in ${props.className || ""}}`,
      style: props.style,
      children: [(0, import_jsx_runtime.jsxs)(Flex, {
        alignItems: "center",
        gap: "sm",
        style: {
          paddingRight: spacing.xs,
          borderRight: "1px solid",
          marginRight: spacing.xs
        },
        children: [(0, import_jsx_runtime.jsx)(LockIcon, {
          size: iconSize.sm
        }), (0, import_jsx_runtime.jsx)("span", {
          children: " Sign in "
        })]
      }), (0, import_jsx_runtime.jsx)("span", {
        children: shortenAddress(address || "", true)
      })]
    }), !requiresSignIn && (!activeWallet ? (0, import_jsx_runtime.jsx)(AnimatedButton, {
      disabled: isLoading,
      className: `${props.className || ""} ${TW_CONNECT_WALLET}`,
      "data-theme": theme,
      "data-is-loading": isLoading,
      variant: "inverted",
      type: "button",
      style: {
        minWidth: "140px",
        ...props.style
      },
      "aria-label": connectionStatus === "connecting" ? "Connecting" : btnTitle,
      onClick: () => {
        setModalConfig({
          title: props.modalTitle || "Choose your wallet",
          theme,
          data: void 0
        });
        setIsWalletModalOpen(true);
      },
      "data-test": "connect-wallet-button",
      children: isLoading ? (0, import_jsx_runtime.jsx)(Spinner, {
        size: "sm",
        color: "inverted"
      }) : btnTitle
    }) : (0, import_jsx_runtime.jsx)(ConnectedWalletDetails, {
      networkSelector: props.networkSelector,
      dropdownPosition: props.dropdownPosition,
      className: props.className,
      theme,
      style: props.style,
      detailsBtn: props.detailsBtn,
      onDisconnect: () => {
        var _a2, _b;
        if (authConfig == null ? void 0 : authConfig.authUrl) {
          logout();
          (_b = (_a2 = props == null ? void 0 : props.auth) == null ? void 0 : _a2.onLogout) == null ? void 0 : _b.call(_a2);
        }
      }
    }))]
  });
};
var AnimatedButton = newStyled(Button)`
  animation: ${fadeInAnimation} 300ms ease;
`;
var video;
function supportsVideoType(mimeType) {
  if (!mimeType || !mimeType.startsWith("video/")) {
    return "";
  }
  if (!video) {
    video = document.createElement("video");
  }
  return video.canPlayType(mimeType);
}
function shouldRenderVideoTag(mimeType) {
  return !!supportsVideoType(mimeType);
}
var audio;
function supportsAudioType(mimeType) {
  if (!mimeType || !mimeType.startsWith("audio/")) {
    return "";
  }
  if (!audio) {
    audio = document.createElement("audio");
  }
  return audio.canPlayType(mimeType);
}
function shouldRenderAudioTag(mimeType) {
  return !!supportsAudioType(mimeType);
}
function mergeRefs(refs) {
  return (value) => {
    refs.forEach((ref) => {
      if (typeof ref === "function") {
        ref(value);
      } else if (ref != null) {
        ref.current = value;
      }
    });
  };
}
var CarbonDocumentUnknown = (props) => {
  return (0, import_jsx_runtime.jsxs)("svg", {
    width: "1em",
    height: "1em",
    viewBox: "0 0 32 32",
    ...props,
    children: [(0, import_jsx_runtime.jsx)("circle", {
      cx: "9",
      cy: "28.5",
      r: "1.5",
      fill: "currentColor"
    }), (0, import_jsx_runtime.jsx)("path", {
      fill: "currentColor",
      d: "M10 25H8v-4h2a2 2 0 0 0 0-4H8a2.002 2.002 0 0 0-2 2v.5H4V19a4.005 4.005 0 0 1 4-4h2a4 4 0 0 1 0 8Z"
    }), (0, import_jsx_runtime.jsx)("path", {
      fill: "currentColor",
      d: "m27.7 9.3l-7-7A.908.908 0 0 0 20 2H10a2.006 2.006 0 0 0-2 2v8h2V4h8v6a2.006 2.006 0 0 0 2 2h6v16H14v2h12a2.006 2.006 0 0 0 2-2V10a.91.91 0 0 0-.3-.7ZM20 10V4.4l5.6 5.6Z"
    })]
  });
};
var CarbonDocumentAudio = (props) => {
  return (0, import_jsx_runtime.jsxs)("svg", {
    width: "1em",
    height: "1em",
    viewBox: "0 0 32 32",
    ...props,
    children: [(0, import_jsx_runtime.jsx)("path", {
      fill: "currentColor",
      d: "M29 31a.999.999 0 0 1-.625-.22L23.65 27H20a1 1 0 0 1-1-1v-5a1 1 0 0 1 1-1h3.65l4.726-3.78A1 1 0 0 1 30 17v13a1 1 0 0 1-1 1Zm-8-6h3a1 1 0 0 1 .625.22L28 27.92v-8.84l-3.376 2.7A1 1 0 0 1 24 22h-3Z"
    }), (0, import_jsx_runtime.jsx)("path", {
      fill: "currentColor",
      d: "M16 28H8V4h8v6a2.006 2.006 0 0 0 2 2h6v3h2v-5a.91.91 0 0 0-.3-.7l-7-7A.909.909 0 0 0 18 2H8a2.006 2.006 0 0 0-2 2v24a2.006 2.006 0 0 0 2 2h8Zm2-23.6l5.6 5.6H18Z"
    })]
  });
};
var CarbonPauseFilled = (props) => {
  return (0, import_jsx_runtime.jsx)("svg", {
    width: "1em",
    height: "1em",
    viewBox: "0 0 32 32",
    ...props,
    children: (0, import_jsx_runtime.jsx)("path", {
      fill: "currentColor",
      d: "M12 6h-2a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2zm10 0h-2a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2z"
    })
  });
};
var CarbonPlayFilledAlt = (props) => {
  return (0, import_jsx_runtime.jsx)("svg", {
    width: "1em",
    height: "1em",
    viewBox: "0 0 32 32",
    ...props,
    children: (0, import_jsx_runtime.jsx)("path", {
      fill: "currentColor",
      d: "M7 28a1 1 0 0 1-1-1V5a1 1 0 0 1 1.482-.876l20 11a1 1 0 0 1 0 1.752l-20 11A1 1 0 0 1 7 28Z"
    })
  });
};
var ModelViewer = (0, import_react14.lazy)(() => import("./ModelViewer-68c3eb38.browser.esm-A4N3ABER.js"));
var PlayButton = (_ref) => {
  let {
    onClick,
    isPlaying
  } = _ref;
  const [isHovering, setIsHovering] = (0, import_react14.useState)(false);
  const onMouseEnter = () => setIsHovering(true);
  const onMouseLeave = () => setIsHovering(false);
  const onMouseDown = () => setIsHovering(false);
  const onMouseUp = () => setIsHovering(true);
  return (0, import_jsx_runtime.jsx)("button", {
    style: {
      position: "absolute",
      bottom: 0,
      right: 0,
      transform: "translate(-25%, -25%)",
      maxWidth: "32px",
      width: "8%",
      minWidth: "24px",
      aspectRatio: "1",
      zIndex: 3,
      backgroundColor: "#fff",
      color: "rgb(138, 147, 155)",
      display: "grid",
      placeItems: "center",
      borderRadius: "50%",
      border: "1px solid rgb(229, 232, 235)",
      cursor: "pointer",
      ...isHovering ? {
        color: "rgb(53, 56, 64)",
        boxShadow: "rgb(4 17 29 / 25%) 0px 0px 8px 0px"
      } : {}
    },
    onClick,
    onMouseEnter,
    onMouseLeave,
    onMouseDown,
    onMouseUp,
    children: !isPlaying ? (0, import_jsx_runtime.jsx)(CarbonPlayFilledAlt, {
      style: {
        width: "66%",
        height: "66%"
      }
    }) : (0, import_jsx_runtime.jsx)(CarbonPauseFilled, {
      style: {
        width: "66%",
        height: "66%"
      }
    })
  });
};
var VideoPlayer = import_react14.default.forwardRef((_ref2, ref) => {
  let {
    src,
    alt,
    poster,
    requireInteraction,
    style,
    width,
    height,
    controls,
    ...restProps
  } = _ref2;
  const videoRef = (0, import_react14.useRef)(null);
  const [playing, setPlaying] = (0, import_react14.useState)(!requireInteraction);
  const [muted, setMuted] = (0, import_react14.useState)(true);
  (0, import_react14.useEffect)(() => {
    if (videoRef.current) {
      if (playing) {
        try {
          videoRef.current.play();
        } catch (err) {
          console.error("error playing video", err);
        }
      } else {
        try {
          videoRef.current.pause();
          videoRef.current.currentTime = 0;
        } catch (err) {
          console.error("error pausing video", err);
        }
      }
    }
  }, [playing]);
  return (0, import_jsx_runtime.jsxs)("div", {
    style: {
      position: "relative",
      ...style
    },
    ...restProps,
    children: [(0, import_jsx_runtime.jsx)("video", {
      ref: mergeRefs([videoRef, ref]),
      src: src != null ? src : void 0,
      poster: poster != null ? poster : void 0,
      loop: true,
      playsInline: true,
      controlsList: "nodownload",
      muted,
      preload: poster ? "metadata" : "auto",
      onCanPlay: () => {
        var _a;
        if (playing) {
          (_a = videoRef.current) == null ? void 0 : _a.play();
        }
      },
      width,
      height,
      controls,
      style: {
        height: "100%",
        width: "100%",
        objectFit: "contain",
        zIndex: 1,
        transition: "opacity .5s",
        opacity: !poster ? 1 : playing ? 1 : 0
      }
    }), poster && (0, import_jsx_runtime.jsx)("img", {
      src: poster,
      style: {
        objectFit: "contain",
        pointerEvents: "none",
        position: "absolute",
        width: "100%",
        height: "100%",
        zIndex: 2,
        transition: "opacity .5s",
        opacity: playing ? 0 : 1,
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
      },
      alt
    }), (0, import_jsx_runtime.jsx)(PlayButton, {
      onClick: () => {
        setPlaying((prev) => !prev);
        setMuted(false);
      },
      isPlaying: playing
    })]
  });
});
VideoPlayer.displayName = "VideoPlayer";
var AudioPlayer = import_react14.default.forwardRef((_ref3, ref) => {
  let {
    src,
    alt,
    poster,
    style,
    height,
    width,
    ...restProps
  } = _ref3;
  const audioRef = (0, import_react14.useRef)(null);
  const [playing, setPlaying] = (0, import_react14.useState)(false);
  const [muted, setMuted] = (0, import_react14.useState)(true);
  (0, import_react14.useEffect)(() => {
    if (audioRef.current) {
      if (playing) {
        audioRef.current.play();
      } else {
        audioRef.current.pause();
        audioRef.current.currentTime = 0;
      }
    }
  }, [playing]);
  return (0, import_jsx_runtime.jsxs)("div", {
    style: {
      position: "relative",
      ...style
    },
    ...restProps,
    children: [poster ? (0, import_jsx_runtime.jsx)("img", {
      height,
      width,
      src: poster,
      style: {
        height: "100%",
        width: "100%",
        pointerEvents: "none",
        objectFit: "contain"
      },
      alt
    }) : (0, import_jsx_runtime.jsx)("div", {
      style: {
        width: "100%",
        height: "100%",
        display: "grid",
        placeItems: "center",
        pointerEvents: "none",
        backgroundColor: "#fff",
        color: "rgb(138, 147, 155)"
      },
      children: (0, import_jsx_runtime.jsx)(CarbonDocumentAudio, {
        style: {
          height: "64px",
          width: "64px"
        }
      })
    }), (0, import_jsx_runtime.jsx)(PlayButton, {
      onClick: () => {
        setPlaying((prev) => !prev);
        setMuted(false);
      },
      isPlaying: playing
    }), (0, import_jsx_runtime.jsx)("audio", {
      ref: mergeRefs([audioRef, ref]),
      src: src != null ? src : void 0,
      loop: true,
      playsInline: true,
      muted,
      preload: "none",
      controlsList: "nodownload",
      style: {
        position: "absolute",
        opacity: 0,
        pointerEvents: "none",
        zIndex: -1,
        visibility: "hidden"
      }
    })]
  });
});
AudioPlayer.displayName = "AudioPlayer";
var IframePlayer = import_react14.default.forwardRef((_ref4, ref) => {
  let {
    src,
    alt,
    poster,
    requireInteraction,
    style,
    ...restProps
  } = _ref4;
  const [playing, setPlaying] = (0, import_react14.useState)(!requireInteraction);
  return (0, import_jsx_runtime.jsxs)("div", {
    style: {
      position: "relative",
      ...style
    },
    ...restProps,
    children: [(0, import_jsx_runtime.jsx)("iframe", {
      src: playing ? src != null ? src : void 0 : void 0,
      ref,
      style: {
        objectFit: "contain",
        zIndex: 1,
        height: "100%",
        width: "100%",
        transition: "opacity .5s",
        opacity: !poster ? 1 : playing ? 1 : 0
      },
      sandbox: "allow-scripts",
      allow: "accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
    }), poster && (0, import_jsx_runtime.jsx)("img", {
      src: poster,
      style: {
        objectFit: "contain",
        pointerEvents: "none",
        position: "absolute",
        width: "100%",
        height: "100%",
        zIndex: 2,
        transition: "opacity .5s",
        opacity: playing ? 0 : 1,
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
      },
      alt
    }), (0, import_jsx_runtime.jsx)(PlayButton, {
      onClick: () => {
        setPlaying((prev) => !prev);
      },
      isPlaying: playing
    })]
  });
});
IframePlayer.displayName = "IframePlayer";
var LinkPlayer = import_react14.default.forwardRef((_ref5, ref) => {
  let {
    src,
    alt,
    style,
    ...restProps
  } = _ref5;
  return (0, import_jsx_runtime.jsx)("div", {
    style: {
      position: "relative",
      ...style
    },
    ...restProps,
    children: (0, import_jsx_runtime.jsx)("div", {
      style: {
        width: "100%",
        height: "100%",
        display: "grid",
        placeItems: "center",
        backgroundColor: "#fff",
        color: "rgb(138, 147, 155)"
      },
      children: (0, import_jsx_runtime.jsxs)("div", {
        style: {
          display: "flex",
          flexDirection: "column",
          gap: "8px",
          alignItems: "center",
          flexWrap: "nowrap"
        },
        children: [(0, import_jsx_runtime.jsx)(CarbonDocumentUnknown, {
          style: {
            maxWidth: "128px",
            minWidth: "48px",
            width: "50%",
            aspectRatio: "1"
          }
        }), (0, import_jsx_runtime.jsx)("a", {
          rel: "noopener noreferrer",
          style: {
            textDecoration: "underline",
            color: "rgb(138, 147, 155)"
          },
          href: src != null ? src : void 0,
          target: "_blank",
          ref,
          children: alt || "File"
        })]
      })
    })
  });
});
LinkPlayer.displayName = "LinkPlayer";
var MediaRenderer = import_react14.default.forwardRef((_ref6, ref) => {
  let {
    src,
    poster,
    alt,
    gatewayUrl,
    requireInteraction = false,
    width = "300px",
    height = "300px",
    style,
    mimeType,
    ...restProps
  } = _ref6;
  const mergedStyle = {
    objectFit: "contain",
    width,
    height,
    ...style
  };
  const videoOrImageSrc = useResolvedMediaType(src != null ? src : void 0, mimeType, gatewayUrl);
  const possiblePosterSrc = useResolvedMediaType(poster != null ? poster : void 0, void 0, gatewayUrl);
  if (!videoOrImageSrc.mimeType) {
    return (0, import_jsx_runtime.jsx)("img", {
      style: mergedStyle,
      ...restProps,
      ref,
      alt
    });
  } else if (videoOrImageSrc.mimeType === "text/html") {
    return (0, import_jsx_runtime.jsx)(IframePlayer, {
      style: mergedStyle,
      src: videoOrImageSrc.url,
      poster: possiblePosterSrc.url,
      requireInteraction,
      ...restProps
    });
  } else if (videoOrImageSrc.mimeType.startsWith("model")) {
    return (0, import_jsx_runtime.jsx)(import_react14.Suspense, {
      fallback: poster ? (0, import_jsx_runtime.jsx)("img", {
        style: mergedStyle,
        src: poster,
        alt,
        ref,
        ...restProps
      }) : null,
      children: (0, import_jsx_runtime.jsx)(ModelViewer, {
        style: mergedStyle,
        src: videoOrImageSrc.url || "",
        poster,
        alt,
        ...restProps
      })
    });
  } else if (shouldRenderVideoTag(videoOrImageSrc.mimeType)) {
    return (0, import_jsx_runtime.jsx)(VideoPlayer, {
      style: mergedStyle,
      src: videoOrImageSrc.url,
      poster: possiblePosterSrc.url,
      requireInteraction,
      ...restProps
    });
  } else if (shouldRenderAudioTag(videoOrImageSrc.mimeType)) {
    return (0, import_jsx_runtime.jsx)(AudioPlayer, {
      style: mergedStyle,
      src: videoOrImageSrc.url,
      poster: possiblePosterSrc.url,
      requireInteraction,
      ...restProps
    });
  } else if (videoOrImageSrc.mimeType.startsWith("image/")) {
    return (0, import_jsx_runtime.jsx)("img", {
      style: mergedStyle,
      src: videoOrImageSrc.url,
      alt,
      ref,
      ...restProps
    });
  }
  return (0, import_jsx_runtime.jsx)(LinkPlayer, {
    style: mergedStyle,
    src: videoOrImageSrc.url,
    alt,
    ref,
    ...restProps
  });
});
MediaRenderer.displayName = "MediaRenderer";
function useResolvedMediaType(uri, mimeType, gatewayUrl) {
  const storage = useStorage();
  const resolvedUrl = (0, import_react14.useMemo)(() => resolveIpfsUri(uri, gatewayUrl ? {
    gatewayUrl
  } : storage ? {
    gatewayUrl: storage.gatewayUrls["ipfs://"][0]
  } : void 0), [uri, storage, gatewayUrl]);
  const resolvedMimType = useQuery(["mime-type", resolvedUrl], () => resolveMimeType(resolvedUrl), {
    enabled: !!resolvedUrl && !mimeType,
    initialData: mimeType
  });
  return {
    url: resolvedUrl,
    mimeType: resolvedMimType.data
  };
}
var ThirdwebNftMedia = import_react14.default.forwardRef((_ref, ref) => {
  var _a;
  let {
    metadata,
    width = "300px",
    height = "300px",
    style,
    ...props
  } = _ref;
  return (0, import_jsx_runtime.jsx)(MediaRenderer, {
    src: metadata.animation_url || metadata.image,
    poster: metadata.image,
    alt: ((_a = metadata.name) == null ? void 0 : _a.toString()) || "",
    ref,
    width,
    height,
    style: {
      ...style
    },
    ...props
  });
});
ThirdwebNftMedia.displayName = "ThirdwebNftMedia";
var Popover = (props) => {
  return (0, import_jsx_runtime.jsxs)($cb5cc270b50c6fcd$export$be92b6f5f03c0fe9, {
    open: props.open,
    onOpenChange: props.onOpenChange,
    children: [(0, import_jsx_runtime.jsx)($cb5cc270b50c6fcd$export$41fb9f06171c75f4, {
      asChild: true,
      children: props.children
    }), (0, import_jsx_runtime.jsx)($cb5cc270b50c6fcd$export$602eac185826482c, {
      children: (0, import_jsx_runtime.jsxs)(PopoverContent, {
        sideOffset: 7,
        side: "top",
        children: [(0, import_jsx_runtime.jsx)(FlexWrapper, {
          children: props.content
        }), (0, import_jsx_runtime.jsx)(PopoverArrow, {})]
      })
    })]
  });
};
var slideUpAndFade = keyframes`
from {
    opacity: 0;
    transform: translateY(2px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
`;
var PopoverContent = newStyled($cb5cc270b50c6fcd$export$7c6e2c02157bb7d2)`
  border-radius: ${radius.sm};
  padding: ${spacing.sm} ${spacing.md};
  background-color: ${(p) => p.theme.bg.inverted};
  box-shadow: ${shadow.md};
  animation-duration: 400ms;
  animation-timing-function: cubic-bezier(0.16, 1, 0.3, 1);
  will-change: transform, opacity;
  animation-name: ${slideUpAndFade};
  color: ${(p) => p.theme.text.inverted};
  font-size: ${fontSize.md};
`;
var PopoverArrow = newStyled($cb5cc270b50c6fcd$export$21b07c8f274aebd5)`
  fill: ${(p) => p.theme.bg.inverted};
`;
var FlexWrapper = newStyled.div`
  display: flex;
  align-items: center;
  gap: ${spacing.sm};
`;
var TW_WEB3BUTTON = "tw-web3button";
var Web3Button = (_ref) => {
  let {
    contractAddress,
    onSuccess,
    onError,
    onSubmit,
    isDisabled,
    contractAbi,
    children,
    action,
    className,
    type,
    theme,
    style
  } = _ref;
  const address = useAddress();
  const sdkChainId = useSDKChainId();
  const switchChain = useSwitchChain();
  const hasMismatch = useNetworkMismatch();
  const connectionStatus = useConnectionStatus();
  const queryClient = useQueryClient();
  const requiresConfirmation = !useIsHeadlessWallet();
  const {
    contract
  } = useContract(contractAddress, contractAbi || "custom");
  const thirdwebTheme = (0, import_react14.useContext)(ThirdwebThemeContext);
  const themeToUse = theme || thirdwebTheme || "dark";
  const [confirmStatus, setConfirmStatus] = (0, import_react14.useState)("idle");
  const actionMutation = useMutation(async () => {
    invariant(contract, "contract is not ready yet");
    if (onSubmit) {
      onSubmit();
    }
    const result = await action(contract);
    return result;
  }, {
    onSuccess: (res) => {
      if (onSuccess) {
        onSuccess(res);
      }
    },
    onError: (err) => {
      if (onError) {
        onError(err);
      }
    },
    onSettled: () => queryClient.invalidateQueries()
  });
  if (!address) {
    return (0, import_jsx_runtime.jsx)(ConnectWallet, {
      style,
      theme,
      className: `${className || ""} ${TW_WEB3BUTTON}--connect-wallet`
    });
  }
  const btnStyle = {
    minWidth: "150px",
    minHeight: "43px"
  };
  let button = null;
  const handleSwitchChain = async () => {
    if (sdkChainId) {
      setConfirmStatus("waiting");
      try {
        await switchChain(sdkChainId);
        setConfirmStatus("idle");
      } catch (e) {
        console.error(e);
        setConfirmStatus("idle");
      }
    }
  };
  if (hasMismatch && !isDisabled) {
    const _button = (0, import_jsx_runtime.jsx)(Button, {
      variant: "inverted",
      type,
      className: `${className || ""} ${TW_WEB3BUTTON}--switch-network`,
      onClick: handleSwitchChain,
      style: {
        ...btnStyle,
        ...style
      },
      "data-is-loading": confirmStatus === "waiting",
      "data-theme": theme,
      children: confirmStatus === "waiting" ? (0, import_jsx_runtime.jsx)(Spinner, {
        size: "sm",
        color: "inverted"
      }) : "Switch Network"
    });
    if (requiresConfirmation) {
      button = (0, import_jsx_runtime.jsx)(Popover, {
        content: (0, import_jsx_runtime.jsx)("span", {
          children: "Confirm in Wallet"
        }),
        open: confirmStatus === "waiting",
        onOpenChange: (isOpen) => {
          if (!isOpen) {
            setConfirmStatus("idle");
          }
        },
        children: _button
      });
    } else {
      button = _button;
    }
  } else if (!isDisabled && (actionMutation.isLoading || !contract || connectionStatus === "connecting" || connectionStatus === "unknown")) {
    button = (0, import_jsx_runtime.jsx)(Button, {
      variant: "inverted",
      type,
      className: `${className || ""} ${TW_WEB3BUTTON}`,
      disabled: true,
      style: {
        ...btnStyle,
        ...style
      },
      "data-is-loading": true,
      "data-theme": theme,
      children: (0, import_jsx_runtime.jsx)(Spinner, {
        size: "md",
        color: "inverted"
      })
    });
  } else {
    button = (0, import_jsx_runtime.jsx)(Button, {
      variant: "inverted",
      type,
      className: `${className || ""} ${TW_WEB3BUTTON}`,
      onClick: () => actionMutation.mutate(),
      disabled: isDisabled,
      style: {
        ...btnStyle,
        ...style
      },
      "data-is-loading": "false",
      "data-theme": theme,
      children
    });
  }
  return (0, import_jsx_runtime.jsx)(ThemeProvider, {
    theme: themeToUse === "dark" ? darkTheme : lightTheme,
    children: button
  });
};
var DEFAULT_API_KEY = "f9e23156ccfc6173c5267eaabf320fb692ffab1c2d572095a58091cbb67590cd";
var GetStartedWithWallets = (_ref) => {
  var _a, _b, _c;
  let {
    onBack
  } = _ref;
  const walletConfigs = useWallets();
  const {
    meta
  } = walletConfigs[0];
  return (0, import_jsx_runtime.jsx)(GetStartedScreen, {
    onBack: () => {
      onBack();
    },
    walletIconURL: meta.iconURL,
    walletName: meta.name,
    appleStoreLink: (_a = meta.urls) == null ? void 0 : _a.ios,
    googlePlayStoreLink: (_b = meta.urls) == null ? void 0 : _b.android,
    chromeExtensionLink: (_c = meta.urls) == null ? void 0 : _c.chrome,
    header: (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
      children: [(0, import_jsx_runtime.jsx)(ModalTitle, {
        children: " Get started with EVM wallets "
      }), (0, import_jsx_runtime.jsx)(Spacer, {
        y: "md"
      }), (0, import_jsx_runtime.jsx)(ModalDescription, {
        children: "An EVM Wallet is your gateway to interact with web3 apps on Ethereum and other custom blockchains."
      }), (0, import_jsx_runtime.jsx)(Spacer, {
        y: "xl"
      }), (0, import_jsx_runtime.jsxs)("div", {
        style: {
          display: "flex",
          gap: spacing.md,
          alignItems: "center"
        },
        children: [(0, import_jsx_runtime.jsx)(SecondaryText, {
          children: "We recommend"
        }), (0, import_jsx_runtime.jsxs)("div", {
          style: {
            display: "flex",
            gap: spacing.xs,
            alignItems: "center"
          },
          children: [(0, import_jsx_runtime.jsx)(Img, {
            src: meta.iconURL,
            width: iconSize.md,
            height: iconSize.md
          }), (0, import_jsx_runtime.jsx)(NeutralText, {
            children: meta.name
          })]
        })]
      })]
    }),
    footer: (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
      children: [(0, import_jsx_runtime.jsx)(Spacer, {
        y: "xl"
      }), (0, import_jsx_runtime.jsx)(HelperLink, {
        target: "_blank",
        href: "https://ethereum.org/en/wallets/find-wallet/",
        style: {
          textAlign: "center"
        },
        children: "Learn more about wallets"
      }), " "]
    })
  });
};
var NeutralText = newStyled.p`
  font-size: ${fontSize.md};
  color: ${(p) => p.theme.text.neutral};
  margin: 0;
`;
var reservedScreens = {
  main: "main",
  getStarted: "getStarted"
};
var ConnectModal = () => {
  const {
    theme,
    title
  } = (0, import_react14.useContext)(ModalConfigCtx);
  const walletConfigs = useWallets();
  const initialScreen = walletConfigs.length === 1 && !walletConfigs[0].selectUI ? walletConfigs[0] : reservedScreens.main;
  const [screen, setScreen] = (0, import_react14.useState)(initialScreen);
  const isWalletModalOpen = useIsWalletModalOpen();
  const setIsWalletModalOpen = useSetIsWalletModalOpen();
  const connectionStatus = useConnectionStatus();
  const wallet = useWallet();
  const walletModalConfig = (0, import_react14.useContext)(ModalConfigCtx);
  const setWalletModalConfig = (0, import_react14.useContext)(SetModalConfigCtx);
  const disconnect = useDisconnect();
  const handleClose = (0, import_react14.useCallback)(function() {
    let reset = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    if (reset) {
      setScreen(initialScreen);
    }
    if (connectionStatus === "connecting") {
      disconnect();
    }
    setIsWalletModalOpen(false);
  }, [setIsWalletModalOpen, initialScreen, connectionStatus, disconnect]);
  const handleBack = (0, import_react14.useCallback)(() => {
    setScreen(initialScreen);
  }, [setScreen, initialScreen]);
  const isWrapperConnected = !!(wallet == null ? void 0 : wallet.getPersonalWallet());
  const isWrapperScreen = typeof screen !== "string" && !!screen.personalWallets;
  const prevConnectionStatus = (0, import_react14.useRef)(connectionStatus);
  (0, import_react14.useEffect)(() => {
    if (!isWrapperConnected && isWrapperScreen && !isWalletModalOpen && connectionStatus === "connected" && prevConnectionStatus.current === "connecting") {
      setIsWalletModalOpen(true);
    }
    prevConnectionStatus.current = connectionStatus;
  }, [isWalletModalOpen, connectionStatus, setIsWalletModalOpen, isWrapperScreen, isWrapperConnected]);
  const WalletConnectUI = typeof screen !== "string" && (screen.connectUI || HeadlessConnectUI);
  return (0, import_jsx_runtime.jsx)(ThemeProvider, {
    theme: typeof theme === "object" ? theme : theme === "light" ? lightTheme : darkTheme,
    children: (0, import_jsx_runtime.jsxs)(Modal, {
      style: {
        maxWidth: "480px"
      },
      open: isWalletModalOpen,
      setOpen: (value) => {
        setIsWalletModalOpen(value);
        if (!value) {
          setScreen(initialScreen);
        }
        if (connectionStatus === "connecting") {
          disconnect();
        }
      },
      children: [screen === reservedScreens.main && (0, import_jsx_runtime.jsx)(WalletSelector, {
        title,
        walletConfigs,
        onGetStarted: () => {
          setScreen(reservedScreens.getStarted);
        },
        selectWallet: setScreen
      }), screen === reservedScreens.getStarted && (0, import_jsx_runtime.jsx)(GetStartedWithWallets, {
        onBack: handleBack
      }), WalletConnectUI && (0, import_jsx_runtime.jsx)(WalletConnectUI, {
        supportedWallets: walletConfigs,
        theme,
        goBack: handleBack,
        close: handleClose,
        isOpen: isWalletModalOpen,
        open: () => {
          setIsWalletModalOpen(true);
        },
        walletConfig: screen,
        selectionData: walletModalConfig.data,
        setSelectionData: (data) => {
          setWalletModalConfig((config) => ({
            ...config,
            data
          }));
        }
      })]
    })
  });
};
var ThirdwebProvider = (_ref) => {
  let {
    thirdwebApiKey = DEFAULT_API_KEY,
    supportedWallets,
    theme,
    children,
    ...restProps
  } = _ref;
  const wallets = supportedWallets || defaultWallets;
  return (0, import_jsx_runtime.jsx)(WalletUIStatesProvider, {
    theme,
    children: (0, import_jsx_runtime.jsx)(ThemeProvider, {
      theme: theme === "dark" ? darkTheme : lightTheme,
      children: (0, import_jsx_runtime.jsxs)(ThirdwebProviderCore, {
        theme,
        thirdwebApiKey,
        supportedWallets: wallets,
        ...restProps,
        children: [children, (0, import_jsx_runtime.jsx)(ConnectModal, {})]
      })
    })
  });
};
function useInstalledWallets() {
  var _a, _b, _c, _d;
  let isMetamaskInstalled = false;
  let isCoinbaseWalletInstalled = false;
  if (assertWindowEthereum(globalThis.window)) {
    isMetamaskInstalled = (_a = globalThis.window.ethereum) == null ? void 0 : _a.isMetaMask;
    isCoinbaseWalletInstalled = ((_b = globalThis.window.ethereum) == null ? void 0 : _b.isCoinbaseWallet) || ((_d = (_c = globalThis.window.ethereum) == null ? void 0 : _c.providers) == null ? void 0 : _d.some((p) => p.isCoinbaseWallet)) || false;
  }
  const installedWallets = {
    metamask: !!isMetamaskInstalled,
    coinbaseWallet: !!isCoinbaseWalletInstalled
  };
  return installedWallets;
}
function useMetamask() {
  const connect = useConnect();
  return (0, import_react14.useCallback)(async (connectOptions) => {
    const {
      metamaskWallet: metamaskWallet2
    } = await import("./headlessConnectUI-6609266c.browser.esm-JANQ5572.js").then(function(n) {
      return n.r;
    });
    return connect(metamaskWallet2(), connectOptions);
  }, [connect]);
}
function useCoinbaseWallet() {
  const connect = useConnect();
  return (0, import_react14.useCallback)(async (connectOptions) => {
    const {
      coinbaseWallet: coinbaseWallet2
    } = await import("./headlessConnectUI-6609266c.browser.esm-JANQ5572.js").then(function(n) {
      return n.q;
    });
    return connect(coinbaseWallet2(), connectOptions);
  }, [connect]);
}
function useFrameWallet() {
  const connect = useConnect();
  return (0, import_react14.useCallback)(async (connectOptions) => {
    const {
      frameWallet: frameWallet2
    } = await import("./frameWallet-80d0fc9f.browser.esm-2HHLKJCC.js");
    return connect(frameWallet2(), connectOptions);
  }, [connect]);
}
function usePaperWallet() {
  const connect = useConnect();
  return (0, import_react14.useCallback)(async (options) => {
    const {
      paperWallet: paperWallet2
    } = await import("./paperWallet-6bbe13a1.browser.esm-GTII4V5Z.js");
    return connect(paperWallet2({
      clientId: options.clientId
    }), {
      chainId: options.chainId,
      email: options.email
    });
  }, [connect]);
}
function usePaperWalletUserEmail() {
  const wallet = useWallet();
  const queryClient = useQueryClient();
  const emailQuery = useQuery([wallet == null ? void 0 : wallet.walletId, "paper-email"], () => {
    if (!wallet || wallet.walletId !== walletIds.paper) {
      throw "Not connected to Paper Wallet";
    }
    return wallet.getEmail();
  }, {
    retry: false
  });
  (0, import_react14.useEffect)(() => {
    queryClient.invalidateQueries([wallet == null ? void 0 : wallet.walletId, "paper-email"]);
  }, [wallet, queryClient]);
  return emailQuery;
}
function useWalletConnectV1() {
  const connect = useConnect();
  return (0, import_react14.useCallback)(async (options) => {
    const {
      walletConnectV1: walletConnectV12
    } = await import("./headlessConnectUI-6609266c.browser.esm-JANQ5572.js").then(function(n) {
      return n.s;
    });
    return connect(walletConnectV12(), options);
  }, [connect]);
}
function useWalletConnect() {
  const connect = useConnect();
  return (0, import_react14.useCallback)(async (options) => {
    const {
      walletConnect: walletConnect2
    } = await import("./walletConnect-999b71fe.browser.esm-7YXLE5ZR.js");
    return connect(walletConnect2(options), options);
  }, [connect]);
}

// node_modules/@thirdweb-dev/react/dist/useSafe-564c7f83.browser.esm.js
init_shim();
var import_react16 = __toESM(require_react());
function useSafe() {
  const connect = useConnect();
  return (0, import_react16.useCallback)(async (connectProps) => {
    const {
      safeWallet: safeWallet2
    } = await import("./safeWallet-08c1af58.browser.esm-DD5JAGRD.js");
    return connect(safeWallet2(), connectProps);
  }, [connect]);
}

// node_modules/@thirdweb-dev/react/dist/useMagic-c0613271.browser.esm.js
init_shim();
var import_react17 = __toESM(require_react());
function useMagic() {
  const connect = useConnect();
  return (0, import_react17.useCallback)(async (options) => {
    const {
      magicLink: magicLink2
    } = await import("./magicLink-de5fe521.browser.esm-UK2JL7D2.js");
    return connect(magicLink2(options), options);
  }, [connect]);
}

// node_modules/@thirdweb-dev/react/dist/thirdweb-dev-react.browser.esm.js
init_es();
var import_react_qr_code = __toESM(require_lib());
var import_copy_to_clipboard2 = __toESM(require_copy_to_clipboard());
init_lib();
function useSmartWallet() {
  const connect = useConnect();
  return (0, import_react18.useCallback)(async (options) => {
    const {
      smartWallet: smartWallet2
    } = await Promise.resolve().then(function() {
      return smartWallet$1;
    });
    return connect(smartWallet2(options), options);
  }, [connect]);
}
function useLocalWalletInfo(localWalletConfig, persist) {
  const [walletData, setWalletData] = (0, import_react18.useState)("loading");
  const createWalletInstance = useCreateWalletInstance();
  const [localWallet2, setLocalWallet] = (0, import_react18.useState)(null);
  (0, import_react18.useEffect)(() => {
    const wallet = createWalletInstance(localWalletConfig);
    setLocalWallet(wallet);
    if (persist) {
      wallet.getSavedData().then((data) => {
        setWalletData(data);
      });
    }
  }, [createWalletInstance, localWalletConfig, persist]);
  return {
    setLocalWallet,
    localWallet: localWallet2,
    walletData,
    meta: localWalletConfig.meta,
    persist
  };
}
var DragNDrop = (props) => {
  const [error, setError] = (0, import_react18.useState)(false);
  const [uploaded, setUploaded] = (0, import_react18.useState)();
  const [isDragging, setIsDragging] = (0, import_react18.useState)(false);
  const dragIn = (e) => {
    setError(false);
    setUploaded(void 0);
    setIsDragging(true);
    e.preventDefault();
    e.stopPropagation();
  };
  const dragOut = (e) => {
    setIsDragging(false);
    e.preventDefault();
    e.stopPropagation();
  };
  const handleFileUpload = (file) => {
    if (file.type !== props.accept) {
      setError(true);
    } else {
      setUploaded(file);
      props.onUpload(file);
    }
  };
  const drop = (e) => {
    setIsDragging(false);
    e.preventDefault();
    e.stopPropagation();
    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
      handleFileUpload(e.dataTransfer.files[0]);
      e.dataTransfer.clearData();
    }
  };
  const message = isMobile() ? "Click to Upload" : "Drop your file here or click to upload";
  return (0, import_jsx_runtime2.jsx)("div", {
    onDragEnter: dragIn,
    onDragLeave: dragOut,
    onDragOver: (e) => {
      setIsDragging(true);
      e.preventDefault();
      e.stopPropagation();
    },
    onClick: () => {
      setError(false);
    },
    onDrop: drop,
    style: {
      cursor: "pointer"
    },
    children: (0, import_jsx_runtime2.jsxs)("label", {
      htmlFor: "file-upload",
      children: [(0, import_jsx_runtime2.jsx)("input", {
        id: "file-upload",
        type: "file",
        accept: props.accept,
        multiple: false,
        style: {
          display: "none"
        },
        onChange: (e) => {
          if (e.target.files && e.target.files.length > 0) {
            handleFileUpload(e.target.files[0]);
          }
        }
      }), (0, import_jsx_runtime2.jsx)(DropContainer, {
        "data-error": error,
        "data-is-dragging": isDragging,
        children: !uploaded ? (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, {
          children: [" ", (0, import_jsx_runtime2.jsx)(UploadIconSecondary, {
            width: iconSize.xl,
            height: iconSize.xl
          }), (0, import_jsx_runtime2.jsx)(Spacer, {
            y: "md"
          }), (0, import_jsx_runtime2.jsx)(Message, {
            children: message
          }), (0, import_jsx_runtime2.jsx)(Spacer, {
            y: "md"
          }), error ? (0, import_jsx_runtime2.jsxs)(ErrorMessage3, {
            children: [" ", "Please upload a ", props.extension, " file", " "]
          }) : (0, import_jsx_runtime2.jsxs)(ExtensionText, {
            children: [" ", props.extension, " "]
          })]
        }) : (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, {
          children: [(0, import_jsx_runtime2.jsxs)(Message, {
            children: [uploaded.name, " uploaded successfully"]
          }), (0, import_jsx_runtime2.jsx)(Spacer, {
            y: "md"
          }), (0, import_jsx_runtime2.jsx)(CheckCircleIcon, {
            size: iconSize.xl
          })]
        })
      })]
    })
  });
};
var UploadIconSecondary = newStyled(UploadIcon)`
  color: ${(props) => props.theme.text.secondary};
  transition: transform 200ms ease, color 200ms ease;
`;
var DropContainer = newStyled.div`
  border: 2px solid ${(p) => p.theme.bg.elevated};
  border-radius: ${radius.md};
  padding: ${spacing.xl} ${spacing.md};
  display: flex;
  align-items: center;
  flex-direction: column;
  cursor: pointer;
  transition: border-color 200ms ease;

  &:hover,
  &[data-is-dragging="true"] {
    border-color: ${(p) => p.theme.link.primary};
    svg {
      color: ${(p) => p.theme.link.primary};
    }
  }

  &[data-error="true"] {
    border-color: ${(p) => p.theme.input.errorRing};
  }
`;
var ErrorMessage3 = newStyled.p`
  color: ${(p) => p.theme.input.errorRing};
  font-size: ${fontSize.sm};
  margin: 0;
`;
var ExtensionText = newStyled.span`
  color: ${(p) => p.theme.text.secondary};
  font-size: ${fontSize.sm};
`;
var CheckCircleIcon = (props) => (0, import_jsx_runtime2.jsxs)("svg", {
  width: props.size,
  height: props.size,
  viewBox: "0 0 38 38",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  children: [(0, import_jsx_runtime2.jsx)("path", {
    d: "M35.6666 17.4671V19.0004C35.6645 22.5945 34.5008 26.0916 32.3488 28.9701C30.1969 31.8487 27.1721 33.9546 23.7255 34.9736C20.279 35.9926 16.5954 35.8703 13.224 34.6247C9.85272 33.3792 6.97434 31.0773 5.01819 28.0622C3.06203 25.0472 2.1329 21.4805 2.36938 17.8943C2.60586 14.308 3.99526 10.8943 6.33039 8.16221C8.66551 5.43012 11.8212 3.52606 15.3269 2.734C18.8326 1.94194 22.5004 2.30432 25.7833 3.76709",
    stroke: "#5BD58C",
    strokeWidth: "3.33333",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), (0, import_jsx_runtime2.jsx)("path", {
    d: "M35.6667 5.66699L19 22.3503L14 17.3503",
    stroke: "#5BD58C",
    strokeWidth: "3.33333",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  })]
});
var Message = newStyled.p`
  color: ${(p) => p.theme.text.neutral};
  font-size: ${fontSize.md};
  margin: 0;
  font-weight: 600;
`;
var LocalWalletModalHeader = (props) => {
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, {
    children: [!props.hideBack && (0, import_jsx_runtime2.jsx)(BackButton, {
      onClick: props.onBack
    }), (0, import_jsx_runtime2.jsx)(Spacer, {
      y: "md"
    }), (0, import_jsx_runtime2.jsx)(Img, {
      src: props.meta.iconURL,
      width: iconSize.xl,
      height: iconSize.xl
    }), (0, import_jsx_runtime2.jsx)(Spacer, {
      y: "sm"
    })]
  });
};
var ImportLocalWallet = (props) => {
  const [jsonString, setJsonString] = (0, import_react18.useState)();
  const {
    setLocalWallet,
    meta
  } = useLocalWalletInfo(props.localWalletConf, props.persist);
  const createWalletInstance = useCreateWalletInstance();
  const [password, setPassword] = (0, import_react18.useState)("");
  const [isWrongPassword, setIsWrongPassword] = (0, import_react18.useState)(false);
  const [showPassword, setShowPassword] = (0, import_react18.useState)(false);
  const [importedAddress, setImportedAddress] = (0, import_react18.useState)();
  const {
    setConnectedWallet,
    setConnectionStatus
  } = useWalletContext();
  const handleImport = async () => {
    const localWallet2 = createWalletInstance(props.localWalletConf);
    if (!localWallet2 || !jsonString) {
      throw new Error("Invalid state");
    }
    try {
      await localWallet2.import({
        encryptedJson: jsonString,
        password
      });
    } catch (e) {
      console.error(e);
      setIsWrongPassword(true);
      return;
    }
    setConnectionStatus("connecting");
    await localWallet2.connect();
    await localWallet2.save({
      strategy: "encryptedJson",
      password
    });
    setConnectedWallet(localWallet2);
    setLocalWallet(localWallet2);
    props.onConnect();
  };
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, {
    children: [(0, import_jsx_runtime2.jsx)(LocalWalletModalHeader, {
      onBack: props.goBack,
      meta
    }), (0, import_jsx_runtime2.jsx)(ModalTitle, {
      style: {
        textAlign: "left"
      },
      children: "Import Wallet"
    }), (0, import_jsx_runtime2.jsx)(Spacer, {
      y: "md"
    }), (0, import_jsx_runtime2.jsx)(ModalDescription, {
      children: "The application can authorize any transactions on behalf of the wallet without any approvals. We recommend only connecting to trusted applications."
    }), (0, import_jsx_runtime2.jsx)(Spacer, {
      y: "lg"
    }), (0, import_jsx_runtime2.jsx)(DragNDrop, {
      extension: "JSON",
      accept: "application/json",
      onUpload: (file) => {
        const reader = new FileReader();
        reader.onload = (event) => {
          var _a, _b;
          setJsonString((_a = event.target) == null ? void 0 : _a.result);
          const obj = JSON.parse((_b = event.target) == null ? void 0 : _b.result);
          setImportedAddress(obj.address);
        };
        reader.readAsText(file, "utf-8");
      }
    }), (0, import_jsx_runtime2.jsx)(Spacer, {
      y: "lg"
    }), (0, import_jsx_runtime2.jsxs)("form", {
      onSubmit: (e) => {
        e.preventDefault();
        handleImport();
      },
      children: [jsonString && (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, {
        children: [(0, import_jsx_runtime2.jsx)("input", {
          type: "text",
          name: "username",
          autoComplete: "off",
          value: importedAddress || "",
          disabled: true,
          style: {
            display: "none"
          }
        }), (0, import_jsx_runtime2.jsx)(FormFieldWithIconButton, {
          required: true,
          noSave: true,
          name: "password",
          autocomplete: "off",
          id: "password",
          onChange: (value) => {
            setPassword(value);
            setIsWrongPassword(false);
          },
          right: {
            onClick: () => setShowPassword(!showPassword),
            icon: showPassword ? (0, import_jsx_runtime2.jsx)(EyeClosedIcon, {}) : (0, import_jsx_runtime2.jsx)(EyeOpenIcon, {})
          },
          label: "Password",
          type: showPassword ? "text" : "password",
          value: password,
          error: isWrongPassword ? "Wrong Password" : ""
        }), (0, import_jsx_runtime2.jsx)(Spacer, {
          y: "xl"
        })]
      }), (0, import_jsx_runtime2.jsx)(FormFooter, {
        children: (0, import_jsx_runtime2.jsx)(Button, {
          variant: "inverted",
          type: "submit",
          disabled: !jsonString,
          style: {
            minWidth: "110px",
            opacity: jsonString ? 1 : 0.5
          },
          children: "Import"
        })
      })]
    })]
  });
};
var CreateLocalWallet_Password = (props) => {
  const [password, setPassword] = (0, import_react18.useState)("");
  const [confirmPassword, setConfirmPassword] = (0, import_react18.useState)("");
  const [showPassword, setShowPassword] = (0, import_react18.useState)(false);
  const passwordMismatch = confirmPassword && password !== confirmPassword;
  const [isConnecting, setIsConnecting] = (0, import_react18.useState)(false);
  const {
    localWallet: localWallet2,
    meta
  } = useLocalWalletInfo(props.localWalletConf, props.persist);
  const {
    setConnectedWallet,
    setConnectionStatus
  } = useWalletContext();
  const [showImportScreen, setShowImportScreen] = (0, import_react18.useState)(false);
  const [generatedAddress, setGeneratedAddress] = (0, import_react18.useState)(null);
  (0, import_react18.useEffect)(() => {
    if (!localWallet2 || showImportScreen || localWallet2.ethersWallet) {
      return;
    }
    localWallet2.generate().then((_address) => {
      setGeneratedAddress(_address);
    });
  }, [localWallet2, showImportScreen]);
  if (showImportScreen) {
    return (0, import_jsx_runtime2.jsx)(ImportLocalWallet, {
      localWalletConf: props.localWalletConf,
      onConnect: props.onConnect,
      goBack: () => {
        setShowImportScreen(false);
      },
      persist: props.persist
    });
  }
  const handleConnect = async () => {
    if (passwordMismatch || !localWallet2) {
      throw new Error("Invalid state");
    }
    setIsConnecting(true);
    setConnectionStatus("connecting");
    await localWallet2.connect();
    await localWallet2.save({
      strategy: "encryptedJson",
      password
    });
    setConnectedWallet(localWallet2);
    setIsConnecting(false);
    props.onConnect();
  };
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, {
    children: [(0, import_jsx_runtime2.jsx)(LocalWalletModalHeader, {
      onBack: props.goBack,
      meta,
      hideBack: !props.renderBackButton
    }), (0, import_jsx_runtime2.jsx)(Flex, {
      alignItems: "center",
      gap: "xs",
      children: (0, import_jsx_runtime2.jsx)(ModalTitle, {
        children: "Guest Wallet"
      })
    }), (0, import_jsx_runtime2.jsx)(Spacer, {
      y: "sm"
    }), (0, import_jsx_runtime2.jsxs)(ModalDescription, {
      children: ["Choose a password for your wallet, you", `'`, "ll be able to access and export this wallet with the same password."]
    }), (0, import_jsx_runtime2.jsx)(Spacer, {
      y: "lg"
    }), (0, import_jsx_runtime2.jsxs)("form", {
      onSubmit: (e) => {
        e.preventDefault();
        handleConnect();
      },
      children: [(0, import_jsx_runtime2.jsx)("input", {
        type: "text",
        name: "username",
        autoComplete: "off",
        value: generatedAddress || "",
        disabled: true,
        style: {
          display: "none"
        }
      }), (0, import_jsx_runtime2.jsx)(FormFieldWithIconButton, {
        name: "password",
        required: true,
        autocomplete: "new-password",
        id: "new-password",
        onChange: (value) => setPassword(value),
        right: {
          icon: showPassword ? (0, import_jsx_runtime2.jsx)(EyeClosedIcon, {}) : (0, import_jsx_runtime2.jsx)(EyeOpenIcon, {}),
          onClick: () => setShowPassword(!showPassword)
        },
        label: "Password",
        type: showPassword ? "text" : "password",
        value: password,
        dataTest: "new-password"
      }), (0, import_jsx_runtime2.jsx)(Spacer, {
        y: "lg"
      }), (0, import_jsx_runtime2.jsx)(FormFieldWithIconButton, {
        name: "confirm-password",
        required: true,
        autocomplete: "new-password",
        id: "confirm-password",
        onChange: (value) => setConfirmPassword(value),
        right: {
          icon: showPassword ? (0, import_jsx_runtime2.jsx)(EyeClosedIcon, {}) : (0, import_jsx_runtime2.jsx)(EyeOpenIcon, {}),
          onClick: () => setShowPassword(!showPassword)
        },
        label: "Confirm Password",
        type: showPassword ? "text" : "password",
        value: confirmPassword,
        error: passwordMismatch ? "Passwords don't match" : "",
        dataTest: "confirm-password"
      }), (0, import_jsx_runtime2.jsx)(Spacer, {
        y: "xl"
      }), (0, import_jsx_runtime2.jsxs)(Button, {
        variant: "inverted",
        type: "submit",
        style: {
          width: "100%",
          gap: spacing.sm
        },
        "data-test": "create-new-wallet-button",
        children: [isConnecting ? "Connecting" : "Create new wallet", isConnecting && (0, import_jsx_runtime2.jsx)(Spinner, {
          size: "sm",
          color: "inverted"
        })]
      })]
    }), (0, import_jsx_runtime2.jsx)(Spacer, {
      y: "xxl"
    }), (0, import_jsx_runtime2.jsx)(TextDivider, {
      children: (0, import_jsx_runtime2.jsx)("span", {
        children: "OR"
      })
    }), (0, import_jsx_runtime2.jsx)(Spacer, {
      y: "lg"
    }), (0, import_jsx_runtime2.jsx)(Flex, {
      justifyContent: "center",
      children: (0, import_jsx_runtime2.jsx)(Button, {
        variant: "link",
        onClick: () => {
          setShowImportScreen(true);
        },
        children: "Import wallet"
      })
    })]
  });
};
var CreateLocalWallet_Guest = (props) => {
  const {
    localWallet: localWallet2
  } = useLocalWalletInfo(props.localWallet, props.persist);
  const {
    setConnectedWallet,
    setConnectionStatus
  } = useWalletContext();
  const {
    onConnect
  } = props;
  const handleConnect = (0, import_react18.useCallback)(async () => {
    if (!localWallet2) {
      throw new Error("Invalid state");
    }
    await localWallet2.generate();
    setConnectionStatus("connecting");
    await localWallet2.connect();
    setConnectedWallet(localWallet2);
    onConnect();
  }, [localWallet2, setConnectedWallet, onConnect, setConnectionStatus]);
  const connecting = (0, import_react18.useRef)(false);
  (0, import_react18.useEffect)(() => {
    if (connecting.current || !localWallet2) {
      return;
    }
    connecting.current = true;
    handleConnect();
  }, [handleConnect, localWallet2]);
  return (0, import_jsx_runtime2.jsx)(Flex, {
    justifyContent: "center",
    alignItems: "center",
    style: {
      height: "300px"
    },
    children: (0, import_jsx_runtime2.jsx)(Spinner, {
      size: "lg",
      color: "link"
    })
  });
};
var OverrideConfirmation = (props) => {
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, {
    children: [(0, import_jsx_runtime2.jsx)(LocalWalletModalHeader, {
      onBack: props.onBack,
      meta: props.meta
    }), (0, import_jsx_runtime2.jsx)(ModalTitle, {
      children: "Backup your wallet"
    }), (0, import_jsx_runtime2.jsx)(Spacer, {
      y: "md"
    }), (0, import_jsx_runtime2.jsxs)("div", {
      style: {
        lineHeight: 1.5
      },
      children: [(0, import_jsx_runtime2.jsx)(SecondaryText, {
        children: "Your current wallet will be deleted if you create a new wallet. Backup wallet to your device before creating a new wallet"
      }), (0, import_jsx_runtime2.jsx)(Spacer, {
        y: "xl"
      }), (0, import_jsx_runtime2.jsx)(FormFooter, {
        children: (0, import_jsx_runtime2.jsx)(Button, {
          variant: "inverted",
          onClick: props.onBackup,
          children: "Backup wallet"
        })
      })]
    })]
  });
};
var ReconnectLocalWallet = (props) => {
  const [password, setPassword] = (0, import_react18.useState)("");
  const [showPassword, setShowPassword] = (0, import_react18.useState)(false);
  const [isWrongPassword, setIsWrongPassword] = (0, import_react18.useState)(false);
  const {
    setConnectedWallet,
    setConnectionStatus
  } = useWalletContext();
  const [isConnecting, setIsConnecting] = (0, import_react18.useState)(false);
  const [showCreate, setShowCreate] = (0, import_react18.useState)(false);
  const [showBackupConfirmation, setShowBackupConfirmation] = (0, import_react18.useState)(false);
  const [showExport, setShowExport] = (0, import_react18.useState)(false);
  const {
    localWallet: localWallet2,
    meta,
    walletData
  } = useLocalWalletInfo(props.localWallet, props.persist);
  const savedAddress = walletData ? walletData === "loading" ? "" : walletData.address : "";
  if (showExport) {
    if (!localWallet2) {
      throw new Error("Invalid state");
    }
    return (0, import_jsx_runtime2.jsx)(ExportLocalWallet, {
      localWalletConfig: props.localWallet,
      onBack: () => {
        setShowExport(false);
      },
      onExport: () => {
        setShowExport(false);
        setShowBackupConfirmation(false);
        setShowCreate(true);
      }
    });
  }
  if (showBackupConfirmation) {
    return (0, import_jsx_runtime2.jsx)(OverrideConfirmation, {
      meta,
      onBackup: () => {
        setShowExport(true);
      },
      onBack: () => {
        setShowBackupConfirmation(false);
      }
    });
  }
  if (showCreate) {
    return (0, import_jsx_runtime2.jsx)(CreateLocalWallet_Password, {
      renderBackButton: props.supportedWallets.length > 1,
      localWalletConf: props.localWallet,
      goBack: () => {
        setShowCreate(false);
      },
      onConnect: props.onConnect,
      persist: props.persist
    });
  }
  const handleReconnect = async () => {
    if (!localWallet2) {
      throw new Error("Invalid state");
    }
    setIsConnecting(true);
    try {
      await localWallet2.load({
        strategy: "encryptedJson",
        password
      });
      setConnectionStatus("connecting");
      await localWallet2.connect();
      setConnectedWallet(localWallet2);
      props.onConnect();
    } catch (e) {
      setIsWrongPassword(true);
    }
    setIsConnecting(false);
  };
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, {
    children: [(0, import_jsx_runtime2.jsx)(LocalWalletModalHeader, {
      onBack: props.goBack,
      meta,
      hideBack: !props.renderBackButton
    }), (0, import_jsx_runtime2.jsx)(ModalTitle, {
      style: {
        textAlign: "left"
      },
      children: "Guest Wallet"
    }), (0, import_jsx_runtime2.jsx)(Spacer, {
      y: "xs"
    }), (0, import_jsx_runtime2.jsx)(ModalDescription, {
      children: "Connect to saved wallet on your device"
    }), (0, import_jsx_runtime2.jsx)(Spacer, {
      y: "lg"
    }), (0, import_jsx_runtime2.jsx)(Label, {
      children: "Saved Wallet"
    }), (0, import_jsx_runtime2.jsx)(Spacer, {
      y: "sm"
    }), (0, import_jsx_runtime2.jsx)(SecondaryText, {
      children: savedAddress === "" ? "Loading..." : shortenAddress(savedAddress)
    }), (0, import_jsx_runtime2.jsx)(Spacer, {
      y: "lg"
    }), (0, import_jsx_runtime2.jsxs)("form", {
      onSubmit: (e) => {
        e.preventDefault();
        handleReconnect();
      },
      children: [(0, import_jsx_runtime2.jsx)("input", {
        type: "text",
        name: "username",
        autoComplete: "off",
        value: savedAddress,
        disabled: true,
        style: {
          display: "none"
        }
      }), (0, import_jsx_runtime2.jsx)(FormFieldWithIconButton, {
        required: true,
        name: "current-password",
        autocomplete: "current-password",
        id: "current-password",
        onChange: (value) => {
          setPassword(value);
          setIsWrongPassword(false);
        },
        right: {
          onClick: () => setShowPassword(!showPassword),
          icon: showPassword ? (0, import_jsx_runtime2.jsx)(EyeClosedIcon, {}) : (0, import_jsx_runtime2.jsx)(EyeOpenIcon, {})
        },
        label: "Password",
        type: showPassword ? "text" : "password",
        value: password,
        error: isWrongPassword ? "Wrong Password" : "",
        dataTest: "current-password"
      }), (0, import_jsx_runtime2.jsx)(Spacer, {
        y: "lg"
      }), (0, import_jsx_runtime2.jsx)(FormFooter, {
        children: (0, import_jsx_runtime2.jsxs)(Button, {
          variant: "inverted",
          type: "submit",
          style: {
            display: "flex",
            gap: spacing.sm
          },
          children: ["Connect", isConnecting && (0, import_jsx_runtime2.jsx)(Spinner, {
            size: "sm",
            color: "inverted"
          })]
        })
      })]
    }), (0, import_jsx_runtime2.jsx)(Spacer, {
      y: "xxl"
    }), (0, import_jsx_runtime2.jsx)(Button, {
      variant: "link",
      style: {
        textAlign: "center",
        width: "100%",
        padding: "2px"
      },
      onClick: () => {
        setShowBackupConfirmation(true);
      },
      children: "Create a new wallet"
    })]
  });
};
var LocalWalletConnectUI = (props) => {
  const {
    walletData
  } = useLocalWalletInfo(props.walletConfig, props.persist);
  if (!props.persist) {
    return (0, import_jsx_runtime2.jsx)(CreateLocalWallet_Guest, {
      persist: props.persist,
      localWallet: props.walletConfig,
      goBack: props.goBack,
      onConnect: props.close
    });
  }
  if (walletData === "loading") {
    return (0, import_jsx_runtime2.jsx)(Flex, {
      justifyContent: "center",
      alignItems: "center",
      style: {
        height: "300px"
      },
      children: (0, import_jsx_runtime2.jsx)(Spinner, {
        size: "lg",
        color: "primary"
      })
    });
  }
  if (walletData) {
    return (0, import_jsx_runtime2.jsx)(ReconnectLocalWallet, {
      renderBackButton: props.supportedWallets.length > 1,
      supportedWallets: props.supportedWallets,
      onConnect: props.close,
      goBack: props.goBack,
      localWallet: props.walletConfig,
      persist: props.persist
    });
  }
  return (0, import_jsx_runtime2.jsx)(CreateLocalWallet_Password, {
    goBack: props.goBack,
    localWalletConf: props.walletConfig,
    onConnect: props.close,
    renderBackButton: props.supportedWallets.length > 1,
    persist: props.persist
  });
};
var localWallet = (config) => {
  return {
    id: LocalWallet.id,
    meta: {
      ...LocalWallet.meta,
      name: "Guest Wallet"
    },
    create: (options) => new LocalWallet(options),
    connectUI(props) {
      return (0, import_jsx_runtime2.jsx)(LocalWalletConnectUI, {
        ...props,
        persist: config && config.persist !== void 0 ? config.persist : true
      });
    }
  };
};
var SmartWalletConnecting = (props) => {
  const activeWallet = useWallet();
  const connect = useConnect();
  const connectedChain = useChain();
  const targetChain = useWalletContext().activeChain;
  const mismatch = useNetworkMismatch();
  const [connectError, setConnectError] = (0, import_react18.useState)(false);
  const [switchError, setSwitchError] = (0, import_react18.useState)(false);
  const [switchingNetwork, setSwitchingNetwork] = (0, import_react18.useState)(false);
  const connectionStatus = useConnectionStatus();
  const requiresConfirmation = !useIsHeadlessWallet();
  const {
    onConnect
  } = props;
  const connectStarted = (0, import_react18.useRef)(false);
  const switchChain = useSwitchChain();
  const handleConnect = (0, import_react18.useCallback)(async () => {
    if (!activeWallet || !connectedChain || connectStarted.current) {
      return;
    }
    setConnectError(false);
    try {
      connectStarted.current = true;
      await connect(props.smartWallet, {
        personalWallet: activeWallet
      });
      onConnect();
    } catch (e) {
      console.error(e);
      setConnectError(true);
    }
  }, [activeWallet, connectedChain, connect, props.smartWallet, onConnect]);
  (0, import_react18.useEffect)(() => {
    if (!mismatch) {
      handleConnect();
    }
  }, [mismatch, handleConnect, activeWallet, connectedChain]);
  if (connectionStatus === "connecting" || !mismatch) {
    return (0, import_jsx_runtime2.jsxs)(Flex, {
      style: {
        height: "300px",
        justifyContent: "center",
        flexDirection: "column",
        gap: spacing.xl,
        alignItems: "center"
      },
      children: [(0, import_jsx_runtime2.jsx)(ModalTitle, {
        children: "Connecting to Smart Wallet "
      }), (0, import_jsx_runtime2.jsx)(Spinner, {
        color: "link",
        size: "lg"
      })]
    });
  }
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, {
    children: [(0, import_jsx_runtime2.jsx)(BackButton, {
      onClick: props.onBack
    }), (0, import_jsx_runtime2.jsx)(Spacer, {
      y: "md"
    }), (0, import_jsx_runtime2.jsx)(Img, {
      src: props.smartWallet.meta.iconURL,
      width: iconSize.xl,
      height: iconSize.xl
    }), (0, import_jsx_runtime2.jsx)(Spacer, {
      y: "lg"
    }), (0, import_jsx_runtime2.jsx)(ModalTitle, {
      children: "Network Mismatch"
    }), (0, import_jsx_runtime2.jsx)(Spacer, {
      y: "md"
    }), (0, import_jsx_runtime2.jsx)(ModalDescription, {
      children: "Selected wallet is not connected to the required network"
    }), (0, import_jsx_runtime2.jsx)(Spacer, {
      y: "lg"
    }), connectError && (0, import_jsx_runtime2.jsxs)(ErrorMessage, {
      style: {
        display: "flex",
        gap: spacing.sm,
        alignItems: "center",
        fontSize: fontSize.sm
      },
      children: [(0, import_jsx_runtime2.jsx)(ExclamationTriangleIcon, {
        width: iconSize.sm,
        height: iconSize.sm
      }), (0, import_jsx_runtime2.jsxs)("span", {
        children: ["Could not connect to Smart Wallet. ", (0, import_jsx_runtime2.jsx)("br", {})]
      })]
    }), (0, import_jsx_runtime2.jsxs)(Button, {
      type: "button",
      variant: "secondary",
      style: {
        display: "flex",
        alignItems: "center",
        gap: spacing.sm
      },
      onClick: async () => {
        if (!activeWallet) {
          throw new Error("No active wallet");
        }
        setConnectError(false);
        setSwitchError(false);
        setSwitchingNetwork(true);
        try {
          await switchChain(targetChain.chainId);
        } catch (e) {
          setSwitchError(true);
        } finally {
          setSwitchingNetwork(false);
        }
      },
      children: [" ", switchingNetwork ? "Switching" : "Switch Network", switchingNetwork && (0, import_jsx_runtime2.jsx)(Spinner, {
        size: "sm",
        color: "primary"
      })]
    }), (0, import_jsx_runtime2.jsx)(Spacer, {
      y: "md"
    }), switchingNetwork && requiresConfirmation && (0, import_jsx_runtime2.jsx)(ConfirmMessage2, {
      children: " Confirm in your wallet "
    }), switchError && (0, import_jsx_runtime2.jsxs)(ErrorMessage, {
      style: {
        display: "flex",
        gap: spacing.sm,
        alignItems: "center",
        fontSize: fontSize.sm
      },
      children: [(0, import_jsx_runtime2.jsx)(ExclamationTriangleIcon, {
        width: iconSize.sm,
        height: iconSize.sm
      }), (0, import_jsx_runtime2.jsx)("span", {
        children: "Failed to switch network."
      })]
    })]
  });
};
var ConfirmMessage2 = newStyled.p`
  font-size: ${fontSize.sm};
  margin: 0;
  color: ${(p) => p.theme.link.primary};
`;
var SelectPersonalWallet = (props) => {
  const guestWallet = props.personalWallets.find((w) => w.id === walletIds.localWallet);
  const personalWallets = props.personalWallets.filter((w) => w.id !== walletIds.localWallet);
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, {
    children: [props.renderBackButton && (0, import_jsx_runtime2.jsx)(BackButton, {
      onClick: props.onBack
    }), (0, import_jsx_runtime2.jsx)(IconContainer, {
      children: (0, import_jsx_runtime2.jsx)(Img, {
        src: props.smartWallet.meta.iconURL,
        width: iconSize.xl,
        height: iconSize.xl
      })
    }), (0, import_jsx_runtime2.jsx)(Spacer, {
      y: "lg"
    }), (0, import_jsx_runtime2.jsx)(ModalTitle, {
      children: "Link Personal Wallet"
    }), (0, import_jsx_runtime2.jsx)(Spacer, {
      y: "sm"
    }), (0, import_jsx_runtime2.jsxs)(ModalDescription, {
      children: ["Select a personal wallet to access your account.", " ", (0, import_jsx_runtime2.jsxs)(HelperLink, {
        md: true,
        href: "https://portal.thirdweb.com/wallet/smart-wallet",
        target: "_blank",
        style: {
          display: "inline",
          whiteSpace: "nowrap"
        },
        children: [" ", "Learn More", " "]
      })]
    }), (0, import_jsx_runtime2.jsx)(Spacer, {
      y: "lg"
    }), (0, import_jsx_runtime2.jsx)(WalletSelection, {
      walletConfigs: personalWallets,
      selectWallet: props.selectWallet
    }), guestWallet && (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, {
      children: [(0, import_jsx_runtime2.jsx)(Spacer, {
        y: "xl"
      }), (0, import_jsx_runtime2.jsx)(Flex, {
        justifyContent: "center",
        children: (0, import_jsx_runtime2.jsx)(Button, {
          variant: "link",
          onClick: () => {
            props.selectWallet(guestWallet);
          },
          "data-test": "continue-as-guest-button",
          children: "Continue as guest"
        })
      })]
    })]
  });
};
var IconContainer = newStyled.div`
  margin-top: ${spacing.lg};
`;
var smartWallet = (config) => {
  const personalWallets = (config == null ? void 0 : config.personalWallets) || defaultWallets;
  return {
    id: SmartWallet.id,
    meta: SmartWallet.meta,
    create: (options) => new SmartWallet({
      ...options,
      ...config
    }),
    connectUI(props) {
      return (0, import_jsx_runtime2.jsx)(SmartConnectUI, {
        ...props,
        personalWallets
      });
    },
    personalWallets
  };
};
var SmartConnectUI = (props) => {
  const activeWallet = useWallet();
  const {
    walletConfig
  } = props;
  const [personalWalletConfig, setPersonalWalletConfig] = (0, import_react18.useState)();
  if (personalWalletConfig) {
    const _props = {
      close: () => {
        setPersonalWalletConfig(void 0);
        props.close(false);
      },
      goBack: () => {
        setPersonalWalletConfig(void 0);
      },
      isOpen: props.isOpen,
      open: props.open,
      theme: props.theme,
      walletConfig: personalWalletConfig,
      supportedWallets: props.personalWallets,
      selectionData: props.selectionData,
      setSelectionData: props.setSelectionData
    };
    if (personalWalletConfig.connectUI) {
      return (0, import_jsx_runtime2.jsx)(personalWalletConfig.connectUI, {
        ..._props
      });
    }
    return (0, import_jsx_runtime2.jsx)(HeadlessConnectUI, {
      ..._props
    });
  }
  if (!activeWallet) {
    return (0, import_jsx_runtime2.jsx)(SelectPersonalWallet, {
      personalWallets: props.personalWallets,
      onBack: props.goBack,
      smartWallet: walletConfig,
      selectWallet: setPersonalWalletConfig,
      renderBackButton: props.supportedWallets.length > 1
    });
  }
  return (0, import_jsx_runtime2.jsx)(SmartWalletConnecting, {
    onBack: props.goBack,
    onConnect: props.close,
    smartWallet: walletConfig
  });
};
var smartWallet$1 = Object.freeze({
  __proto__: null,
  smartWallet,
  SmartConnectUI
});
var ZerionScan = (_ref) => {
  let {
    onBack,
    onConnected,
    onGetStarted,
    walletConfig
  } = _ref;
  const createInstance = useCreateWalletInstance();
  const [qrCodeUri, setQrCodeUri] = (0, import_react18.useState)();
  const {
    setConnectedWallet,
    chainToConnect,
    setConnectionStatus
  } = useWalletContext();
  const scanStarted = (0, import_react18.useRef)(false);
  (0, import_react18.useEffect)(() => {
    if (scanStarted.current) {
      return;
    }
    scanStarted.current = true;
    const zerion = createInstance(walletConfig);
    setConnectionStatus("connecting");
    zerion.connectWithQrCode({
      chainId: chainToConnect == null ? void 0 : chainToConnect.chainId,
      onQrCodeUri(uri) {
        setQrCodeUri(uri);
      },
      onConnected() {
        setConnectedWallet(zerion);
        onConnected();
      }
    });
  }, [createInstance, setConnectedWallet, chainToConnect, onConnected, walletConfig, setConnectionStatus]);
  return (0, import_jsx_runtime2.jsx)(ScanScreen, {
    onBack,
    onGetStarted,
    qrCodeUri,
    walletName: walletConfig.meta.name,
    walletIconURL: walletConfig.meta.iconURL
  });
};
var ZerionConnectUI = (props) => {
  var _a, _b, _c;
  const [screen, setScreen] = (0, import_react18.useState)("connecting");
  const {
    walletConfig,
    close
  } = props;
  const connect = useConnect();
  const {
    goBack
  } = props;
  const connectPrompted = (0, import_react18.useRef)(false);
  (0, import_react18.useEffect)(() => {
    if (connectPrompted.current) {
      return;
    }
    const isInstalled = walletConfig.isInstalled ? walletConfig.isInstalled() : false;
    (async () => {
      if (isInstalled) {
        try {
          connectPrompted.current = true;
          setScreen("connecting");
          await connect(walletConfig);
          close();
        } catch (e) {
          goBack();
        }
      } else {
        if (isMobile()) {
          window.open("https://link.zerion.io/pt3gdRP0njb");
        } else {
          setScreen("scanning");
        }
      }
    })();
  }, [walletConfig, close, connect, goBack]);
  if (screen === "connecting") {
    return (0, import_jsx_runtime2.jsx)(ConnectingScreen, {
      onBack: props.goBack,
      walletName: walletConfig.meta.name,
      walletIconURL: walletConfig.meta.iconURL,
      supportLink: "https://help.zerion.io/en/"
    });
  }
  if (screen === "get-started") {
    return (0, import_jsx_runtime2.jsx)(GetStartedScreen, {
      walletIconURL: walletConfig.meta.iconURL,
      walletName: walletConfig.meta.name,
      chromeExtensionLink: (_a = walletConfig.meta.urls) == null ? void 0 : _a.chrome,
      googlePlayStoreLink: (_b = walletConfig.meta.urls) == null ? void 0 : _b.android,
      appleStoreLink: (_c = walletConfig.meta.urls) == null ? void 0 : _c.ios,
      onBack: props.goBack
    });
  }
  if (screen === "scanning") {
    return (0, import_jsx_runtime2.jsx)(ZerionScan, {
      onBack: props.goBack,
      onConnected: close,
      onGetStarted: () => {
        setScreen("get-started");
      },
      walletConfig
    });
  }
  return null;
};
var zerionWallet = () => {
  return {
    id: ZerionWallet.id,
    meta: ZerionWallet.meta,
    create: (options) => {
      return new ZerionWallet(options);
    },
    connectUI: ZerionConnectUI,
    isInstalled() {
      if (assertWindowEthereum(globalThis.window)) {
        return !!globalThis.window.ethereum.isZerion;
      }
      return false;
    }
  };
};
export {
  ALL_ROLES,
  APPROVED_IMPLEMENTATIONS,
  AbiObjectSchema,
  AbiSchema,
  AbiTypeSchema,
  AddressOrEnsSchema,
  AddressSchema,
  AdminRoleMissingError,
  AssetNotFoundError,
  AuctionAlreadyStartedError,
  AuctionHasNotEndedError,
  BYOCContractMetadataSchema,
  BaseSignaturePayloadInput,
  BigNumberSchema,
  BigNumberTransformSchema,
  BigNumberishSchema,
  COMMON_FACTORY,
  CONTRACTS_MAP,
  CONTRACT_ADDRESSES,
  CREATE2_FACTORY_BYTECODE,
  CallOverrideSchema,
  ChainId,
  ChainIdToAddressSchema,
  ClaimConditionInputArray,
  ClaimConditionInputSchema,
  ClaimConditionMetadataSchema,
  ClaimConditionOutputSchema,
  ClaimEligibility,
  CommonContractOutputSchema,
  CommonContractSchema,
  CommonPlatformFeeSchema,
  CommonPrimarySaleSchema,
  CommonRoyaltySchema,
  CommonSymbolSchema,
  CommonTrustedForwarderSchema,
  CompilerMetadataFetchedSchema,
  ConnectWallet,
  ContractAppURI,
  ContractDeployer,
  ContractEncoder,
  ContractEvents,
  ContractInfoSchema,
  ContractInterceptor,
  ContractMetadata,
  ContractOwner,
  ContractPlatformFee,
  ContractPrimarySale,
  ContractPublishedMetadata,
  ContractRoles,
  ContractRoyalty,
  CurrencySchema,
  CurrencyValueSchema,
  CustomContractDeploy,
  CustomContractInput,
  CustomContractOutput,
  CustomContractSchema,
  CustomFactoryInput,
  DEPLOYER_ABI,
  DEPLOYER_BYTECODE,
  DelayedReveal,
  DeployTransaction,
  DeployTypeInput,
  DeploymentNetworkInput,
  DropClaimConditions,
  DropErc1155ClaimConditions,
  DropErc1155History,
  DuplicateFileNameError,
  DuplicateLeafsError,
  EditionDropInitializer,
  EditionInitializer,
  EditionMetadataInputOrUriSchema,
  EditionMetadataInputSchema,
  EditionMetadataOutputSchema,
  EditionMetadataWithOwnerOutputSchema,
  EndDateSchema,
  Erc1155,
  Erc1155BatchMintable,
  Erc1155Burnable,
  Erc1155Enumerable,
  Erc1155LazyMintable,
  Erc1155Mintable,
  Erc1155SignatureMintable,
  Erc20,
  Erc20BatchMintable,
  Erc20Burnable,
  Erc20ClaimableWithConditions,
  Erc20Droppable,
  Erc20Mintable,
  Erc20SignatureMintable,
  Erc721,
  Erc721BatchMintable,
  Erc721Burnable,
  Erc721Claimable,
  Erc721ClaimableWithConditions,
  Erc721Enumerable,
  Erc721LazyMintable,
  Erc721Mintable,
  Erc721Supply,
  Erc721TieredDrop,
  Erc721WithQuantitySignatureMintable,
  EventType,
  ExtensionNotImplementedError,
  ExtraPublishMetadataSchemaInput,
  ExtraPublishMetadataSchemaOutput,
  FactoryDeploymentSchema,
  FetchError,
  FileNameMissingError,
  FullPublishMetadataSchemaInput,
  FullPublishMetadataSchemaOutput,
  FunctionDeprecatedError,
  GAS_LIMIT_FOR_DEPLOYER,
  GasCostEstimator,
  GenericRequest,
  InterfaceId_IERC1155,
  InterfaceId_IERC721,
  InvalidAddressError,
  LINK_TOKEN_ADDRESS,
  LOCAL_NODE_PKEY,
  ListingNotFoundError,
  ListingType,
  MarketplaceAuction,
  MarketplaceDirect,
  MarketplaceInitializer,
  MarketplaceV3DirectListings,
  MarketplaceV3EnglishAuctions,
  MarketplaceV3Initializer,
  MarketplaceV3Offers,
  MediaRenderer,
  MerkleSchema,
  MintRequest1155,
  MintRequest20,
  MintRequest721,
  MintRequest721withQuantity,
  MissingOwnerRoleError,
  MissingRoleError,
  MultiwrapInitializer,
  NATIVE_TOKENS,
  NATIVE_TOKEN_ADDRESS,
  NFTCollectionInitializer,
  NFTDropInitializer,
  NetworkSelector,
  NotEnoughTokensError,
  NotFoundError,
  OZ_DEFENDER_FORWARDER_ADDRESS,
  OptionalPropertiesInput,
  PAPER_API_URL,
  PREBUILT_CONTRACTS_APPURI_MAP,
  PREBUILT_CONTRACTS_MAP,
  PackInitializer,
  PaperCheckout,
  PartialClaimConditionInputSchema,
  PreDeployMetadata,
  PreDeployMetadataFetchedSchema,
  ProfileSchemaInput,
  ProfileSchemaOutput,
  ProposalState,
  PublishedContractSchema,
  QuantityAboveLimitError,
  RawDateSchema,
  RestrictedTransferError,
  SIGNATURE,
  SUPPORTED_CHAIN_IDS,
  SUPPORTED_FEATURES,
  Signature1155PayloadInput,
  Signature1155PayloadInputWithTokenId,
  Signature1155PayloadOutput,
  Signature20PayloadInput,
  Signature20PayloadOutput,
  Signature721PayloadInput,
  Signature721PayloadOutput,
  Signature721WithQuantityInput,
  Signature721WithQuantityOutput,
  SignatureDropInitializer,
  SnapshotEntryInput,
  SnapshotEntryWithProofSchema,
  SnapshotInfoSchema,
  SnapshotInputSchema,
  SnapshotSchema,
  SplitInitializer,
  StandardErc1155,
  StandardErc20,
  StandardErc721,
  StartDateSchema,
  StaticJsonRpcBatchProvider,
  Status,
  ThirdwebAuthProvider,
  ThirdwebConfigProvider,
  ThirdwebConnectedWalletProvider,
  ThirdwebNftMedia,
  ThirdwebProvider,
  ThirdwebProviderCore,
  ThirdwebSDK,
  ThirdwebSDKProvider,
  ThirdwebThemeContext,
  TokenDropInitializer,
  TokenERC20History,
  TokenInitializer,
  TokenMintInputSchema,
  Transaction,
  TransactionError,
  UploadError,
  UserWallet,
  VoteInitializer,
  VoteType,
  Web3Button,
  WrongListingTypeError,
  __DEV__,
  approveErc20Allowance,
  assertEnabled,
  biconomySendFunction,
  checkVerificationStatus,
  cleanCurrencyAddress,
  coinbaseWallet,
  compilerMetadata,
  computeCloneFactoryAddress,
  computeDeploymentAddress,
  computeDeploymentInfo,
  computeEOAForwarderAddress,
  computeForwarderAddress,
  computeNativeTokenAddress,
  contractType,
  convertParamValues,
  convertToReadableQuantity,
  createCheckoutLinkIntent,
  createSnapshot,
  createTransactionBatches,
  defaultGaslessSendFunction,
  defenderSendFunction,
  deployContractDeterministic,
  deployContractDeterministicRaw,
  deployCreate2Factory,
  deployWithThrowawayDeployer,
  detectContractFeature,
  detectFeatures,
  directDeployDeterministic,
  directDeployDeterministicWithUri,
  encodeConstructorParamsForImplementation,
  estimateGasForDeploy,
  extractCommentFromMetadata,
  extractConstructorParams,
  extractConstructorParamsFromAbi,
  extractEventsFromAbi,
  extractFunctionParamsFromAbi,
  extractFunctions,
  extractFunctionsFromAbi,
  extractIPFSHashFromBytecode,
  extractMinimalProxyImplementationAddress,
  fetchAbiFromAddress,
  fetchAndCacheDeployMetadata,
  fetchAndCachePublishedContractURI,
  fetchContractMetadataFromAddress,
  fetchCurrencyMetadata,
  fetchCurrencyValue,
  fetchExtendedReleaseMetadata,
  fetchPreDeployMetadata,
  fetchRawPredeployMetadata,
  fetchRegisteredCheckoutId,
  fetchSnapshotEntryForAddress,
  fetchSourceFilesFromMetadata,
  frameWallet,
  getAllDetectedExtensionNames,
  getAllDetectedExtensions,
  getAllDetectedFeatureNames,
  getAllDetectedFeatures,
  getApprovedImplementation,
  getBlock,
  getBlockNumber,
  getBlockWithTransactions,
  getCachedAbiForContract,
  getChainId,
  getChainIdFromNetwork,
  getChainProvider,
  getContract,
  getContractAddressByChainId,
  getContractFromAbi,
  getContractName,
  getContractPublisherAddress,
  getContractTypeForRemoteName,
  getCreate2FactoryAddress,
  getCreate2FactoryDeploymentInfo,
  getDefaultTrustedForwarders,
  getDeployArguments,
  getDeploymentInfo,
  getEncodedConstructorParamsForThirdwebContract,
  getErc1155,
  getErc20,
  getErc721,
  getErcs,
  getInitBytecodeWithSalt,
  getKeylessTxn,
  getMultichainRegistryAddress,
  getNativeTokenByChainId,
  getProviderFromRpcUrl,
  getRoleHash,
  getRpcUrl,
  getSaltHash,
  getSignerAndProvider,
  getSupportedChains,
  getThirdwebContractAddress,
  getTrustedForwarders,
  hasERC20Allowance,
  hasFunction,
  hasMatchingAbi,
  includesErrorMessage,
  isChainConfig,
  isContractDeployed,
  isDowngradeVersion,
  isEIP155Enforced,
  isExtensionEnabled,
  isFeatureEnabled,
  isIncrementalVersion,
  isNativeToken,
  isProvider,
  isSigner,
  isVerifiedOnEtherscan,
  localWallet,
  magicLink,
  matchesPrebuiltAbi,
  metamaskWallet,
  normalizeAmount,
  normalizePriceValue,
  paperWallet,
  parseChainIdToPaperChain,
  parseRevertReason,
  predictAddressDeterministic,
  predictAddressDeterministicWithUri,
  predictThirdwebContractAddress,
  prepareGaslessRequest,
  resolveAddress,
  resolveContractUriFromAddress,
  resolveEns,
  resolveIpfsUri,
  resolveMimeType,
  safeWallet,
  setErc20Allowance,
  setSupportedChains,
  shouldNeverPersistQuery,
  smartWallet,
  toDisplayValue,
  toEther,
  toSemver,
  toUnits,
  toWei,
  useAcceptDirectListingOffer,
  useActiveChain,
  useActiveClaimCondition,
  useActiveClaimConditionForWallet,
  useActiveListings,
  useAddress,
  useAirdropNFT,
  useAllRoleMembers,
  useAppURI,
  useAuctionWinner,
  useAuth,
  useBalance,
  useBatchesToReveal,
  useBidBuffer,
  useBurnNFT,
  useBurnToken,
  useBuyDirectListing,
  useBuyNow,
  useCancelDirectListing,
  useCancelEnglishAuction,
  useCancelListing,
  useChain,
  useChainId,
  useClaimConditions,
  useClaimIneligibilityReasons,
  useClaimNFT,
  useClaimToken,
  useClaimedNFTSupply,
  useClaimedNFTs,
  useClaimerProofs,
  useCoinbaseWallet,
  useCompilerMetadata,
  useConnect,
  useConnectedWallet,
  useConnectionStatus,
  useContract,
  useContractEvents,
  useContractMetadata,
  useContractMetadataUpdate,
  useContractRead,
  useContractType,
  useContractWrite,
  useCreateAuctionListing,
  useCreateDirectListing,
  useCreateSmartWallet,
  useCreateWalletInstance,
  useDelayedRevealLazyMint,
  useDirectListing,
  useDirectListings,
  useDirectListingsCount,
  useDisconnect,
  useEdition,
  useEditionDrop,
  useEnglishAuction,
  useEnglishAuctionWinningBid,
  useEnglishAuctions,
  useEnglishAuctionsCount,
  useExecuteAuctionSale,
  useFrameWallet,
  useGrantRole,
  useInstalledWallets,
  useIsAddressRole,
  useIsSmartWalletDeployed,
  useIsWalletModalOpen,
  useLazyMint,
  useListing,
  useListings,
  useListingsCount,
  useLogin,
  useLogout,
  useMagic,
  useMakeBid,
  useMakeOffer,
  useMarketplace,
  useMetadata,
  useMetamask,
  useMinimumNextBid,
  useMintNFT,
  useMintNFTSupply,
  useMintToken,
  useMultiwrap,
  useNFT,
  useNFTBalance,
  useNFTCollection,
  useNFTDrop,
  useNFTs,
  useNetwork,
  useNetworkMismatch,
  useOffers,
  useOwnedNFTs,
  usePack,
  usePaperWallet,
  usePaperWalletUserEmail,
  usePlatformFees,
  usePrimarySaleRecipient,
  useReadonlySDK,
  useResetClaimConditions,
  useResolvedMediaType,
  useRevealLazyMint,
  useRevokeRole,
  useRoleMembers,
  useRoyaltySettings,
  useSDK,
  useSDKChainId,
  useSafe,
  useSetAllRoleMembers,
  useSetAppURI,
  useSetClaimConditions,
  useSetConnectedWallet,
  useSetConnectionStatus,
  useSetIsWalletModalOpen,
  useSignatureDrop,
  useSigner,
  useSmartWallet,
  useSmartWallets,
  useSplit,
  useStorage,
  useStorageUpload,
  useSupportedChains,
  useSupportedWallet,
  useSwitchAccount,
  useSwitchChain,
  useThirdwebAuthContext,
  useThirdwebConfigContext,
  useThirdwebConnectedWalletContext,
  useToken,
  useTokenBalance,
  useTokenDecimals,
  useTokenDrop,
  useTokenSupply,
  useTotalCirculatingSupply,
  useTotalCount,
  useTransferBatchToken,
  useTransferNFT,
  useTransferToken,
  useUnclaimedNFTSupply,
  useUnclaimedNFTs,
  useUpdateMetadata,
  useUpdatePlatformFees,
  useUpdatePrimarySaleRecipient,
  useUpdateRoyaltySettings,
  useUser,
  useValidDirectListings,
  useValidEnglishAuctions,
  useVote,
  useWallet,
  useWalletConfig,
  useWalletConnect,
  useWalletConnectV1,
  useWalletContext,
  useWallets,
  useWatchTransactions,
  useWinningBid,
  verify,
  verifyThirdwebPrebuiltImplementation,
  walletConnect,
  walletConnectV1,
  watchBlock,
  watchBlockNumber,
  watchBlockWithTransactions,
  watchTransactions,
  zerionWallet
};
//# sourceMappingURL=@thirdweb-dev_react.js.map
