import {
  IEvents,
  RELAY_JSONRPC,
  encodeIss,
  esm_exports,
  generateKeyPair,
  init_esm,
  require_browser,
  require_chacha20poly1305,
  require_cjs,
  require_cjs2,
  require_hkdf,
  require_lodash,
  require_random,
  require_sha256,
  require_x25519,
  signJWT
} from "./chunk-BENPVMCZ.js";
import {
  require_src,
  require_src2,
  require_src3
} from "./chunk-RM25UG3Z.js";
import {
  assertWindowEthereum
} from "./chunk-FETDTUNB.js";
import {
  addHexPrefix,
  aesCbcDecrypt,
  aesCbcEncrypt,
  arrayToBuffer,
  arrayToHex,
  arrayToUtf8,
  browser_exports,
  bufferToArray,
  concatArrays,
  hexToArray,
  hmacSha256Sign,
  init_esm as init_esm4,
  isHexString,
  randomBytes,
  removeHexLeadingZeros,
  removeHexPrefix,
  sanitizeHex,
  utf8ToArray,
  utf8ToBuffer,
  utf8ToHex
} from "./chunk-7EEN2ZWX.js";
import {
  JsonRpcProvider,
  detect,
  esm_exports as esm_exports2,
  formatJsonRpcError,
  formatJsonRpcRequest,
  formatJsonRpcResult,
  getBigIntRpcId,
  init_es,
  init_esm as init_esm2,
  init_esm3,
  isJsonRpcError,
  isJsonRpcRequest,
  isJsonRpcResponse,
  isJsonRpcResult,
  isLocalhostUrl,
  isWsUrl,
  parseConnectionError,
  payloadId,
  require_cjs as require_cjs3,
  require_cjs2 as require_cjs4,
  require_decode_uri_component,
  require_filter_obj,
  require_split_on_first,
  require_strict_uri_encode,
  require_tslib,
  safeJsonParse,
  safeJsonStringify
} from "./chunk-SXM3NUOY.js";
import {
  require_events
} from "./chunk-L4L7HN5R.js";
import {
  _classPrivateMethodGet,
  _classPrivateMethodInitSpec
} from "./chunk-JG4XYP4Y.js";
import {
  walletIds
} from "./chunk-OLCE3NRE.js";
import {
  WagmiAdapter
} from "./chunk-56PDSJSZ.js";
import {
  _classPrivateFieldGet,
  _classPrivateFieldInitSpec,
  _classPrivateFieldSet
} from "./chunk-TJDZPDYI.js";
import {
  _defineProperty
} from "./chunk-UZDOK4BQ.js";
import {
  concat,
  fromString,
  toString
} from "./chunk-XUXNDKXO.js";
import {
  c1,
  defaultChains
} from "./chunk-MF32MPNC.js";
import {
  eventemitter3_default
} from "./chunk-24M2PVBU.js";
import {
  Contract,
  Wallet,
  init_lib7 as init_lib3,
  utils_exports
} from "./chunk-T4GQYX7O.js";
import {
  hashMessage,
  init_lib11 as init_lib,
  init_lib15 as init_lib2,
  lib_exports19 as lib_exports,
  recoverAddress,
  require_sha3
} from "./chunk-RGAYGF33.js";
import {
  global,
  import_process,
  init_shim,
  require_buffer
} from "./chunk-ZGMFR26H.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-IKJM6GHQ.js";

// node_modules/@walletconnect/heartbeat/dist/cjs/types/heartbeat.js
var require_heartbeat = __commonJS({
  "node_modules/@walletconnect/heartbeat/dist/cjs/types/heartbeat.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IHeartBeat = void 0;
    var events_1 = (init_esm(), __toCommonJS(esm_exports));
    var IHeartBeat = class extends events_1.IEvents {
      constructor(opts) {
        super();
      }
    };
    exports.IHeartBeat = IHeartBeat;
  }
});

// node_modules/@walletconnect/heartbeat/dist/cjs/types/index.js
var require_types = __commonJS({
  "node_modules/@walletconnect/heartbeat/dist/cjs/types/index.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_heartbeat(), exports);
  }
});

// node_modules/@walletconnect/heartbeat/dist/cjs/constants/heartbeat.js
var require_heartbeat2 = __commonJS({
  "node_modules/@walletconnect/heartbeat/dist/cjs/constants/heartbeat.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HEARTBEAT_EVENTS = exports.HEARTBEAT_INTERVAL = void 0;
    var time_1 = require_cjs();
    exports.HEARTBEAT_INTERVAL = time_1.FIVE_SECONDS;
    exports.HEARTBEAT_EVENTS = {
      pulse: "heartbeat_pulse"
    };
  }
});

// node_modules/@walletconnect/heartbeat/dist/cjs/constants/index.js
var require_constants = __commonJS({
  "node_modules/@walletconnect/heartbeat/dist/cjs/constants/index.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_heartbeat2(), exports);
  }
});

// node_modules/@walletconnect/heartbeat/dist/cjs/heartbeat.js
var require_heartbeat3 = __commonJS({
  "node_modules/@walletconnect/heartbeat/dist/cjs/heartbeat.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HeartBeat = void 0;
    var tslib_1 = require_tslib();
    var events_1 = require_events();
    var time_1 = require_cjs();
    var types_1 = require_types();
    var constants_1 = require_constants();
    var HeartBeat = class extends types_1.IHeartBeat {
      constructor(opts) {
        super(opts);
        this.events = new events_1.EventEmitter();
        this.interval = constants_1.HEARTBEAT_INTERVAL;
        this.interval = (opts === null || opts === void 0 ? void 0 : opts.interval) || constants_1.HEARTBEAT_INTERVAL;
      }
      static init(opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const heartbeat = new HeartBeat(opts);
          yield heartbeat.init();
          return heartbeat;
        });
      }
      init() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          yield this.initialize();
        });
      }
      stop() {
        clearInterval(this.intervalRef);
      }
      on(event, listener) {
        this.events.on(event, listener);
      }
      once(event, listener) {
        this.events.once(event, listener);
      }
      off(event, listener) {
        this.events.off(event, listener);
      }
      removeListener(event, listener) {
        this.events.removeListener(event, listener);
      }
      initialize() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          this.intervalRef = setInterval(() => this.pulse(), time_1.toMiliseconds(this.interval));
        });
      }
      pulse() {
        this.events.emit(constants_1.HEARTBEAT_EVENTS.pulse);
      }
    };
    exports.HeartBeat = HeartBeat;
  }
});

// node_modules/@walletconnect/heartbeat/dist/cjs/index.js
var require_cjs5 = __commonJS({
  "node_modules/@walletconnect/heartbeat/dist/cjs/index.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_heartbeat3(), exports);
    tslib_1.__exportStar(require_types(), exports);
    tslib_1.__exportStar(require_constants(), exports);
  }
});

// node_modules/@walletconnect/utils/node_modules/query-string/index.js
var require_query_string = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/query-string/index.js"(exports) {
    "use strict";
    init_shim();
    var strictUriEncode = require_strict_uri_encode();
    var decodeComponent = require_decode_uri_component();
    var splitOnFirst = require_split_on_first();
    var filterObject = require_filter_obj();
    var isNullOrUndefined = (value) => value === null || value === void 0;
    var encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case "index":
          return (key) => (result, value) => {
            const index = result.length;
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), "[", index, "]"].join("")];
            }
            return [
              ...result,
              [encode(key, options), "[", encode(index, options), "]=", encode(value, options)].join("")
            ];
          };
        case "bracket":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), "[]"].join("")];
            }
            return [...result, [encode(key, options), "[]=", encode(value, options)].join("")];
          };
        case "colon-list-separator":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), ":list="].join("")];
            }
            return [...result, [encode(key, options), ":list=", encode(value, options)].join("")];
          };
        case "comma":
        case "separator":
        case "bracket-separator": {
          const keyValueSep = options.arrayFormat === "bracket-separator" ? "[]=" : "=";
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            value = value === null ? "" : value;
            if (result.length === 0) {
              return [[encode(key, options), keyValueSep, encode(value, options)].join("")];
            }
            return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
          };
        }
        default:
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, encode(key, options)];
            }
            return [...result, [encode(key, options), "=", encode(value, options)].join("")];
          };
      }
    }
    function parserForArrayFormat(options) {
      let result;
      switch (options.arrayFormat) {
        case "index":
          return (key, value, accumulator) => {
            result = /\[(\d*)\]$/.exec(key);
            key = key.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = {};
            }
            accumulator[key][result[1]] = value;
          };
        case "bracket":
          return (key, value, accumulator) => {
            result = /(\[\])$/.exec(key);
            key = key.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "colon-list-separator":
          return (key, value, accumulator) => {
            result = /(:list)$/.exec(key);
            key = key.replace(/:list$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "comma":
        case "separator":
          return (key, value, accumulator) => {
            const isArray = typeof value === "string" && value.includes(options.arrayFormatSeparator);
            const isEncodedArray = typeof value === "string" && !isArray && decode(value, options).includes(options.arrayFormatSeparator);
            value = isEncodedArray ? decode(value, options) : value;
            const newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item) => decode(item, options)) : value === null ? value : decode(value, options);
            accumulator[key] = newValue;
          };
        case "bracket-separator":
          return (key, value, accumulator) => {
            const isArray = /(\[\])$/.test(key);
            key = key.replace(/\[\]$/, "");
            if (!isArray) {
              accumulator[key] = value ? decode(value, options) : value;
              return;
            }
            const arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map((item) => decode(item, options));
            if (accumulator[key] === void 0) {
              accumulator[key] = arrayValue;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], arrayValue);
          };
        default:
          return (key, value, accumulator) => {
            if (accumulator[key] === void 0) {
              accumulator[key] = value;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
      }
    }
    function validateArrayFormatSeparator(value) {
      if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
      }
    }
    function encode(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
      }
      return value;
    }
    function decode(value, options) {
      if (options.decode) {
        return decodeComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }
      if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort((a3, b5) => Number(a3) - Number(b5)).map((key) => input[key]);
      }
      return input;
    }
    function removeHash(input) {
      const hashStart = input.indexOf("#");
      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }
      return input;
    }
    function getHash(url) {
      let hash = "";
      const hashStart = url.indexOf("#");
      if (hashStart !== -1) {
        hash = url.slice(hashStart);
      }
      return hash;
    }
    function extract(input) {
      input = removeHash(input);
      const queryStart = input.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return input.slice(queryStart + 1);
    }
    function parseValue(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        value = value.toLowerCase() === "true";
      }
      return value;
    }
    function parse6(query, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const formatter = parserForArrayFormat(options);
      const ret = /* @__PURE__ */ Object.create(null);
      if (typeof query !== "string") {
        return ret;
      }
      query = query.trim().replace(/^[?#&]/, "");
      if (!query) {
        return ret;
      }
      for (const param of query.split("&")) {
        if (param === "") {
          continue;
        }
        let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
        value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options.arrayFormat) ? value : decode(value, options);
        formatter(decode(key, options), value, ret);
      }
      for (const key of Object.keys(ret)) {
        const value = ret[key];
        if (typeof value === "object" && value !== null) {
          for (const k3 of Object.keys(value)) {
            value[k3] = parseValue(value[k3], options);
          }
        } else {
          ret[key] = parseValue(value, options);
        }
      }
      if (options.sort === false) {
        return ret;
      }
      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
        const value = ret[key];
        if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
          result[key] = keysSorter(value);
        } else {
          result[key] = value;
        }
        return result;
      }, /* @__PURE__ */ Object.create(null));
    }
    exports.extract = extract;
    exports.parse = parse6;
    exports.stringify = (object, options) => {
      if (!object) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const shouldFilter = (key) => options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === "";
      const formatter = encoderForArrayFormat(options);
      const objectCopy = {};
      for (const key of Object.keys(object)) {
        if (!shouldFilter(key)) {
          objectCopy[key] = object[key];
        }
      }
      const keys = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys.sort(options.sort);
      }
      return keys.map((key) => {
        const value = object[key];
        if (value === void 0) {
          return "";
        }
        if (value === null) {
          return encode(key, options);
        }
        if (Array.isArray(value)) {
          if (value.length === 0 && options.arrayFormat === "bracket-separator") {
            return encode(key, options) + "[]";
          }
          return value.reduce(formatter(key), []).join("&");
        }
        return encode(key, options) + "=" + encode(value, options);
      }).filter((x4) => x4.length > 0).join("&");
    };
    exports.parseUrl = (url, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url_, hash] = splitOnFirst(url, "#");
      return Object.assign(
        {
          url: url_.split("?")[0] || "",
          query: parse6(extract(url), options)
        },
        options && options.parseFragmentIdentifier && hash ? { fragmentIdentifier: decode(hash, options) } : {}
      );
    };
    exports.stringifyUrl = (object, options) => {
      options = Object.assign({
        encode: true,
        strict: true,
        [encodeFragmentIdentifier]: true
      }, options);
      const url = removeHash(object.url).split("?")[0] || "";
      const queryFromUrl = exports.extract(object.url);
      const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
      const query = Object.assign(parsedQueryFromUrl, object.query);
      let queryString = exports.stringify(query, options);
      if (queryString) {
        queryString = `?${queryString}`;
      }
      let hash = getHash(object.url);
      if (object.fragmentIdentifier) {
        hash = `#${options[encodeFragmentIdentifier] ? encode(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;
      }
      return `${url}${queryString}${hash}`;
    };
    exports.pick = (input, filter, options) => {
      options = Object.assign({
        parseFragmentIdentifier: true,
        [encodeFragmentIdentifier]: false
      }, options);
      const { url, query, fragmentIdentifier } = exports.parseUrl(input, options);
      return exports.stringifyUrl({
        url,
        query: filterObject(query, filter),
        fragmentIdentifier
      }, options);
    };
    exports.exclude = (input, filter, options) => {
      const exclusionFilter = Array.isArray(filter) ? (key) => !filter.includes(key) : (key, value) => !filter(key, value);
      return exports.pick(input, exclusionFilter, options);
    };
  }
});

// node_modules/@walletconnect/jsonrpc-ws-connection/node_modules/ws/browser.js
var require_browser2 = __commonJS({
  "node_modules/@walletconnect/jsonrpc-ws-connection/node_modules/ws/browser.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// node_modules/unfetch/dist/unfetch.module.js
var unfetch_module_exports = {};
__export(unfetch_module_exports, {
  default: () => unfetch_module_default
});
function unfetch_module_default(e, n3) {
  return n3 = n3 || {}, new Promise(function(t, r) {
    var s = new XMLHttpRequest(), o2 = [], u5 = [], i3 = {}, a3 = function() {
      return { ok: 2 == (s.status / 100 | 0), statusText: s.statusText, status: s.status, url: s.responseURL, text: function() {
        return Promise.resolve(s.responseText);
      }, json: function() {
        return Promise.resolve(s.responseText).then(JSON.parse);
      }, blob: function() {
        return Promise.resolve(new Blob([s.response]));
      }, clone: a3, headers: { keys: function() {
        return o2;
      }, entries: function() {
        return u5;
      }, get: function(e2) {
        return i3[e2.toLowerCase()];
      }, has: function(e2) {
        return e2.toLowerCase() in i3;
      } } };
    };
    for (var l2 in s.open(n3.method || "get", e, true), s.onload = function() {
      s.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm, function(e2, n4, t2) {
        o2.push(n4 = n4.toLowerCase()), u5.push([n4, t2]), i3[n4] = i3[n4] ? i3[n4] + "," + t2 : t2;
      }), t(a3());
    }, s.onerror = r, s.withCredentials = "include" == n3.credentials, n3.headers)
      s.setRequestHeader(l2, n3.headers[l2]);
    s.send(n3.body || null);
  });
}
var init_unfetch_module = __esm({
  "node_modules/unfetch/dist/unfetch.module.js"() {
    init_shim();
  }
});

// node_modules/isomorphic-unfetch/browser.js
var require_browser3 = __commonJS({
  "node_modules/isomorphic-unfetch/browser.js"(exports, module) {
    init_shim();
    module.exports = self.fetch || (self.fetch = (init_unfetch_module(), __toCommonJS(unfetch_module_exports)).default || (init_unfetch_module(), __toCommonJS(unfetch_module_exports)));
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/query-string/index.js
var require_query_string2 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/query-string/index.js"(exports) {
    "use strict";
    init_shim();
    var strictUriEncode = require_strict_uri_encode();
    var decodeComponent = require_decode_uri_component();
    var splitOnFirst = require_split_on_first();
    var filterObject = require_filter_obj();
    var isNullOrUndefined = (value) => value === null || value === void 0;
    var encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case "index":
          return (key) => (result, value) => {
            const index = result.length;
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), "[", index, "]"].join("")];
            }
            return [
              ...result,
              [encode(key, options), "[", encode(index, options), "]=", encode(value, options)].join("")
            ];
          };
        case "bracket":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), "[]"].join("")];
            }
            return [...result, [encode(key, options), "[]=", encode(value, options)].join("")];
          };
        case "colon-list-separator":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), ":list="].join("")];
            }
            return [...result, [encode(key, options), ":list=", encode(value, options)].join("")];
          };
        case "comma":
        case "separator":
        case "bracket-separator": {
          const keyValueSep = options.arrayFormat === "bracket-separator" ? "[]=" : "=";
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            value = value === null ? "" : value;
            if (result.length === 0) {
              return [[encode(key, options), keyValueSep, encode(value, options)].join("")];
            }
            return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
          };
        }
        default:
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, encode(key, options)];
            }
            return [...result, [encode(key, options), "=", encode(value, options)].join("")];
          };
      }
    }
    function parserForArrayFormat(options) {
      let result;
      switch (options.arrayFormat) {
        case "index":
          return (key, value, accumulator) => {
            result = /\[(\d*)\]$/.exec(key);
            key = key.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = {};
            }
            accumulator[key][result[1]] = value;
          };
        case "bracket":
          return (key, value, accumulator) => {
            result = /(\[\])$/.exec(key);
            key = key.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "colon-list-separator":
          return (key, value, accumulator) => {
            result = /(:list)$/.exec(key);
            key = key.replace(/:list$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "comma":
        case "separator":
          return (key, value, accumulator) => {
            const isArray = typeof value === "string" && value.includes(options.arrayFormatSeparator);
            const isEncodedArray = typeof value === "string" && !isArray && decode(value, options).includes(options.arrayFormatSeparator);
            value = isEncodedArray ? decode(value, options) : value;
            const newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item) => decode(item, options)) : value === null ? value : decode(value, options);
            accumulator[key] = newValue;
          };
        case "bracket-separator":
          return (key, value, accumulator) => {
            const isArray = /(\[\])$/.test(key);
            key = key.replace(/\[\]$/, "");
            if (!isArray) {
              accumulator[key] = value ? decode(value, options) : value;
              return;
            }
            const arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map((item) => decode(item, options));
            if (accumulator[key] === void 0) {
              accumulator[key] = arrayValue;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], arrayValue);
          };
        default:
          return (key, value, accumulator) => {
            if (accumulator[key] === void 0) {
              accumulator[key] = value;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
      }
    }
    function validateArrayFormatSeparator(value) {
      if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
      }
    }
    function encode(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
      }
      return value;
    }
    function decode(value, options) {
      if (options.decode) {
        return decodeComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }
      if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort((a3, b5) => Number(a3) - Number(b5)).map((key) => input[key]);
      }
      return input;
    }
    function removeHash(input) {
      const hashStart = input.indexOf("#");
      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }
      return input;
    }
    function getHash(url) {
      let hash = "";
      const hashStart = url.indexOf("#");
      if (hashStart !== -1) {
        hash = url.slice(hashStart);
      }
      return hash;
    }
    function extract(input) {
      input = removeHash(input);
      const queryStart = input.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return input.slice(queryStart + 1);
    }
    function parseValue(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        value = value.toLowerCase() === "true";
      }
      return value;
    }
    function parse6(query, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const formatter = parserForArrayFormat(options);
      const ret = /* @__PURE__ */ Object.create(null);
      if (typeof query !== "string") {
        return ret;
      }
      query = query.trim().replace(/^[?#&]/, "");
      if (!query) {
        return ret;
      }
      for (const param of query.split("&")) {
        if (param === "") {
          continue;
        }
        let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
        value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options.arrayFormat) ? value : decode(value, options);
        formatter(decode(key, options), value, ret);
      }
      for (const key of Object.keys(ret)) {
        const value = ret[key];
        if (typeof value === "object" && value !== null) {
          for (const k3 of Object.keys(value)) {
            value[k3] = parseValue(value[k3], options);
          }
        } else {
          ret[key] = parseValue(value, options);
        }
      }
      if (options.sort === false) {
        return ret;
      }
      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
        const value = ret[key];
        if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
          result[key] = keysSorter(value);
        } else {
          result[key] = value;
        }
        return result;
      }, /* @__PURE__ */ Object.create(null));
    }
    exports.extract = extract;
    exports.parse = parse6;
    exports.stringify = (object, options) => {
      if (!object) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const shouldFilter = (key) => options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === "";
      const formatter = encoderForArrayFormat(options);
      const objectCopy = {};
      for (const key of Object.keys(object)) {
        if (!shouldFilter(key)) {
          objectCopy[key] = object[key];
        }
      }
      const keys = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys.sort(options.sort);
      }
      return keys.map((key) => {
        const value = object[key];
        if (value === void 0) {
          return "";
        }
        if (value === null) {
          return encode(key, options);
        }
        if (Array.isArray(value)) {
          if (value.length === 0 && options.arrayFormat === "bracket-separator") {
            return encode(key, options) + "[]";
          }
          return value.reduce(formatter(key), []).join("&");
        }
        return encode(key, options) + "=" + encode(value, options);
      }).filter((x4) => x4.length > 0).join("&");
    };
    exports.parseUrl = (url, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url_, hash] = splitOnFirst(url, "#");
      return Object.assign(
        {
          url: url_.split("?")[0] || "",
          query: parse6(extract(url), options)
        },
        options && options.parseFragmentIdentifier && hash ? { fragmentIdentifier: decode(hash, options) } : {}
      );
    };
    exports.stringifyUrl = (object, options) => {
      options = Object.assign({
        encode: true,
        strict: true,
        [encodeFragmentIdentifier]: true
      }, options);
      const url = removeHash(object.url).split("?")[0] || "";
      const queryFromUrl = exports.extract(object.url);
      const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
      const query = Object.assign(parsedQueryFromUrl, object.query);
      let queryString = exports.stringify(query, options);
      if (queryString) {
        queryString = `?${queryString}`;
      }
      let hash = getHash(object.url);
      if (object.fragmentIdentifier) {
        hash = `#${options[encodeFragmentIdentifier] ? encode(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;
      }
      return `${url}${queryString}${hash}`;
    };
    exports.pick = (input, filter, options) => {
      options = Object.assign({
        parseFragmentIdentifier: true,
        [encodeFragmentIdentifier]: false
      }, options);
      const { url, query, fragmentIdentifier } = exports.parseUrl(input, options);
      return exports.stringifyUrl({
        url,
        query: filterObject(query, filter),
        fragmentIdentifier
      }, options);
    };
    exports.exclude = (input, filter, options) => {
      const exclusionFilter = Array.isArray(filter) ? (key) => !filter.includes(key) : (key, value) => !filter(key, value);
      return exports.pick(input, exclusionFilter, options);
    };
  }
});

// node_modules/@walletconnect/browser-utils/node_modules/@walletconnect/window-getters/dist/cjs/index.js
var require_cjs6 = __commonJS({
  "node_modules/@walletconnect/browser-utils/node_modules/@walletconnect/window-getters/dist/cjs/index.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLocalStorage = exports.getLocalStorageOrThrow = exports.getCrypto = exports.getCryptoOrThrow = exports.getLocation = exports.getLocationOrThrow = exports.getNavigator = exports.getNavigatorOrThrow = exports.getDocument = exports.getDocumentOrThrow = exports.getFromWindowOrThrow = exports.getFromWindow = void 0;
    function getFromWindow2(name) {
      let res = void 0;
      if (typeof window !== "undefined" && typeof window[name] !== "undefined") {
        res = window[name];
      }
      return res;
    }
    exports.getFromWindow = getFromWindow2;
    function getFromWindowOrThrow2(name) {
      const res = getFromWindow2(name);
      if (!res) {
        throw new Error(`${name} is not defined in Window`);
      }
      return res;
    }
    exports.getFromWindowOrThrow = getFromWindowOrThrow2;
    function getDocumentOrThrow2() {
      return getFromWindowOrThrow2("document");
    }
    exports.getDocumentOrThrow = getDocumentOrThrow2;
    function getDocument2() {
      return getFromWindow2("document");
    }
    exports.getDocument = getDocument2;
    function getNavigatorOrThrow2() {
      return getFromWindowOrThrow2("navigator");
    }
    exports.getNavigatorOrThrow = getNavigatorOrThrow2;
    function getNavigator3() {
      return getFromWindow2("navigator");
    }
    exports.getNavigator = getNavigator3;
    function getLocationOrThrow2() {
      return getFromWindowOrThrow2("location");
    }
    exports.getLocationOrThrow = getLocationOrThrow2;
    function getLocation3() {
      return getFromWindow2("location");
    }
    exports.getLocation = getLocation3;
    function getCryptoOrThrow2() {
      return getFromWindowOrThrow2("crypto");
    }
    exports.getCryptoOrThrow = getCryptoOrThrow2;
    function getCrypto2() {
      return getFromWindow2("crypto");
    }
    exports.getCrypto = getCrypto2;
    function getLocalStorageOrThrow2() {
      return getFromWindowOrThrow2("localStorage");
    }
    exports.getLocalStorageOrThrow = getLocalStorageOrThrow2;
    function getLocalStorage3() {
      return getFromWindow2("localStorage");
    }
    exports.getLocalStorage = getLocalStorage3;
  }
});

// node_modules/@walletconnect/browser-utils/node_modules/@walletconnect/window-metadata/dist/cjs/index.js
var require_cjs7 = __commonJS({
  "node_modules/@walletconnect/browser-utils/node_modules/@walletconnect/window-metadata/dist/cjs/index.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getWindowMetadata = void 0;
    var window_getters_1 = require_cjs6();
    function getWindowMetadata2() {
      let doc;
      let loc;
      try {
        doc = window_getters_1.getDocumentOrThrow();
        loc = window_getters_1.getLocationOrThrow();
      } catch (e) {
        return null;
      }
      function getIcons() {
        const links = doc.getElementsByTagName("link");
        const icons2 = [];
        for (let i3 = 0; i3 < links.length; i3++) {
          const link = links[i3];
          const rel = link.getAttribute("rel");
          if (rel) {
            if (rel.toLowerCase().indexOf("icon") > -1) {
              const href = link.getAttribute("href");
              if (href) {
                if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
                  let absoluteHref = loc.protocol + "//" + loc.host;
                  if (href.indexOf("/") === 0) {
                    absoluteHref += href;
                  } else {
                    const path = loc.pathname.split("/");
                    path.pop();
                    const finalPath = path.join("/");
                    absoluteHref += finalPath + "/" + href;
                  }
                  icons2.push(absoluteHref);
                } else if (href.indexOf("//") === 0) {
                  const absoluteUrl = loc.protocol + href;
                  icons2.push(absoluteUrl);
                } else {
                  icons2.push(href);
                }
              }
            }
          }
        }
        return icons2;
      }
      function getWindowMetadataOfAny(...args) {
        const metaTags = doc.getElementsByTagName("meta");
        for (let i3 = 0; i3 < metaTags.length; i3++) {
          const tag = metaTags[i3];
          const attributes = ["itemprop", "property", "name"].map((target) => tag.getAttribute(target)).filter((attr) => {
            if (attr) {
              return args.includes(attr);
            }
            return false;
          });
          if (attributes.length && attributes) {
            const content = tag.getAttribute("content");
            if (content) {
              return content;
            }
          }
        }
        return "";
      }
      function getName() {
        let name2 = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
        if (!name2) {
          name2 = doc.title;
        }
        return name2;
      }
      function getDescription() {
        const description2 = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
        return description2;
      }
      const name = getName();
      const description = getDescription();
      const url = loc.origin;
      const icons = getIcons();
      const meta = {
        description,
        url,
        icons,
        name
      };
      return meta;
    }
    exports.getWindowMetadata = getWindowMetadata2;
  }
});

// node_modules/@walletconnect/client/node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/@walletconnect/client/node_modules/bn.js/lib/bn.js"(exports, module) {
    init_shim();
    (function(module2, exports2) {
      "use strict";
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN4(number, base, endian) {
        if (BN4.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN4;
      } else {
        exports2.BN = BN4;
      }
      BN4.BN = BN4;
      BN4.wordSize = 26;
      var Buffer2;
      try {
        Buffer2 = require_buffer().Buffer;
      } catch (e) {
      }
      BN4.isBN = function isBN(num) {
        if (num instanceof BN4) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN4.wordSize && Array.isArray(num.words);
      };
      BN4.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN4.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN4.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
        }
        if (base === 16) {
          this._parseHex(number, start);
        } else {
          this._parseBase(number, base, start);
        }
        if (number[0] === "-") {
          this.negative = 1;
        }
        this.strip();
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN4.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN4.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i3 = 0; i3 < this.length; i3++) {
          this.words[i3] = 0;
        }
        var j6, w5;
        var off = 0;
        if (endian === "be") {
          for (i3 = number.length - 1, j6 = 0; i3 >= 0; i3 -= 3) {
            w5 = number[i3] | number[i3 - 1] << 8 | number[i3 - 2] << 16;
            this.words[j6] |= w5 << off & 67108863;
            this.words[j6 + 1] = w5 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j6++;
            }
          }
        } else if (endian === "le") {
          for (i3 = 0, j6 = 0; i3 < number.length; i3 += 3) {
            w5 = number[i3] | number[i3 + 1] << 8 | number[i3 + 2] << 16;
            this.words[j6] |= w5 << off & 67108863;
            this.words[j6 + 1] = w5 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j6++;
            }
          }
        }
        return this.strip();
      };
      function parseHex(str, start, end) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i3 = start; i3 < len; i3++) {
          var c3 = str.charCodeAt(i3) - 48;
          r <<= 4;
          if (c3 >= 49 && c3 <= 54) {
            r |= c3 - 49 + 10;
          } else if (c3 >= 17 && c3 <= 22) {
            r |= c3 - 17 + 10;
          } else {
            r |= c3 & 15;
          }
        }
        return r;
      }
      BN4.prototype._parseHex = function _parseHex(number, start) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i3 = 0; i3 < this.length; i3++) {
          this.words[i3] = 0;
        }
        var j6, w5;
        var off = 0;
        for (i3 = number.length - 6, j6 = 0; i3 >= start; i3 -= 6) {
          w5 = parseHex(number, i3, i3 + 6);
          this.words[j6] |= w5 << off & 67108863;
          this.words[j6 + 1] |= w5 >>> 26 - off & 4194303;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j6++;
          }
        }
        if (i3 + 6 !== start) {
          w5 = parseHex(number, start, i3 + 6);
          this.words[j6] |= w5 << off & 67108863;
          this.words[j6 + 1] |= w5 >>> 26 - off & 4194303;
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i3 = start; i3 < len; i3++) {
          var c3 = str.charCodeAt(i3) - 48;
          r *= mul;
          if (c3 >= 49) {
            r += c3 - 49 + 10;
          } else if (c3 >= 17) {
            r += c3 - 17 + 10;
          } else {
            r += c3;
          }
        }
        return r;
      }
      BN4.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i3 = start; i3 < end; i3 += limbLen) {
          word = parseBase(number, i3, i3 + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i3, number.length, base);
          for (i3 = 0; i3 < mod; i3++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
      };
      BN4.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i3 = 0; i3 < this.length; i3++) {
          dest.words[i3] = this.words[i3];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN4.prototype.clone = function clone() {
        var r = new BN4(null);
        this.copy(r);
        return r;
      };
      BN4.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN4.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN4.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN4.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN4.prototype.toString = function toString2(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i3 = 0; i3 < this.length; i3++) {
            var w5 = this.words[i3];
            var word = ((w5 << off | carry) & 16777215).toString(16);
            carry = w5 >>> 24 - off & 16777215;
            if (carry !== 0 || i3 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i3--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c3 = this.clone();
          c3.negative = 0;
          while (!c3.isZero()) {
            var r = c3.modn(groupBase).toString(base);
            c3 = c3.idivn(groupBase);
            if (!c3.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN4.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN4.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN4.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length);
      };
      BN4.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN4.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b5, i3;
        var q6 = this.clone();
        if (!littleEndian) {
          for (i3 = 0; i3 < reqLength - byteLength; i3++) {
            res[i3] = 0;
          }
          for (i3 = 0; !q6.isZero(); i3++) {
            b5 = q6.andln(255);
            q6.iushrn(8);
            res[reqLength - i3 - 1] = b5;
          }
        } else {
          for (i3 = 0; !q6.isZero(); i3++) {
            b5 = q6.andln(255);
            q6.iushrn(8);
            res[i3] = b5;
          }
          for (; i3 < reqLength; i3++) {
            res[i3] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN4.prototype._countBits = function _countBits(w5) {
          return 32 - Math.clz32(w5);
        };
      } else {
        BN4.prototype._countBits = function _countBits(w5) {
          var t = w5;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN4.prototype._zeroBits = function _zeroBits(w5) {
        if (w5 === 0)
          return 26;
        var t = w5;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN4.prototype.bitLength = function bitLength() {
        var w5 = this.words[this.length - 1];
        var hi = this._countBits(w5);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w5 = new Array(num.bitLength());
        for (var bit = 0; bit < w5.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w5[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w5;
      }
      BN4.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i3 = 0; i3 < this.length; i3++) {
          var b5 = this._zeroBits(this.words[i3]);
          r += b5;
          if (b5 !== 26)
            break;
        }
        return r;
      };
      BN4.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN4.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN4.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN4.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN4.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN4.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN4.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i3 = 0; i3 < num.length; i3++) {
          this.words[i3] = this.words[i3] | num.words[i3];
        }
        return this.strip();
      };
      BN4.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN4.prototype.or = function or3(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN4.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN4.prototype.iuand = function iuand(num) {
        var b5;
        if (this.length > num.length) {
          b5 = num;
        } else {
          b5 = this;
        }
        for (var i3 = 0; i3 < b5.length; i3++) {
          this.words[i3] = this.words[i3] & num.words[i3];
        }
        this.length = b5.length;
        return this.strip();
      };
      BN4.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN4.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN4.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN4.prototype.iuxor = function iuxor(num) {
        var a3;
        var b5;
        if (this.length > num.length) {
          a3 = this;
          b5 = num;
        } else {
          a3 = num;
          b5 = this;
        }
        for (var i3 = 0; i3 < b5.length; i3++) {
          this.words[i3] = a3.words[i3] ^ b5.words[i3];
        }
        if (this !== a3) {
          for (; i3 < a3.length; i3++) {
            this.words[i3] = a3.words[i3];
          }
        }
        this.length = a3.length;
        return this.strip();
      };
      BN4.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN4.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN4.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN4.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i3 = 0; i3 < bytesNeeded; i3++) {
          this.words[i3] = ~this.words[i3] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i3] = ~this.words[i3] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN4.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN4.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN4.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a3, b5;
        if (this.length > num.length) {
          a3 = this;
          b5 = num;
        } else {
          a3 = num;
          b5 = this;
        }
        var carry = 0;
        for (var i3 = 0; i3 < b5.length; i3++) {
          r = (a3.words[i3] | 0) + (b5.words[i3] | 0) + carry;
          this.words[i3] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i3 < a3.length; i3++) {
          r = (a3.words[i3] | 0) + carry;
          this.words[i3] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a3.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a3 !== this) {
          for (; i3 < a3.length; i3++) {
            this.words[i3] = a3.words[i3];
          }
        }
        return this;
      };
      BN4.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN4.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a3, b5;
        if (cmp > 0) {
          a3 = this;
          b5 = num;
        } else {
          a3 = num;
          b5 = this;
        }
        var carry = 0;
        for (var i3 = 0; i3 < b5.length; i3++) {
          r = (a3.words[i3] | 0) - (b5.words[i3] | 0) + carry;
          carry = r >> 26;
          this.words[i3] = r & 67108863;
        }
        for (; carry !== 0 && i3 < a3.length; i3++) {
          r = (a3.words[i3] | 0) + carry;
          carry = r >> 26;
          this.words[i3] = r & 67108863;
        }
        if (carry === 0 && i3 < a3.length && a3 !== this) {
          for (; i3 < a3.length; i3++) {
            this.words[i3] = a3.words[i3];
          }
        }
        this.length = Math.max(this.length, i3);
        if (a3 !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN4.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a3 = self2.words[0] | 0;
        var b5 = num.words[0] | 0;
        var r = a3 * b5;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k3 = 1; k3 < len; k3++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k3, num.length - 1);
          for (var j6 = Math.max(0, k3 - self2.length + 1); j6 <= maxJ; j6++) {
            var i3 = k3 - j6 | 0;
            a3 = self2.words[i3] | 0;
            b5 = num.words[j6] | 0;
            r = a3 * b5 + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k3] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k3] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a3 = self2.words;
        var b5 = num.words;
        var o2 = out.words;
        var c3 = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a3[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a3[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a3[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a3[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a4 = a3[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a3[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a3[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a3[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a3[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a3[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b5[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b5[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b5[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b5[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b42 = b5[4] | 0;
        var bl4 = b42 & 8191;
        var bh4 = b42 >>> 13;
        var b52 = b5[5] | 0;
        var bl5 = b52 & 8191;
        var bh5 = b52 >>> 13;
        var b6 = b5[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b5[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b5[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b5[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w22 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w32 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w42 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o2[0] = w0;
        o2[1] = w1;
        o2[2] = w22;
        o2[3] = w32;
        o2[4] = w42;
        o2[5] = w5;
        o2[6] = w6;
        o2[7] = w7;
        o2[8] = w8;
        o2[9] = w9;
        o2[10] = w10;
        o2[11] = w11;
        o2[12] = w12;
        o2[13] = w13;
        o2[14] = w14;
        o2[15] = w15;
        o2[16] = w16;
        o2[17] = w17;
        o2[18] = w18;
        if (c3 !== 0) {
          o2[19] = c3;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k3 = 0; k3 < out.length - 1; k3++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k3, num.length - 1);
          for (var j6 = Math.max(0, k3 - self2.length + 1); j6 <= maxJ; j6++) {
            var i3 = k3 - j6;
            var a3 = self2.words[i3] | 0;
            var b5 = num.words[j6] | 0;
            var r = a3 * b5;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k3] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k3] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN4.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x4, y4) {
        this.x = x4;
        this.y = y4;
      }
      FFTM.prototype.makeRBT = function makeRBT(N6) {
        var t = new Array(N6);
        var l2 = BN4.prototype._countBits(N6) - 1;
        for (var i3 = 0; i3 < N6; i3++) {
          t[i3] = this.revBin(i3, l2, N6);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x4, l2, N6) {
        if (x4 === 0 || x4 === N6 - 1)
          return x4;
        var rb = 0;
        for (var i3 = 0; i3 < l2; i3++) {
          rb |= (x4 & 1) << l2 - i3 - 1;
          x4 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N6) {
        for (var i3 = 0; i3 < N6; i3++) {
          rtws[i3] = rws[rbt[i3]];
          itws[i3] = iws[rbt[i3]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N6, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N6);
        for (var s = 1; s < N6; s <<= 1) {
          var l2 = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l2);
          var itwdf = Math.sin(2 * Math.PI / l2);
          for (var p6 = 0; p6 < N6; p6 += l2) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j6 = 0; j6 < s; j6++) {
              var re5 = rtws[p6 + j6];
              var ie5 = itws[p6 + j6];
              var ro = rtws[p6 + j6 + s];
              var io = itws[p6 + j6 + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p6 + j6] = re5 + ro;
              itws[p6 + j6] = ie5 + io;
              rtws[p6 + j6 + s] = re5 - ro;
              itws[p6 + j6 + s] = ie5 - io;
              if (j6 !== l2) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n3, m5) {
        var N6 = Math.max(m5, n3) | 1;
        var odd = N6 & 1;
        var i3 = 0;
        for (N6 = N6 / 2 | 0; N6; N6 = N6 >>> 1) {
          i3++;
        }
        return 1 << i3 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N6) {
        if (N6 <= 1)
          return;
        for (var i3 = 0; i3 < N6 / 2; i3++) {
          var t = rws[i3];
          rws[i3] = rws[N6 - i3 - 1];
          rws[N6 - i3 - 1] = t;
          t = iws[i3];
          iws[i3] = -iws[N6 - i3 - 1];
          iws[N6 - i3 - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws3, N6) {
        var carry = 0;
        for (var i3 = 0; i3 < N6 / 2; i3++) {
          var w5 = Math.round(ws3[2 * i3 + 1] / N6) * 8192 + Math.round(ws3[2 * i3] / N6) + carry;
          ws3[i3] = w5 & 67108863;
          if (w5 < 67108864) {
            carry = 0;
          } else {
            carry = w5 / 67108864 | 0;
          }
        }
        return ws3;
      };
      FFTM.prototype.convert13b = function convert13b(ws3, len, rws, N6) {
        var carry = 0;
        for (var i3 = 0; i3 < len; i3++) {
          carry = carry + (ws3[i3] | 0);
          rws[2 * i3] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i3 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i3 = 2 * len; i3 < N6; ++i3) {
          rws[i3] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N6) {
        var ph = new Array(N6);
        for (var i3 = 0; i3 < N6; i3++) {
          ph[i3] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x4, y4, out) {
        var N6 = 2 * this.guessLen13b(x4.length, y4.length);
        var rbt = this.makeRBT(N6);
        var _4 = this.stub(N6);
        var rws = new Array(N6);
        var rwst = new Array(N6);
        var iwst = new Array(N6);
        var nrws = new Array(N6);
        var nrwst = new Array(N6);
        var niwst = new Array(N6);
        var rmws = out.words;
        rmws.length = N6;
        this.convert13b(x4.words, x4.length, rws, N6);
        this.convert13b(y4.words, y4.length, nrws, N6);
        this.transform(rws, _4, rwst, iwst, N6, rbt);
        this.transform(nrws, _4, nrwst, niwst, N6, rbt);
        for (var i3 = 0; i3 < N6; i3++) {
          var rx = rwst[i3] * nrwst[i3] - iwst[i3] * niwst[i3];
          iwst[i3] = rwst[i3] * niwst[i3] + iwst[i3] * nrwst[i3];
          rwst[i3] = rx;
        }
        this.conjugate(rwst, iwst, N6);
        this.transform(rwst, iwst, rmws, _4, N6, rbt);
        this.conjugate(rmws, _4, N6);
        this.normalize13b(rmws, N6);
        out.negative = x4.negative ^ y4.negative;
        out.length = x4.length + y4.length;
        return out.strip();
      };
      BN4.prototype.mul = function mul(num) {
        var out = new BN4(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN4.prototype.mulf = function mulf(num) {
        var out = new BN4(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN4.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN4.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i3 = 0; i3 < this.length; i3++) {
          var w5 = (this.words[i3] | 0) * num;
          var lo = (w5 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w5 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i3] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i3] = carry;
          this.length++;
        }
        return this;
      };
      BN4.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN4.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN4.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN4.prototype.pow = function pow(num) {
        var w5 = toBitArray(num);
        if (w5.length === 0)
          return new BN4(1);
        var res = this;
        for (var i3 = 0; i3 < w5.length; i3++, res = res.sqr()) {
          if (w5[i3] !== 0)
            break;
        }
        if (++i3 < w5.length) {
          for (var q6 = res.sqr(); i3 < w5.length; i3++, q6 = q6.sqr()) {
            if (w5[i3] === 0)
              continue;
            res = res.mul(q6);
          }
        }
        return res;
      };
      BN4.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i3;
        if (r !== 0) {
          var carry = 0;
          for (i3 = 0; i3 < this.length; i3++) {
            var newCarry = this.words[i3] & carryMask;
            var c3 = (this.words[i3] | 0) - newCarry << r;
            this.words[i3] = c3 | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i3] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i3 = this.length - 1; i3 >= 0; i3--) {
            this.words[i3 + s] = this.words[i3];
          }
          for (i3 = 0; i3 < s; i3++) {
            this.words[i3] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN4.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN4.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h3;
        if (hint) {
          h3 = (hint - hint % 26) / 26;
        } else {
          h3 = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h3 -= s;
        h3 = Math.max(0, h3);
        if (maskedWords) {
          for (var i3 = 0; i3 < s; i3++) {
            maskedWords.words[i3] = this.words[i3];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i3 = 0; i3 < this.length; i3++) {
            this.words[i3] = this.words[i3 + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i3 = this.length - 1; i3 >= 0 && (carry !== 0 || i3 >= h3); i3--) {
          var word = this.words[i3] | 0;
          this.words[i3] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN4.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN4.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN4.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN4.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN4.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN4.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q6 = 1 << r;
        if (this.length <= s)
          return false;
        var w5 = this.words[s];
        return !!(w5 & q6);
      };
      BN4.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN4.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN4.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN4.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i3 = 0; i3 < this.length && this.words[i3] >= 67108864; i3++) {
          this.words[i3] -= 67108864;
          if (i3 === this.length - 1) {
            this.words[i3 + 1] = 1;
          } else {
            this.words[i3 + 1]++;
          }
        }
        this.length = Math.max(this.length, i3 + 1);
        return this;
      };
      BN4.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i3 = 0; i3 < this.length && this.words[i3] < 0; i3++) {
            this.words[i3] += 67108864;
            this.words[i3 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN4.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN4.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN4.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN4.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN4.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i3;
        this._expand(len);
        var w5;
        var carry = 0;
        for (i3 = 0; i3 < num.length; i3++) {
          w5 = (this.words[i3 + shift] | 0) + carry;
          var right = (num.words[i3] | 0) * mul;
          w5 -= right & 67108863;
          carry = (w5 >> 26) - (right / 67108864 | 0);
          this.words[i3 + shift] = w5 & 67108863;
        }
        for (; i3 < this.length - shift; i3++) {
          w5 = (this.words[i3 + shift] | 0) + carry;
          carry = w5 >> 26;
          this.words[i3 + shift] = w5 & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i3 = 0; i3 < this.length; i3++) {
          w5 = -(this.words[i3] | 0) + carry;
          carry = w5 >> 26;
          this.words[i3] = w5 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN4.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a3 = this.clone();
        var b5 = num;
        var bhi = b5.words[b5.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b5 = b5.ushln(shift);
          a3.iushln(shift);
          bhi = b5.words[b5.length - 1] | 0;
        }
        var m5 = a3.length - b5.length;
        var q6;
        if (mode !== "mod") {
          q6 = new BN4(null);
          q6.length = m5 + 1;
          q6.words = new Array(q6.length);
          for (var i3 = 0; i3 < q6.length; i3++) {
            q6.words[i3] = 0;
          }
        }
        var diff = a3.clone()._ishlnsubmul(b5, 1, m5);
        if (diff.negative === 0) {
          a3 = diff;
          if (q6) {
            q6.words[m5] = 1;
          }
        }
        for (var j6 = m5 - 1; j6 >= 0; j6--) {
          var qj = (a3.words[b5.length + j6] | 0) * 67108864 + (a3.words[b5.length + j6 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a3._ishlnsubmul(b5, qj, j6);
          while (a3.negative !== 0) {
            qj--;
            a3.negative = 0;
            a3._ishlnsubmul(b5, 1, j6);
            if (!a3.isZero()) {
              a3.negative ^= 1;
            }
          }
          if (q6) {
            q6.words[j6] = qj;
          }
        }
        if (q6) {
          q6.strip();
        }
        a3.strip();
        if (mode !== "div" && shift !== 0) {
          a3.iushrn(shift);
        }
        return {
          div: q6 || null,
          mod: a3
        };
      };
      BN4.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN4(0),
            mod: new BN4(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN4(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN4(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN4(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN4.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN4.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN4.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN4.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN4.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p6 = (1 << 26) % num;
        var acc = 0;
        for (var i3 = this.length - 1; i3 >= 0; i3--) {
          acc = (p6 * acc + (this.words[i3] | 0)) % num;
        }
        return acc;
      };
      BN4.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i3 = this.length - 1; i3 >= 0; i3--) {
          var w5 = (this.words[i3] | 0) + carry * 67108864;
          this.words[i3] = w5 / num | 0;
          carry = w5 % num;
        }
        return this.strip();
      };
      BN4.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN4.prototype.egcd = function egcd(p6) {
        assert(p6.negative === 0);
        assert(!p6.isZero());
        var x4 = this;
        var y4 = p6.clone();
        if (x4.negative !== 0) {
          x4 = x4.umod(p6);
        } else {
          x4 = x4.clone();
        }
        var A3 = new BN4(1);
        var B2 = new BN4(0);
        var C7 = new BN4(0);
        var D3 = new BN4(1);
        var g5 = 0;
        while (x4.isEven() && y4.isEven()) {
          x4.iushrn(1);
          y4.iushrn(1);
          ++g5;
        }
        var yp = y4.clone();
        var xp = x4.clone();
        while (!x4.isZero()) {
          for (var i3 = 0, im = 1; (x4.words[0] & im) === 0 && i3 < 26; ++i3, im <<= 1)
            ;
          if (i3 > 0) {
            x4.iushrn(i3);
            while (i3-- > 0) {
              if (A3.isOdd() || B2.isOdd()) {
                A3.iadd(yp);
                B2.isub(xp);
              }
              A3.iushrn(1);
              B2.iushrn(1);
            }
          }
          for (var j6 = 0, jm = 1; (y4.words[0] & jm) === 0 && j6 < 26; ++j6, jm <<= 1)
            ;
          if (j6 > 0) {
            y4.iushrn(j6);
            while (j6-- > 0) {
              if (C7.isOdd() || D3.isOdd()) {
                C7.iadd(yp);
                D3.isub(xp);
              }
              C7.iushrn(1);
              D3.iushrn(1);
            }
          }
          if (x4.cmp(y4) >= 0) {
            x4.isub(y4);
            A3.isub(C7);
            B2.isub(D3);
          } else {
            y4.isub(x4);
            C7.isub(A3);
            D3.isub(B2);
          }
        }
        return {
          a: C7,
          b: D3,
          gcd: y4.iushln(g5)
        };
      };
      BN4.prototype._invmp = function _invmp(p6) {
        assert(p6.negative === 0);
        assert(!p6.isZero());
        var a3 = this;
        var b5 = p6.clone();
        if (a3.negative !== 0) {
          a3 = a3.umod(p6);
        } else {
          a3 = a3.clone();
        }
        var x1 = new BN4(1);
        var x22 = new BN4(0);
        var delta = b5.clone();
        while (a3.cmpn(1) > 0 && b5.cmpn(1) > 0) {
          for (var i3 = 0, im = 1; (a3.words[0] & im) === 0 && i3 < 26; ++i3, im <<= 1)
            ;
          if (i3 > 0) {
            a3.iushrn(i3);
            while (i3-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j6 = 0, jm = 1; (b5.words[0] & jm) === 0 && j6 < 26; ++j6, jm <<= 1)
            ;
          if (j6 > 0) {
            b5.iushrn(j6);
            while (j6-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a3.cmp(b5) >= 0) {
            a3.isub(b5);
            x1.isub(x22);
          } else {
            b5.isub(a3);
            x22.isub(x1);
          }
        }
        var res;
        if (a3.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p6);
        }
        return res;
      };
      BN4.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a3 = this.clone();
        var b5 = num.clone();
        a3.negative = 0;
        b5.negative = 0;
        for (var shift = 0; a3.isEven() && b5.isEven(); shift++) {
          a3.iushrn(1);
          b5.iushrn(1);
        }
        do {
          while (a3.isEven()) {
            a3.iushrn(1);
          }
          while (b5.isEven()) {
            b5.iushrn(1);
          }
          var r = a3.cmp(b5);
          if (r < 0) {
            var t = a3;
            a3 = b5;
            b5 = t;
          } else if (r === 0 || b5.cmpn(1) === 0) {
            break;
          }
          a3.isub(b5);
        } while (true);
        return b5.iushln(shift);
      };
      BN4.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN4.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN4.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN4.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN4.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q6 = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q6;
          return this;
        }
        var carry = q6;
        for (var i3 = s; carry !== 0 && i3 < this.length; i3++) {
          var w5 = this.words[i3] | 0;
          w5 += carry;
          carry = w5 >>> 26;
          w5 &= 67108863;
          this.words[i3] = w5;
        }
        if (carry !== 0) {
          this.words[i3] = carry;
          this.length++;
        }
        return this;
      };
      BN4.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN4.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w5 = this.words[0] | 0;
          res = w5 === num ? 0 : w5 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN4.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN4.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i3 = this.length - 1; i3 >= 0; i3--) {
          var a3 = this.words[i3] | 0;
          var b5 = num.words[i3] | 0;
          if (a3 === b5)
            continue;
          if (a3 < b5) {
            res = -1;
          } else if (a3 > b5) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN4.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN4.prototype.gt = function gt4(num) {
        return this.cmp(num) === 1;
      };
      BN4.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN4.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN4.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN4.prototype.lt = function lt6(num) {
        return this.cmp(num) === -1;
      };
      BN4.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN4.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN4.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN4.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN4.red = function red(num) {
        return new Red(num);
      };
      BN4.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN4.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN4.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN4.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN4.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN4.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN4.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN4.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN4.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN4.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN4.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN4.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN4.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN4.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN4.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN4.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN4.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p6) {
        this.name = name;
        this.p = new BN4(p6, 16);
        this.n = this.p.bitLength();
        this.k = new BN4(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN4(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          r.strip();
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i3 = 0; i3 < outLen; i3++) {
          output.words[i3] = input.words[i3];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i3 = 10; i3 < input.length; i3++) {
          var next = input.words[i3] | 0;
          input.words[i3 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i3 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i3 = 0; i3 < num.length; i3++) {
          var w5 = num.words[i3] | 0;
          lo += w5 * 977;
          num.words[i3] = lo & 67108863;
          lo = w5 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i3 = 0; i3 < num.length; i3++) {
          var hi = (num.words[i3] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i3] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN4._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m5) {
        if (typeof m5 === "string") {
          var prime = BN4._prime(m5);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m5.gtn(1), "modulus must be greater than 1");
          this.m = m5;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a3) {
        assert(a3.negative === 0, "red works only with positives");
        assert(a3.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a3, b5) {
        assert((a3.negative | b5.negative) === 0, "red works only with positives");
        assert(
          a3.red && a3.red === b5.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a3) {
        if (this.prime)
          return this.prime.ireduce(a3)._forceRed(this);
        return a3.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a3) {
        if (a3.isZero()) {
          return a3.clone();
        }
        return this.m.sub(a3)._forceRed(this);
      };
      Red.prototype.add = function add(a3, b5) {
        this._verify2(a3, b5);
        var res = a3.add(b5);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a3, b5) {
        this._verify2(a3, b5);
        var res = a3.iadd(b5);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a3, b5) {
        this._verify2(a3, b5);
        var res = a3.sub(b5);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a3, b5) {
        this._verify2(a3, b5);
        var res = a3.isub(b5);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a3, num) {
        this._verify1(a3);
        return this.imod(a3.ushln(num));
      };
      Red.prototype.imul = function imul(a3, b5) {
        this._verify2(a3, b5);
        return this.imod(a3.imul(b5));
      };
      Red.prototype.mul = function mul(a3, b5) {
        this._verify2(a3, b5);
        return this.imod(a3.mul(b5));
      };
      Red.prototype.isqr = function isqr(a3) {
        return this.imul(a3, a3.clone());
      };
      Red.prototype.sqr = function sqr(a3) {
        return this.mul(a3, a3);
      };
      Red.prototype.sqrt = function sqrt(a3) {
        if (a3.isZero())
          return a3.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN4(1)).iushrn(2);
          return this.pow(a3, pow);
        }
        var q6 = this.m.subn(1);
        var s = 0;
        while (!q6.isZero() && q6.andln(1) === 0) {
          s++;
          q6.iushrn(1);
        }
        assert(!q6.isZero());
        var one = new BN4(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z6 = this.m.bitLength();
        z6 = new BN4(2 * z6 * z6).toRed(this);
        while (this.pow(z6, lpow).cmp(nOne) !== 0) {
          z6.redIAdd(nOne);
        }
        var c3 = this.pow(z6, q6);
        var r = this.pow(a3, q6.addn(1).iushrn(1));
        var t = this.pow(a3, q6);
        var m5 = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i3 = 0; tmp.cmp(one) !== 0; i3++) {
            tmp = tmp.redSqr();
          }
          assert(i3 < m5);
          var b5 = this.pow(c3, new BN4(1).iushln(m5 - i3 - 1));
          r = r.redMul(b5);
          c3 = b5.redSqr();
          t = t.redMul(c3);
          m5 = i3;
        }
        return r;
      };
      Red.prototype.invm = function invm(a3) {
        var inv = a3._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a3, num) {
        if (num.isZero())
          return new BN4(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a3.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN4(1).toRed(this);
        wnd[1] = a3;
        for (var i3 = 2; i3 < wnd.length; i3++) {
          wnd[i3] = this.mul(wnd[i3 - 1], a3);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i3 = num.length - 1; i3 >= 0; i3--) {
          var word = num.words[i3];
          for (var j6 = start - 1; j6 >= 0; j6--) {
            var bit = word >> j6 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i3 !== 0 || j6 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN4.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m5) {
        Red.call(this, m5);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN4(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a3, b5) {
        if (a3.isZero() || b5.isZero()) {
          a3.words[0] = 0;
          a3.length = 1;
          return a3;
        }
        var t = a3.imul(b5);
        var c3 = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t.isub(c3).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a3, b5) {
        if (a3.isZero() || b5.isZero())
          return new BN4(0)._forceRed(this);
        var t = a3.mul(b5);
        var c3 = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t.isub(c3).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a3) {
        var res = this.imod(a3._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/@walletconnect/client/node_modules/query-string/index.js
var require_query_string3 = __commonJS({
  "node_modules/@walletconnect/client/node_modules/query-string/index.js"(exports) {
    "use strict";
    init_shim();
    var strictUriEncode = require_strict_uri_encode();
    var decodeComponent = require_decode_uri_component();
    var splitOnFirst = require_split_on_first();
    var isNullOrUndefined = (value) => value === null || value === void 0;
    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case "index":
          return (key) => (result, value) => {
            const index = result.length;
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), "[", index, "]"].join("")];
            }
            return [
              ...result,
              [encode(key, options), "[", encode(index, options), "]=", encode(value, options)].join("")
            ];
          };
        case "bracket":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), "[]"].join("")];
            }
            return [...result, [encode(key, options), "[]=", encode(value, options)].join("")];
          };
        case "comma":
        case "separator":
          return (key) => (result, value) => {
            if (value === null || value === void 0 || value.length === 0) {
              return result;
            }
            if (result.length === 0) {
              return [[encode(key, options), "=", encode(value, options)].join("")];
            }
            return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
          };
        default:
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, encode(key, options)];
            }
            return [...result, [encode(key, options), "=", encode(value, options)].join("")];
          };
      }
    }
    function parserForArrayFormat(options) {
      let result;
      switch (options.arrayFormat) {
        case "index":
          return (key, value, accumulator) => {
            result = /\[(\d*)\]$/.exec(key);
            key = key.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = {};
            }
            accumulator[key][result[1]] = value;
          };
        case "bracket":
          return (key, value, accumulator) => {
            result = /(\[\])$/.exec(key);
            key = key.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "comma":
        case "separator":
          return (key, value, accumulator) => {
            const isArray = typeof value === "string" && value.split("").indexOf(options.arrayFormatSeparator) > -1;
            const newValue = isArray ? value.split(options.arrayFormatSeparator).map((item) => decode(item, options)) : value === null ? value : decode(value, options);
            accumulator[key] = newValue;
          };
        default:
          return (key, value, accumulator) => {
            if (accumulator[key] === void 0) {
              accumulator[key] = value;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
      }
    }
    function validateArrayFormatSeparator(value) {
      if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
      }
    }
    function encode(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
      }
      return value;
    }
    function decode(value, options) {
      if (options.decode) {
        return decodeComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }
      if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort((a3, b5) => Number(a3) - Number(b5)).map((key) => input[key]);
      }
      return input;
    }
    function removeHash(input) {
      const hashStart = input.indexOf("#");
      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }
      return input;
    }
    function getHash(url) {
      let hash = "";
      const hashStart = url.indexOf("#");
      if (hashStart !== -1) {
        hash = url.slice(hashStart);
      }
      return hash;
    }
    function extract(input) {
      input = removeHash(input);
      const queryStart = input.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return input.slice(queryStart + 1);
    }
    function parseValue(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        value = value.toLowerCase() === "true";
      }
      return value;
    }
    function parse6(input, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const formatter = parserForArrayFormat(options);
      const ret = /* @__PURE__ */ Object.create(null);
      if (typeof input !== "string") {
        return ret;
      }
      input = input.trim().replace(/^[?#&]/, "");
      if (!input) {
        return ret;
      }
      for (const param of input.split("&")) {
        let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
        value = value === void 0 ? null : ["comma", "separator"].includes(options.arrayFormat) ? value : decode(value, options);
        formatter(decode(key, options), value, ret);
      }
      for (const key of Object.keys(ret)) {
        const value = ret[key];
        if (typeof value === "object" && value !== null) {
          for (const k3 of Object.keys(value)) {
            value[k3] = parseValue(value[k3], options);
          }
        } else {
          ret[key] = parseValue(value, options);
        }
      }
      if (options.sort === false) {
        return ret;
      }
      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
        const value = ret[key];
        if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
          result[key] = keysSorter(value);
        } else {
          result[key] = value;
        }
        return result;
      }, /* @__PURE__ */ Object.create(null));
    }
    exports.extract = extract;
    exports.parse = parse6;
    exports.stringify = (object, options) => {
      if (!object) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const shouldFilter = (key) => options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === "";
      const formatter = encoderForArrayFormat(options);
      const objectCopy = {};
      for (const key of Object.keys(object)) {
        if (!shouldFilter(key)) {
          objectCopy[key] = object[key];
        }
      }
      const keys = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys.sort(options.sort);
      }
      return keys.map((key) => {
        const value = object[key];
        if (value === void 0) {
          return "";
        }
        if (value === null) {
          return encode(key, options);
        }
        if (Array.isArray(value)) {
          return value.reduce(formatter(key), []).join("&");
        }
        return encode(key, options) + "=" + encode(value, options);
      }).filter((x4) => x4.length > 0).join("&");
    };
    exports.parseUrl = (input, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url, hash] = splitOnFirst(input, "#");
      return Object.assign(
        {
          url: url.split("?")[0] || "",
          query: parse6(extract(input), options)
        },
        options && options.parseFragmentIdentifier && hash ? { fragmentIdentifier: decode(hash, options) } : {}
      );
    };
    exports.stringifyUrl = (input, options) => {
      options = Object.assign({
        encode: true,
        strict: true
      }, options);
      const url = removeHash(input.url).split("?")[0] || "";
      const queryFromUrl = exports.extract(input.url);
      const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
      const query = Object.assign(parsedQueryFromUrl, input.query);
      let queryString = exports.stringify(query, options);
      if (queryString) {
        queryString = `?${queryString}`;
      }
      let hash = getHash(input.url);
      if (input.fragmentIdentifier) {
        hash = `#${encode(input.fragmentIdentifier, options)}`;
      }
      return `${url}${queryString}${hash}`;
    };
  }
});

// node_modules/@walletconnect/socket-transport/node_modules/bn.js/lib/bn.js
var require_bn2 = __commonJS({
  "node_modules/@walletconnect/socket-transport/node_modules/bn.js/lib/bn.js"(exports, module) {
    init_shim();
    (function(module2, exports2) {
      "use strict";
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN4(number, base, endian) {
        if (BN4.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN4;
      } else {
        exports2.BN = BN4;
      }
      BN4.BN = BN4;
      BN4.wordSize = 26;
      var Buffer2;
      try {
        Buffer2 = require_buffer().Buffer;
      } catch (e) {
      }
      BN4.isBN = function isBN(num) {
        if (num instanceof BN4) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN4.wordSize && Array.isArray(num.words);
      };
      BN4.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN4.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN4.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
        }
        if (base === 16) {
          this._parseHex(number, start);
        } else {
          this._parseBase(number, base, start);
        }
        if (number[0] === "-") {
          this.negative = 1;
        }
        this.strip();
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN4.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN4.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i3 = 0; i3 < this.length; i3++) {
          this.words[i3] = 0;
        }
        var j6, w5;
        var off = 0;
        if (endian === "be") {
          for (i3 = number.length - 1, j6 = 0; i3 >= 0; i3 -= 3) {
            w5 = number[i3] | number[i3 - 1] << 8 | number[i3 - 2] << 16;
            this.words[j6] |= w5 << off & 67108863;
            this.words[j6 + 1] = w5 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j6++;
            }
          }
        } else if (endian === "le") {
          for (i3 = 0, j6 = 0; i3 < number.length; i3 += 3) {
            w5 = number[i3] | number[i3 + 1] << 8 | number[i3 + 2] << 16;
            this.words[j6] |= w5 << off & 67108863;
            this.words[j6 + 1] = w5 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j6++;
            }
          }
        }
        return this.strip();
      };
      function parseHex(str, start, end) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i3 = start; i3 < len; i3++) {
          var c3 = str.charCodeAt(i3) - 48;
          r <<= 4;
          if (c3 >= 49 && c3 <= 54) {
            r |= c3 - 49 + 10;
          } else if (c3 >= 17 && c3 <= 22) {
            r |= c3 - 17 + 10;
          } else {
            r |= c3 & 15;
          }
        }
        return r;
      }
      BN4.prototype._parseHex = function _parseHex(number, start) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i3 = 0; i3 < this.length; i3++) {
          this.words[i3] = 0;
        }
        var j6, w5;
        var off = 0;
        for (i3 = number.length - 6, j6 = 0; i3 >= start; i3 -= 6) {
          w5 = parseHex(number, i3, i3 + 6);
          this.words[j6] |= w5 << off & 67108863;
          this.words[j6 + 1] |= w5 >>> 26 - off & 4194303;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j6++;
          }
        }
        if (i3 + 6 !== start) {
          w5 = parseHex(number, start, i3 + 6);
          this.words[j6] |= w5 << off & 67108863;
          this.words[j6 + 1] |= w5 >>> 26 - off & 4194303;
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i3 = start; i3 < len; i3++) {
          var c3 = str.charCodeAt(i3) - 48;
          r *= mul;
          if (c3 >= 49) {
            r += c3 - 49 + 10;
          } else if (c3 >= 17) {
            r += c3 - 17 + 10;
          } else {
            r += c3;
          }
        }
        return r;
      }
      BN4.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i3 = start; i3 < end; i3 += limbLen) {
          word = parseBase(number, i3, i3 + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i3, number.length, base);
          for (i3 = 0; i3 < mod; i3++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
      };
      BN4.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i3 = 0; i3 < this.length; i3++) {
          dest.words[i3] = this.words[i3];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN4.prototype.clone = function clone() {
        var r = new BN4(null);
        this.copy(r);
        return r;
      };
      BN4.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN4.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN4.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN4.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN4.prototype.toString = function toString2(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i3 = 0; i3 < this.length; i3++) {
            var w5 = this.words[i3];
            var word = ((w5 << off | carry) & 16777215).toString(16);
            carry = w5 >>> 24 - off & 16777215;
            if (carry !== 0 || i3 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i3--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c3 = this.clone();
          c3.negative = 0;
          while (!c3.isZero()) {
            var r = c3.modn(groupBase).toString(base);
            c3 = c3.idivn(groupBase);
            if (!c3.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN4.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN4.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN4.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length);
      };
      BN4.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN4.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b5, i3;
        var q6 = this.clone();
        if (!littleEndian) {
          for (i3 = 0; i3 < reqLength - byteLength; i3++) {
            res[i3] = 0;
          }
          for (i3 = 0; !q6.isZero(); i3++) {
            b5 = q6.andln(255);
            q6.iushrn(8);
            res[reqLength - i3 - 1] = b5;
          }
        } else {
          for (i3 = 0; !q6.isZero(); i3++) {
            b5 = q6.andln(255);
            q6.iushrn(8);
            res[i3] = b5;
          }
          for (; i3 < reqLength; i3++) {
            res[i3] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN4.prototype._countBits = function _countBits(w5) {
          return 32 - Math.clz32(w5);
        };
      } else {
        BN4.prototype._countBits = function _countBits(w5) {
          var t = w5;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN4.prototype._zeroBits = function _zeroBits(w5) {
        if (w5 === 0)
          return 26;
        var t = w5;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN4.prototype.bitLength = function bitLength() {
        var w5 = this.words[this.length - 1];
        var hi = this._countBits(w5);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w5 = new Array(num.bitLength());
        for (var bit = 0; bit < w5.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w5[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w5;
      }
      BN4.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i3 = 0; i3 < this.length; i3++) {
          var b5 = this._zeroBits(this.words[i3]);
          r += b5;
          if (b5 !== 26)
            break;
        }
        return r;
      };
      BN4.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN4.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN4.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN4.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN4.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN4.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN4.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i3 = 0; i3 < num.length; i3++) {
          this.words[i3] = this.words[i3] | num.words[i3];
        }
        return this.strip();
      };
      BN4.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN4.prototype.or = function or3(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN4.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN4.prototype.iuand = function iuand(num) {
        var b5;
        if (this.length > num.length) {
          b5 = num;
        } else {
          b5 = this;
        }
        for (var i3 = 0; i3 < b5.length; i3++) {
          this.words[i3] = this.words[i3] & num.words[i3];
        }
        this.length = b5.length;
        return this.strip();
      };
      BN4.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN4.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN4.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN4.prototype.iuxor = function iuxor(num) {
        var a3;
        var b5;
        if (this.length > num.length) {
          a3 = this;
          b5 = num;
        } else {
          a3 = num;
          b5 = this;
        }
        for (var i3 = 0; i3 < b5.length; i3++) {
          this.words[i3] = a3.words[i3] ^ b5.words[i3];
        }
        if (this !== a3) {
          for (; i3 < a3.length; i3++) {
            this.words[i3] = a3.words[i3];
          }
        }
        this.length = a3.length;
        return this.strip();
      };
      BN4.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN4.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN4.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN4.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i3 = 0; i3 < bytesNeeded; i3++) {
          this.words[i3] = ~this.words[i3] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i3] = ~this.words[i3] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN4.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN4.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN4.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a3, b5;
        if (this.length > num.length) {
          a3 = this;
          b5 = num;
        } else {
          a3 = num;
          b5 = this;
        }
        var carry = 0;
        for (var i3 = 0; i3 < b5.length; i3++) {
          r = (a3.words[i3] | 0) + (b5.words[i3] | 0) + carry;
          this.words[i3] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i3 < a3.length; i3++) {
          r = (a3.words[i3] | 0) + carry;
          this.words[i3] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a3.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a3 !== this) {
          for (; i3 < a3.length; i3++) {
            this.words[i3] = a3.words[i3];
          }
        }
        return this;
      };
      BN4.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN4.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a3, b5;
        if (cmp > 0) {
          a3 = this;
          b5 = num;
        } else {
          a3 = num;
          b5 = this;
        }
        var carry = 0;
        for (var i3 = 0; i3 < b5.length; i3++) {
          r = (a3.words[i3] | 0) - (b5.words[i3] | 0) + carry;
          carry = r >> 26;
          this.words[i3] = r & 67108863;
        }
        for (; carry !== 0 && i3 < a3.length; i3++) {
          r = (a3.words[i3] | 0) + carry;
          carry = r >> 26;
          this.words[i3] = r & 67108863;
        }
        if (carry === 0 && i3 < a3.length && a3 !== this) {
          for (; i3 < a3.length; i3++) {
            this.words[i3] = a3.words[i3];
          }
        }
        this.length = Math.max(this.length, i3);
        if (a3 !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN4.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a3 = self2.words[0] | 0;
        var b5 = num.words[0] | 0;
        var r = a3 * b5;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k3 = 1; k3 < len; k3++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k3, num.length - 1);
          for (var j6 = Math.max(0, k3 - self2.length + 1); j6 <= maxJ; j6++) {
            var i3 = k3 - j6 | 0;
            a3 = self2.words[i3] | 0;
            b5 = num.words[j6] | 0;
            r = a3 * b5 + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k3] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k3] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a3 = self2.words;
        var b5 = num.words;
        var o2 = out.words;
        var c3 = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a3[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a3[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a3[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a3[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a4 = a3[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a3[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a3[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a3[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a3[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a3[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b5[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b5[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b5[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b5[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b42 = b5[4] | 0;
        var bl4 = b42 & 8191;
        var bh4 = b42 >>> 13;
        var b52 = b5[5] | 0;
        var bl5 = b52 & 8191;
        var bh5 = b52 >>> 13;
        var b6 = b5[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b5[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b5[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b5[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w22 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w32 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w42 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o2[0] = w0;
        o2[1] = w1;
        o2[2] = w22;
        o2[3] = w32;
        o2[4] = w42;
        o2[5] = w5;
        o2[6] = w6;
        o2[7] = w7;
        o2[8] = w8;
        o2[9] = w9;
        o2[10] = w10;
        o2[11] = w11;
        o2[12] = w12;
        o2[13] = w13;
        o2[14] = w14;
        o2[15] = w15;
        o2[16] = w16;
        o2[17] = w17;
        o2[18] = w18;
        if (c3 !== 0) {
          o2[19] = c3;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k3 = 0; k3 < out.length - 1; k3++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k3, num.length - 1);
          for (var j6 = Math.max(0, k3 - self2.length + 1); j6 <= maxJ; j6++) {
            var i3 = k3 - j6;
            var a3 = self2.words[i3] | 0;
            var b5 = num.words[j6] | 0;
            var r = a3 * b5;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k3] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k3] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN4.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x4, y4) {
        this.x = x4;
        this.y = y4;
      }
      FFTM.prototype.makeRBT = function makeRBT(N6) {
        var t = new Array(N6);
        var l2 = BN4.prototype._countBits(N6) - 1;
        for (var i3 = 0; i3 < N6; i3++) {
          t[i3] = this.revBin(i3, l2, N6);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x4, l2, N6) {
        if (x4 === 0 || x4 === N6 - 1)
          return x4;
        var rb = 0;
        for (var i3 = 0; i3 < l2; i3++) {
          rb |= (x4 & 1) << l2 - i3 - 1;
          x4 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N6) {
        for (var i3 = 0; i3 < N6; i3++) {
          rtws[i3] = rws[rbt[i3]];
          itws[i3] = iws[rbt[i3]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N6, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N6);
        for (var s = 1; s < N6; s <<= 1) {
          var l2 = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l2);
          var itwdf = Math.sin(2 * Math.PI / l2);
          for (var p6 = 0; p6 < N6; p6 += l2) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j6 = 0; j6 < s; j6++) {
              var re5 = rtws[p6 + j6];
              var ie5 = itws[p6 + j6];
              var ro = rtws[p6 + j6 + s];
              var io = itws[p6 + j6 + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p6 + j6] = re5 + ro;
              itws[p6 + j6] = ie5 + io;
              rtws[p6 + j6 + s] = re5 - ro;
              itws[p6 + j6 + s] = ie5 - io;
              if (j6 !== l2) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n3, m5) {
        var N6 = Math.max(m5, n3) | 1;
        var odd = N6 & 1;
        var i3 = 0;
        for (N6 = N6 / 2 | 0; N6; N6 = N6 >>> 1) {
          i3++;
        }
        return 1 << i3 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N6) {
        if (N6 <= 1)
          return;
        for (var i3 = 0; i3 < N6 / 2; i3++) {
          var t = rws[i3];
          rws[i3] = rws[N6 - i3 - 1];
          rws[N6 - i3 - 1] = t;
          t = iws[i3];
          iws[i3] = -iws[N6 - i3 - 1];
          iws[N6 - i3 - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws3, N6) {
        var carry = 0;
        for (var i3 = 0; i3 < N6 / 2; i3++) {
          var w5 = Math.round(ws3[2 * i3 + 1] / N6) * 8192 + Math.round(ws3[2 * i3] / N6) + carry;
          ws3[i3] = w5 & 67108863;
          if (w5 < 67108864) {
            carry = 0;
          } else {
            carry = w5 / 67108864 | 0;
          }
        }
        return ws3;
      };
      FFTM.prototype.convert13b = function convert13b(ws3, len, rws, N6) {
        var carry = 0;
        for (var i3 = 0; i3 < len; i3++) {
          carry = carry + (ws3[i3] | 0);
          rws[2 * i3] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i3 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i3 = 2 * len; i3 < N6; ++i3) {
          rws[i3] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N6) {
        var ph = new Array(N6);
        for (var i3 = 0; i3 < N6; i3++) {
          ph[i3] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x4, y4, out) {
        var N6 = 2 * this.guessLen13b(x4.length, y4.length);
        var rbt = this.makeRBT(N6);
        var _4 = this.stub(N6);
        var rws = new Array(N6);
        var rwst = new Array(N6);
        var iwst = new Array(N6);
        var nrws = new Array(N6);
        var nrwst = new Array(N6);
        var niwst = new Array(N6);
        var rmws = out.words;
        rmws.length = N6;
        this.convert13b(x4.words, x4.length, rws, N6);
        this.convert13b(y4.words, y4.length, nrws, N6);
        this.transform(rws, _4, rwst, iwst, N6, rbt);
        this.transform(nrws, _4, nrwst, niwst, N6, rbt);
        for (var i3 = 0; i3 < N6; i3++) {
          var rx = rwst[i3] * nrwst[i3] - iwst[i3] * niwst[i3];
          iwst[i3] = rwst[i3] * niwst[i3] + iwst[i3] * nrwst[i3];
          rwst[i3] = rx;
        }
        this.conjugate(rwst, iwst, N6);
        this.transform(rwst, iwst, rmws, _4, N6, rbt);
        this.conjugate(rmws, _4, N6);
        this.normalize13b(rmws, N6);
        out.negative = x4.negative ^ y4.negative;
        out.length = x4.length + y4.length;
        return out.strip();
      };
      BN4.prototype.mul = function mul(num) {
        var out = new BN4(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN4.prototype.mulf = function mulf(num) {
        var out = new BN4(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN4.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN4.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i3 = 0; i3 < this.length; i3++) {
          var w5 = (this.words[i3] | 0) * num;
          var lo = (w5 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w5 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i3] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i3] = carry;
          this.length++;
        }
        return this;
      };
      BN4.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN4.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN4.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN4.prototype.pow = function pow(num) {
        var w5 = toBitArray(num);
        if (w5.length === 0)
          return new BN4(1);
        var res = this;
        for (var i3 = 0; i3 < w5.length; i3++, res = res.sqr()) {
          if (w5[i3] !== 0)
            break;
        }
        if (++i3 < w5.length) {
          for (var q6 = res.sqr(); i3 < w5.length; i3++, q6 = q6.sqr()) {
            if (w5[i3] === 0)
              continue;
            res = res.mul(q6);
          }
        }
        return res;
      };
      BN4.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i3;
        if (r !== 0) {
          var carry = 0;
          for (i3 = 0; i3 < this.length; i3++) {
            var newCarry = this.words[i3] & carryMask;
            var c3 = (this.words[i3] | 0) - newCarry << r;
            this.words[i3] = c3 | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i3] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i3 = this.length - 1; i3 >= 0; i3--) {
            this.words[i3 + s] = this.words[i3];
          }
          for (i3 = 0; i3 < s; i3++) {
            this.words[i3] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN4.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN4.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h3;
        if (hint) {
          h3 = (hint - hint % 26) / 26;
        } else {
          h3 = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h3 -= s;
        h3 = Math.max(0, h3);
        if (maskedWords) {
          for (var i3 = 0; i3 < s; i3++) {
            maskedWords.words[i3] = this.words[i3];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i3 = 0; i3 < this.length; i3++) {
            this.words[i3] = this.words[i3 + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i3 = this.length - 1; i3 >= 0 && (carry !== 0 || i3 >= h3); i3--) {
          var word = this.words[i3] | 0;
          this.words[i3] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN4.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN4.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN4.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN4.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN4.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN4.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q6 = 1 << r;
        if (this.length <= s)
          return false;
        var w5 = this.words[s];
        return !!(w5 & q6);
      };
      BN4.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN4.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN4.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN4.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i3 = 0; i3 < this.length && this.words[i3] >= 67108864; i3++) {
          this.words[i3] -= 67108864;
          if (i3 === this.length - 1) {
            this.words[i3 + 1] = 1;
          } else {
            this.words[i3 + 1]++;
          }
        }
        this.length = Math.max(this.length, i3 + 1);
        return this;
      };
      BN4.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i3 = 0; i3 < this.length && this.words[i3] < 0; i3++) {
            this.words[i3] += 67108864;
            this.words[i3 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN4.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN4.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN4.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN4.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN4.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i3;
        this._expand(len);
        var w5;
        var carry = 0;
        for (i3 = 0; i3 < num.length; i3++) {
          w5 = (this.words[i3 + shift] | 0) + carry;
          var right = (num.words[i3] | 0) * mul;
          w5 -= right & 67108863;
          carry = (w5 >> 26) - (right / 67108864 | 0);
          this.words[i3 + shift] = w5 & 67108863;
        }
        for (; i3 < this.length - shift; i3++) {
          w5 = (this.words[i3 + shift] | 0) + carry;
          carry = w5 >> 26;
          this.words[i3 + shift] = w5 & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i3 = 0; i3 < this.length; i3++) {
          w5 = -(this.words[i3] | 0) + carry;
          carry = w5 >> 26;
          this.words[i3] = w5 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN4.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a3 = this.clone();
        var b5 = num;
        var bhi = b5.words[b5.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b5 = b5.ushln(shift);
          a3.iushln(shift);
          bhi = b5.words[b5.length - 1] | 0;
        }
        var m5 = a3.length - b5.length;
        var q6;
        if (mode !== "mod") {
          q6 = new BN4(null);
          q6.length = m5 + 1;
          q6.words = new Array(q6.length);
          for (var i3 = 0; i3 < q6.length; i3++) {
            q6.words[i3] = 0;
          }
        }
        var diff = a3.clone()._ishlnsubmul(b5, 1, m5);
        if (diff.negative === 0) {
          a3 = diff;
          if (q6) {
            q6.words[m5] = 1;
          }
        }
        for (var j6 = m5 - 1; j6 >= 0; j6--) {
          var qj = (a3.words[b5.length + j6] | 0) * 67108864 + (a3.words[b5.length + j6 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a3._ishlnsubmul(b5, qj, j6);
          while (a3.negative !== 0) {
            qj--;
            a3.negative = 0;
            a3._ishlnsubmul(b5, 1, j6);
            if (!a3.isZero()) {
              a3.negative ^= 1;
            }
          }
          if (q6) {
            q6.words[j6] = qj;
          }
        }
        if (q6) {
          q6.strip();
        }
        a3.strip();
        if (mode !== "div" && shift !== 0) {
          a3.iushrn(shift);
        }
        return {
          div: q6 || null,
          mod: a3
        };
      };
      BN4.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN4(0),
            mod: new BN4(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN4(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN4(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN4(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN4.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN4.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN4.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN4.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN4.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p6 = (1 << 26) % num;
        var acc = 0;
        for (var i3 = this.length - 1; i3 >= 0; i3--) {
          acc = (p6 * acc + (this.words[i3] | 0)) % num;
        }
        return acc;
      };
      BN4.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i3 = this.length - 1; i3 >= 0; i3--) {
          var w5 = (this.words[i3] | 0) + carry * 67108864;
          this.words[i3] = w5 / num | 0;
          carry = w5 % num;
        }
        return this.strip();
      };
      BN4.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN4.prototype.egcd = function egcd(p6) {
        assert(p6.negative === 0);
        assert(!p6.isZero());
        var x4 = this;
        var y4 = p6.clone();
        if (x4.negative !== 0) {
          x4 = x4.umod(p6);
        } else {
          x4 = x4.clone();
        }
        var A3 = new BN4(1);
        var B2 = new BN4(0);
        var C7 = new BN4(0);
        var D3 = new BN4(1);
        var g5 = 0;
        while (x4.isEven() && y4.isEven()) {
          x4.iushrn(1);
          y4.iushrn(1);
          ++g5;
        }
        var yp = y4.clone();
        var xp = x4.clone();
        while (!x4.isZero()) {
          for (var i3 = 0, im = 1; (x4.words[0] & im) === 0 && i3 < 26; ++i3, im <<= 1)
            ;
          if (i3 > 0) {
            x4.iushrn(i3);
            while (i3-- > 0) {
              if (A3.isOdd() || B2.isOdd()) {
                A3.iadd(yp);
                B2.isub(xp);
              }
              A3.iushrn(1);
              B2.iushrn(1);
            }
          }
          for (var j6 = 0, jm = 1; (y4.words[0] & jm) === 0 && j6 < 26; ++j6, jm <<= 1)
            ;
          if (j6 > 0) {
            y4.iushrn(j6);
            while (j6-- > 0) {
              if (C7.isOdd() || D3.isOdd()) {
                C7.iadd(yp);
                D3.isub(xp);
              }
              C7.iushrn(1);
              D3.iushrn(1);
            }
          }
          if (x4.cmp(y4) >= 0) {
            x4.isub(y4);
            A3.isub(C7);
            B2.isub(D3);
          } else {
            y4.isub(x4);
            C7.isub(A3);
            D3.isub(B2);
          }
        }
        return {
          a: C7,
          b: D3,
          gcd: y4.iushln(g5)
        };
      };
      BN4.prototype._invmp = function _invmp(p6) {
        assert(p6.negative === 0);
        assert(!p6.isZero());
        var a3 = this;
        var b5 = p6.clone();
        if (a3.negative !== 0) {
          a3 = a3.umod(p6);
        } else {
          a3 = a3.clone();
        }
        var x1 = new BN4(1);
        var x22 = new BN4(0);
        var delta = b5.clone();
        while (a3.cmpn(1) > 0 && b5.cmpn(1) > 0) {
          for (var i3 = 0, im = 1; (a3.words[0] & im) === 0 && i3 < 26; ++i3, im <<= 1)
            ;
          if (i3 > 0) {
            a3.iushrn(i3);
            while (i3-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j6 = 0, jm = 1; (b5.words[0] & jm) === 0 && j6 < 26; ++j6, jm <<= 1)
            ;
          if (j6 > 0) {
            b5.iushrn(j6);
            while (j6-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a3.cmp(b5) >= 0) {
            a3.isub(b5);
            x1.isub(x22);
          } else {
            b5.isub(a3);
            x22.isub(x1);
          }
        }
        var res;
        if (a3.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p6);
        }
        return res;
      };
      BN4.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a3 = this.clone();
        var b5 = num.clone();
        a3.negative = 0;
        b5.negative = 0;
        for (var shift = 0; a3.isEven() && b5.isEven(); shift++) {
          a3.iushrn(1);
          b5.iushrn(1);
        }
        do {
          while (a3.isEven()) {
            a3.iushrn(1);
          }
          while (b5.isEven()) {
            b5.iushrn(1);
          }
          var r = a3.cmp(b5);
          if (r < 0) {
            var t = a3;
            a3 = b5;
            b5 = t;
          } else if (r === 0 || b5.cmpn(1) === 0) {
            break;
          }
          a3.isub(b5);
        } while (true);
        return b5.iushln(shift);
      };
      BN4.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN4.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN4.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN4.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN4.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q6 = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q6;
          return this;
        }
        var carry = q6;
        for (var i3 = s; carry !== 0 && i3 < this.length; i3++) {
          var w5 = this.words[i3] | 0;
          w5 += carry;
          carry = w5 >>> 26;
          w5 &= 67108863;
          this.words[i3] = w5;
        }
        if (carry !== 0) {
          this.words[i3] = carry;
          this.length++;
        }
        return this;
      };
      BN4.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN4.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w5 = this.words[0] | 0;
          res = w5 === num ? 0 : w5 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN4.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN4.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i3 = this.length - 1; i3 >= 0; i3--) {
          var a3 = this.words[i3] | 0;
          var b5 = num.words[i3] | 0;
          if (a3 === b5)
            continue;
          if (a3 < b5) {
            res = -1;
          } else if (a3 > b5) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN4.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN4.prototype.gt = function gt4(num) {
        return this.cmp(num) === 1;
      };
      BN4.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN4.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN4.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN4.prototype.lt = function lt6(num) {
        return this.cmp(num) === -1;
      };
      BN4.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN4.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN4.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN4.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN4.red = function red(num) {
        return new Red(num);
      };
      BN4.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN4.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN4.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN4.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN4.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN4.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN4.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN4.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN4.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN4.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN4.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN4.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN4.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN4.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN4.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN4.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN4.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p6) {
        this.name = name;
        this.p = new BN4(p6, 16);
        this.n = this.p.bitLength();
        this.k = new BN4(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN4(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          r.strip();
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i3 = 0; i3 < outLen; i3++) {
          output.words[i3] = input.words[i3];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i3 = 10; i3 < input.length; i3++) {
          var next = input.words[i3] | 0;
          input.words[i3 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i3 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i3 = 0; i3 < num.length; i3++) {
          var w5 = num.words[i3] | 0;
          lo += w5 * 977;
          num.words[i3] = lo & 67108863;
          lo = w5 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i3 = 0; i3 < num.length; i3++) {
          var hi = (num.words[i3] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i3] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN4._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m5) {
        if (typeof m5 === "string") {
          var prime = BN4._prime(m5);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m5.gtn(1), "modulus must be greater than 1");
          this.m = m5;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a3) {
        assert(a3.negative === 0, "red works only with positives");
        assert(a3.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a3, b5) {
        assert((a3.negative | b5.negative) === 0, "red works only with positives");
        assert(
          a3.red && a3.red === b5.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a3) {
        if (this.prime)
          return this.prime.ireduce(a3)._forceRed(this);
        return a3.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a3) {
        if (a3.isZero()) {
          return a3.clone();
        }
        return this.m.sub(a3)._forceRed(this);
      };
      Red.prototype.add = function add(a3, b5) {
        this._verify2(a3, b5);
        var res = a3.add(b5);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a3, b5) {
        this._verify2(a3, b5);
        var res = a3.iadd(b5);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a3, b5) {
        this._verify2(a3, b5);
        var res = a3.sub(b5);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a3, b5) {
        this._verify2(a3, b5);
        var res = a3.isub(b5);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a3, num) {
        this._verify1(a3);
        return this.imod(a3.ushln(num));
      };
      Red.prototype.imul = function imul(a3, b5) {
        this._verify2(a3, b5);
        return this.imod(a3.imul(b5));
      };
      Red.prototype.mul = function mul(a3, b5) {
        this._verify2(a3, b5);
        return this.imod(a3.mul(b5));
      };
      Red.prototype.isqr = function isqr(a3) {
        return this.imul(a3, a3.clone());
      };
      Red.prototype.sqr = function sqr(a3) {
        return this.mul(a3, a3);
      };
      Red.prototype.sqrt = function sqrt(a3) {
        if (a3.isZero())
          return a3.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN4(1)).iushrn(2);
          return this.pow(a3, pow);
        }
        var q6 = this.m.subn(1);
        var s = 0;
        while (!q6.isZero() && q6.andln(1) === 0) {
          s++;
          q6.iushrn(1);
        }
        assert(!q6.isZero());
        var one = new BN4(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z6 = this.m.bitLength();
        z6 = new BN4(2 * z6 * z6).toRed(this);
        while (this.pow(z6, lpow).cmp(nOne) !== 0) {
          z6.redIAdd(nOne);
        }
        var c3 = this.pow(z6, q6);
        var r = this.pow(a3, q6.addn(1).iushrn(1));
        var t = this.pow(a3, q6);
        var m5 = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i3 = 0; tmp.cmp(one) !== 0; i3++) {
            tmp = tmp.redSqr();
          }
          assert(i3 < m5);
          var b5 = this.pow(c3, new BN4(1).iushln(m5 - i3 - 1));
          r = r.redMul(b5);
          c3 = b5.redSqr();
          t = t.redMul(c3);
          m5 = i3;
        }
        return r;
      };
      Red.prototype.invm = function invm(a3) {
        var inv = a3._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a3, num) {
        if (num.isZero())
          return new BN4(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a3.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN4(1).toRed(this);
        wnd[1] = a3;
        for (var i3 = 2; i3 < wnd.length; i3++) {
          wnd[i3] = this.mul(wnd[i3 - 1], a3);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i3 = num.length - 1; i3 >= 0; i3--) {
          var word = num.words[i3];
          for (var j6 = start - 1; j6 >= 0; j6--) {
            var bit = word >> j6 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i3 !== 0 || j6 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN4.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m5) {
        Red.call(this, m5);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN4(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a3, b5) {
        if (a3.isZero() || b5.isZero()) {
          a3.words[0] = 0;
          a3.length = 1;
          return a3;
        }
        var t = a3.imul(b5);
        var c3 = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t.isub(c3).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a3, b5) {
        if (a3.isZero() || b5.isZero())
          return new BN4(0)._forceRed(this);
        var t = a3.mul(b5);
        var c3 = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t.isub(c3).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a3) {
        var res = this.imod(a3._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/@walletconnect/socket-transport/node_modules/query-string/index.js
var require_query_string4 = __commonJS({
  "node_modules/@walletconnect/socket-transport/node_modules/query-string/index.js"(exports) {
    "use strict";
    init_shim();
    var strictUriEncode = require_strict_uri_encode();
    var decodeComponent = require_decode_uri_component();
    var splitOnFirst = require_split_on_first();
    var isNullOrUndefined = (value) => value === null || value === void 0;
    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case "index":
          return (key) => (result, value) => {
            const index = result.length;
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), "[", index, "]"].join("")];
            }
            return [
              ...result,
              [encode(key, options), "[", encode(index, options), "]=", encode(value, options)].join("")
            ];
          };
        case "bracket":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), "[]"].join("")];
            }
            return [...result, [encode(key, options), "[]=", encode(value, options)].join("")];
          };
        case "comma":
        case "separator":
          return (key) => (result, value) => {
            if (value === null || value === void 0 || value.length === 0) {
              return result;
            }
            if (result.length === 0) {
              return [[encode(key, options), "=", encode(value, options)].join("")];
            }
            return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
          };
        default:
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, encode(key, options)];
            }
            return [...result, [encode(key, options), "=", encode(value, options)].join("")];
          };
      }
    }
    function parserForArrayFormat(options) {
      let result;
      switch (options.arrayFormat) {
        case "index":
          return (key, value, accumulator) => {
            result = /\[(\d*)\]$/.exec(key);
            key = key.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = {};
            }
            accumulator[key][result[1]] = value;
          };
        case "bracket":
          return (key, value, accumulator) => {
            result = /(\[\])$/.exec(key);
            key = key.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "comma":
        case "separator":
          return (key, value, accumulator) => {
            const isArray = typeof value === "string" && value.split("").indexOf(options.arrayFormatSeparator) > -1;
            const newValue = isArray ? value.split(options.arrayFormatSeparator).map((item) => decode(item, options)) : value === null ? value : decode(value, options);
            accumulator[key] = newValue;
          };
        default:
          return (key, value, accumulator) => {
            if (accumulator[key] === void 0) {
              accumulator[key] = value;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
      }
    }
    function validateArrayFormatSeparator(value) {
      if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
      }
    }
    function encode(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
      }
      return value;
    }
    function decode(value, options) {
      if (options.decode) {
        return decodeComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }
      if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort((a3, b5) => Number(a3) - Number(b5)).map((key) => input[key]);
      }
      return input;
    }
    function removeHash(input) {
      const hashStart = input.indexOf("#");
      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }
      return input;
    }
    function getHash(url) {
      let hash = "";
      const hashStart = url.indexOf("#");
      if (hashStart !== -1) {
        hash = url.slice(hashStart);
      }
      return hash;
    }
    function extract(input) {
      input = removeHash(input);
      const queryStart = input.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return input.slice(queryStart + 1);
    }
    function parseValue(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        value = value.toLowerCase() === "true";
      }
      return value;
    }
    function parse6(input, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const formatter = parserForArrayFormat(options);
      const ret = /* @__PURE__ */ Object.create(null);
      if (typeof input !== "string") {
        return ret;
      }
      input = input.trim().replace(/^[?#&]/, "");
      if (!input) {
        return ret;
      }
      for (const param of input.split("&")) {
        let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
        value = value === void 0 ? null : ["comma", "separator"].includes(options.arrayFormat) ? value : decode(value, options);
        formatter(decode(key, options), value, ret);
      }
      for (const key of Object.keys(ret)) {
        const value = ret[key];
        if (typeof value === "object" && value !== null) {
          for (const k3 of Object.keys(value)) {
            value[k3] = parseValue(value[k3], options);
          }
        } else {
          ret[key] = parseValue(value, options);
        }
      }
      if (options.sort === false) {
        return ret;
      }
      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
        const value = ret[key];
        if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
          result[key] = keysSorter(value);
        } else {
          result[key] = value;
        }
        return result;
      }, /* @__PURE__ */ Object.create(null));
    }
    exports.extract = extract;
    exports.parse = parse6;
    exports.stringify = (object, options) => {
      if (!object) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const shouldFilter = (key) => options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === "";
      const formatter = encoderForArrayFormat(options);
      const objectCopy = {};
      for (const key of Object.keys(object)) {
        if (!shouldFilter(key)) {
          objectCopy[key] = object[key];
        }
      }
      const keys = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys.sort(options.sort);
      }
      return keys.map((key) => {
        const value = object[key];
        if (value === void 0) {
          return "";
        }
        if (value === null) {
          return encode(key, options);
        }
        if (Array.isArray(value)) {
          return value.reduce(formatter(key), []).join("&");
        }
        return encode(key, options) + "=" + encode(value, options);
      }).filter((x4) => x4.length > 0).join("&");
    };
    exports.parseUrl = (input, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url, hash] = splitOnFirst(input, "#");
      return Object.assign(
        {
          url: url.split("?")[0] || "",
          query: parse6(extract(input), options)
        },
        options && options.parseFragmentIdentifier && hash ? { fragmentIdentifier: decode(hash, options) } : {}
      );
    };
    exports.stringifyUrl = (input, options) => {
      options = Object.assign({
        encode: true,
        strict: true
      }, options);
      const url = removeHash(input.url).split("?")[0] || "";
      const queryFromUrl = exports.extract(input.url);
      const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
      const query = Object.assign(parsedQueryFromUrl, input.query);
      let queryString = exports.stringify(query, options);
      if (queryString) {
        queryString = `?${queryString}`;
      }
      let hash = getHash(input.url);
      if (input.fragmentIdentifier) {
        hash = `#${encode(input.fragmentIdentifier, options)}`;
      }
      return `${url}${queryString}${hash}`;
    };
  }
});

// node_modules/@walletconnect/socket-transport/node_modules/ws/browser.js
var require_browser4 = __commonJS({
  "node_modules/@walletconnect/socket-transport/node_modules/ws/browser.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// node_modules/@walletconnect/iso-crypto/node_modules/bn.js/lib/bn.js
var require_bn3 = __commonJS({
  "node_modules/@walletconnect/iso-crypto/node_modules/bn.js/lib/bn.js"(exports, module) {
    init_shim();
    (function(module2, exports2) {
      "use strict";
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN4(number, base, endian) {
        if (BN4.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN4;
      } else {
        exports2.BN = BN4;
      }
      BN4.BN = BN4;
      BN4.wordSize = 26;
      var Buffer2;
      try {
        Buffer2 = require_buffer().Buffer;
      } catch (e) {
      }
      BN4.isBN = function isBN(num) {
        if (num instanceof BN4) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN4.wordSize && Array.isArray(num.words);
      };
      BN4.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN4.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN4.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
        }
        if (base === 16) {
          this._parseHex(number, start);
        } else {
          this._parseBase(number, base, start);
        }
        if (number[0] === "-") {
          this.negative = 1;
        }
        this.strip();
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN4.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN4.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i3 = 0; i3 < this.length; i3++) {
          this.words[i3] = 0;
        }
        var j6, w5;
        var off = 0;
        if (endian === "be") {
          for (i3 = number.length - 1, j6 = 0; i3 >= 0; i3 -= 3) {
            w5 = number[i3] | number[i3 - 1] << 8 | number[i3 - 2] << 16;
            this.words[j6] |= w5 << off & 67108863;
            this.words[j6 + 1] = w5 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j6++;
            }
          }
        } else if (endian === "le") {
          for (i3 = 0, j6 = 0; i3 < number.length; i3 += 3) {
            w5 = number[i3] | number[i3 + 1] << 8 | number[i3 + 2] << 16;
            this.words[j6] |= w5 << off & 67108863;
            this.words[j6 + 1] = w5 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j6++;
            }
          }
        }
        return this.strip();
      };
      function parseHex(str, start, end) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i3 = start; i3 < len; i3++) {
          var c3 = str.charCodeAt(i3) - 48;
          r <<= 4;
          if (c3 >= 49 && c3 <= 54) {
            r |= c3 - 49 + 10;
          } else if (c3 >= 17 && c3 <= 22) {
            r |= c3 - 17 + 10;
          } else {
            r |= c3 & 15;
          }
        }
        return r;
      }
      BN4.prototype._parseHex = function _parseHex(number, start) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i3 = 0; i3 < this.length; i3++) {
          this.words[i3] = 0;
        }
        var j6, w5;
        var off = 0;
        for (i3 = number.length - 6, j6 = 0; i3 >= start; i3 -= 6) {
          w5 = parseHex(number, i3, i3 + 6);
          this.words[j6] |= w5 << off & 67108863;
          this.words[j6 + 1] |= w5 >>> 26 - off & 4194303;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j6++;
          }
        }
        if (i3 + 6 !== start) {
          w5 = parseHex(number, start, i3 + 6);
          this.words[j6] |= w5 << off & 67108863;
          this.words[j6 + 1] |= w5 >>> 26 - off & 4194303;
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i3 = start; i3 < len; i3++) {
          var c3 = str.charCodeAt(i3) - 48;
          r *= mul;
          if (c3 >= 49) {
            r += c3 - 49 + 10;
          } else if (c3 >= 17) {
            r += c3 - 17 + 10;
          } else {
            r += c3;
          }
        }
        return r;
      }
      BN4.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i3 = start; i3 < end; i3 += limbLen) {
          word = parseBase(number, i3, i3 + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i3, number.length, base);
          for (i3 = 0; i3 < mod; i3++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
      };
      BN4.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i3 = 0; i3 < this.length; i3++) {
          dest.words[i3] = this.words[i3];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN4.prototype.clone = function clone() {
        var r = new BN4(null);
        this.copy(r);
        return r;
      };
      BN4.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN4.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN4.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN4.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN4.prototype.toString = function toString2(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i3 = 0; i3 < this.length; i3++) {
            var w5 = this.words[i3];
            var word = ((w5 << off | carry) & 16777215).toString(16);
            carry = w5 >>> 24 - off & 16777215;
            if (carry !== 0 || i3 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i3--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c3 = this.clone();
          c3.negative = 0;
          while (!c3.isZero()) {
            var r = c3.modn(groupBase).toString(base);
            c3 = c3.idivn(groupBase);
            if (!c3.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN4.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN4.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN4.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length);
      };
      BN4.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN4.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b5, i3;
        var q6 = this.clone();
        if (!littleEndian) {
          for (i3 = 0; i3 < reqLength - byteLength; i3++) {
            res[i3] = 0;
          }
          for (i3 = 0; !q6.isZero(); i3++) {
            b5 = q6.andln(255);
            q6.iushrn(8);
            res[reqLength - i3 - 1] = b5;
          }
        } else {
          for (i3 = 0; !q6.isZero(); i3++) {
            b5 = q6.andln(255);
            q6.iushrn(8);
            res[i3] = b5;
          }
          for (; i3 < reqLength; i3++) {
            res[i3] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN4.prototype._countBits = function _countBits(w5) {
          return 32 - Math.clz32(w5);
        };
      } else {
        BN4.prototype._countBits = function _countBits(w5) {
          var t = w5;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN4.prototype._zeroBits = function _zeroBits(w5) {
        if (w5 === 0)
          return 26;
        var t = w5;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN4.prototype.bitLength = function bitLength() {
        var w5 = this.words[this.length - 1];
        var hi = this._countBits(w5);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w5 = new Array(num.bitLength());
        for (var bit = 0; bit < w5.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w5[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w5;
      }
      BN4.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i3 = 0; i3 < this.length; i3++) {
          var b5 = this._zeroBits(this.words[i3]);
          r += b5;
          if (b5 !== 26)
            break;
        }
        return r;
      };
      BN4.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN4.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN4.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN4.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN4.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN4.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN4.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i3 = 0; i3 < num.length; i3++) {
          this.words[i3] = this.words[i3] | num.words[i3];
        }
        return this.strip();
      };
      BN4.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN4.prototype.or = function or3(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN4.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN4.prototype.iuand = function iuand(num) {
        var b5;
        if (this.length > num.length) {
          b5 = num;
        } else {
          b5 = this;
        }
        for (var i3 = 0; i3 < b5.length; i3++) {
          this.words[i3] = this.words[i3] & num.words[i3];
        }
        this.length = b5.length;
        return this.strip();
      };
      BN4.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN4.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN4.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN4.prototype.iuxor = function iuxor(num) {
        var a3;
        var b5;
        if (this.length > num.length) {
          a3 = this;
          b5 = num;
        } else {
          a3 = num;
          b5 = this;
        }
        for (var i3 = 0; i3 < b5.length; i3++) {
          this.words[i3] = a3.words[i3] ^ b5.words[i3];
        }
        if (this !== a3) {
          for (; i3 < a3.length; i3++) {
            this.words[i3] = a3.words[i3];
          }
        }
        this.length = a3.length;
        return this.strip();
      };
      BN4.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN4.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN4.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN4.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i3 = 0; i3 < bytesNeeded; i3++) {
          this.words[i3] = ~this.words[i3] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i3] = ~this.words[i3] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN4.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN4.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN4.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a3, b5;
        if (this.length > num.length) {
          a3 = this;
          b5 = num;
        } else {
          a3 = num;
          b5 = this;
        }
        var carry = 0;
        for (var i3 = 0; i3 < b5.length; i3++) {
          r = (a3.words[i3] | 0) + (b5.words[i3] | 0) + carry;
          this.words[i3] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i3 < a3.length; i3++) {
          r = (a3.words[i3] | 0) + carry;
          this.words[i3] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a3.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a3 !== this) {
          for (; i3 < a3.length; i3++) {
            this.words[i3] = a3.words[i3];
          }
        }
        return this;
      };
      BN4.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN4.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a3, b5;
        if (cmp > 0) {
          a3 = this;
          b5 = num;
        } else {
          a3 = num;
          b5 = this;
        }
        var carry = 0;
        for (var i3 = 0; i3 < b5.length; i3++) {
          r = (a3.words[i3] | 0) - (b5.words[i3] | 0) + carry;
          carry = r >> 26;
          this.words[i3] = r & 67108863;
        }
        for (; carry !== 0 && i3 < a3.length; i3++) {
          r = (a3.words[i3] | 0) + carry;
          carry = r >> 26;
          this.words[i3] = r & 67108863;
        }
        if (carry === 0 && i3 < a3.length && a3 !== this) {
          for (; i3 < a3.length; i3++) {
            this.words[i3] = a3.words[i3];
          }
        }
        this.length = Math.max(this.length, i3);
        if (a3 !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN4.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a3 = self2.words[0] | 0;
        var b5 = num.words[0] | 0;
        var r = a3 * b5;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k3 = 1; k3 < len; k3++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k3, num.length - 1);
          for (var j6 = Math.max(0, k3 - self2.length + 1); j6 <= maxJ; j6++) {
            var i3 = k3 - j6 | 0;
            a3 = self2.words[i3] | 0;
            b5 = num.words[j6] | 0;
            r = a3 * b5 + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k3] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k3] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a3 = self2.words;
        var b5 = num.words;
        var o2 = out.words;
        var c3 = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a3[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a3[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a3[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a3[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a4 = a3[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a3[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a3[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a3[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a3[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a3[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b5[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b5[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b5[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b5[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b42 = b5[4] | 0;
        var bl4 = b42 & 8191;
        var bh4 = b42 >>> 13;
        var b52 = b5[5] | 0;
        var bl5 = b52 & 8191;
        var bh5 = b52 >>> 13;
        var b6 = b5[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b5[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b5[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b5[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w22 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w32 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w42 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o2[0] = w0;
        o2[1] = w1;
        o2[2] = w22;
        o2[3] = w32;
        o2[4] = w42;
        o2[5] = w5;
        o2[6] = w6;
        o2[7] = w7;
        o2[8] = w8;
        o2[9] = w9;
        o2[10] = w10;
        o2[11] = w11;
        o2[12] = w12;
        o2[13] = w13;
        o2[14] = w14;
        o2[15] = w15;
        o2[16] = w16;
        o2[17] = w17;
        o2[18] = w18;
        if (c3 !== 0) {
          o2[19] = c3;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k3 = 0; k3 < out.length - 1; k3++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k3, num.length - 1);
          for (var j6 = Math.max(0, k3 - self2.length + 1); j6 <= maxJ; j6++) {
            var i3 = k3 - j6;
            var a3 = self2.words[i3] | 0;
            var b5 = num.words[j6] | 0;
            var r = a3 * b5;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k3] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k3] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN4.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x4, y4) {
        this.x = x4;
        this.y = y4;
      }
      FFTM.prototype.makeRBT = function makeRBT(N6) {
        var t = new Array(N6);
        var l2 = BN4.prototype._countBits(N6) - 1;
        for (var i3 = 0; i3 < N6; i3++) {
          t[i3] = this.revBin(i3, l2, N6);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x4, l2, N6) {
        if (x4 === 0 || x4 === N6 - 1)
          return x4;
        var rb = 0;
        for (var i3 = 0; i3 < l2; i3++) {
          rb |= (x4 & 1) << l2 - i3 - 1;
          x4 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N6) {
        for (var i3 = 0; i3 < N6; i3++) {
          rtws[i3] = rws[rbt[i3]];
          itws[i3] = iws[rbt[i3]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N6, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N6);
        for (var s = 1; s < N6; s <<= 1) {
          var l2 = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l2);
          var itwdf = Math.sin(2 * Math.PI / l2);
          for (var p6 = 0; p6 < N6; p6 += l2) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j6 = 0; j6 < s; j6++) {
              var re5 = rtws[p6 + j6];
              var ie5 = itws[p6 + j6];
              var ro = rtws[p6 + j6 + s];
              var io = itws[p6 + j6 + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p6 + j6] = re5 + ro;
              itws[p6 + j6] = ie5 + io;
              rtws[p6 + j6 + s] = re5 - ro;
              itws[p6 + j6 + s] = ie5 - io;
              if (j6 !== l2) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n3, m5) {
        var N6 = Math.max(m5, n3) | 1;
        var odd = N6 & 1;
        var i3 = 0;
        for (N6 = N6 / 2 | 0; N6; N6 = N6 >>> 1) {
          i3++;
        }
        return 1 << i3 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N6) {
        if (N6 <= 1)
          return;
        for (var i3 = 0; i3 < N6 / 2; i3++) {
          var t = rws[i3];
          rws[i3] = rws[N6 - i3 - 1];
          rws[N6 - i3 - 1] = t;
          t = iws[i3];
          iws[i3] = -iws[N6 - i3 - 1];
          iws[N6 - i3 - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws3, N6) {
        var carry = 0;
        for (var i3 = 0; i3 < N6 / 2; i3++) {
          var w5 = Math.round(ws3[2 * i3 + 1] / N6) * 8192 + Math.round(ws3[2 * i3] / N6) + carry;
          ws3[i3] = w5 & 67108863;
          if (w5 < 67108864) {
            carry = 0;
          } else {
            carry = w5 / 67108864 | 0;
          }
        }
        return ws3;
      };
      FFTM.prototype.convert13b = function convert13b(ws3, len, rws, N6) {
        var carry = 0;
        for (var i3 = 0; i3 < len; i3++) {
          carry = carry + (ws3[i3] | 0);
          rws[2 * i3] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i3 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i3 = 2 * len; i3 < N6; ++i3) {
          rws[i3] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N6) {
        var ph = new Array(N6);
        for (var i3 = 0; i3 < N6; i3++) {
          ph[i3] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x4, y4, out) {
        var N6 = 2 * this.guessLen13b(x4.length, y4.length);
        var rbt = this.makeRBT(N6);
        var _4 = this.stub(N6);
        var rws = new Array(N6);
        var rwst = new Array(N6);
        var iwst = new Array(N6);
        var nrws = new Array(N6);
        var nrwst = new Array(N6);
        var niwst = new Array(N6);
        var rmws = out.words;
        rmws.length = N6;
        this.convert13b(x4.words, x4.length, rws, N6);
        this.convert13b(y4.words, y4.length, nrws, N6);
        this.transform(rws, _4, rwst, iwst, N6, rbt);
        this.transform(nrws, _4, nrwst, niwst, N6, rbt);
        for (var i3 = 0; i3 < N6; i3++) {
          var rx = rwst[i3] * nrwst[i3] - iwst[i3] * niwst[i3];
          iwst[i3] = rwst[i3] * niwst[i3] + iwst[i3] * nrwst[i3];
          rwst[i3] = rx;
        }
        this.conjugate(rwst, iwst, N6);
        this.transform(rwst, iwst, rmws, _4, N6, rbt);
        this.conjugate(rmws, _4, N6);
        this.normalize13b(rmws, N6);
        out.negative = x4.negative ^ y4.negative;
        out.length = x4.length + y4.length;
        return out.strip();
      };
      BN4.prototype.mul = function mul(num) {
        var out = new BN4(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN4.prototype.mulf = function mulf(num) {
        var out = new BN4(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN4.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN4.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i3 = 0; i3 < this.length; i3++) {
          var w5 = (this.words[i3] | 0) * num;
          var lo = (w5 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w5 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i3] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i3] = carry;
          this.length++;
        }
        return this;
      };
      BN4.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN4.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN4.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN4.prototype.pow = function pow(num) {
        var w5 = toBitArray(num);
        if (w5.length === 0)
          return new BN4(1);
        var res = this;
        for (var i3 = 0; i3 < w5.length; i3++, res = res.sqr()) {
          if (w5[i3] !== 0)
            break;
        }
        if (++i3 < w5.length) {
          for (var q6 = res.sqr(); i3 < w5.length; i3++, q6 = q6.sqr()) {
            if (w5[i3] === 0)
              continue;
            res = res.mul(q6);
          }
        }
        return res;
      };
      BN4.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i3;
        if (r !== 0) {
          var carry = 0;
          for (i3 = 0; i3 < this.length; i3++) {
            var newCarry = this.words[i3] & carryMask;
            var c3 = (this.words[i3] | 0) - newCarry << r;
            this.words[i3] = c3 | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i3] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i3 = this.length - 1; i3 >= 0; i3--) {
            this.words[i3 + s] = this.words[i3];
          }
          for (i3 = 0; i3 < s; i3++) {
            this.words[i3] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN4.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN4.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h3;
        if (hint) {
          h3 = (hint - hint % 26) / 26;
        } else {
          h3 = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h3 -= s;
        h3 = Math.max(0, h3);
        if (maskedWords) {
          for (var i3 = 0; i3 < s; i3++) {
            maskedWords.words[i3] = this.words[i3];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i3 = 0; i3 < this.length; i3++) {
            this.words[i3] = this.words[i3 + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i3 = this.length - 1; i3 >= 0 && (carry !== 0 || i3 >= h3); i3--) {
          var word = this.words[i3] | 0;
          this.words[i3] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN4.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN4.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN4.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN4.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN4.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN4.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q6 = 1 << r;
        if (this.length <= s)
          return false;
        var w5 = this.words[s];
        return !!(w5 & q6);
      };
      BN4.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN4.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN4.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN4.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i3 = 0; i3 < this.length && this.words[i3] >= 67108864; i3++) {
          this.words[i3] -= 67108864;
          if (i3 === this.length - 1) {
            this.words[i3 + 1] = 1;
          } else {
            this.words[i3 + 1]++;
          }
        }
        this.length = Math.max(this.length, i3 + 1);
        return this;
      };
      BN4.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i3 = 0; i3 < this.length && this.words[i3] < 0; i3++) {
            this.words[i3] += 67108864;
            this.words[i3 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN4.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN4.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN4.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN4.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN4.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i3;
        this._expand(len);
        var w5;
        var carry = 0;
        for (i3 = 0; i3 < num.length; i3++) {
          w5 = (this.words[i3 + shift] | 0) + carry;
          var right = (num.words[i3] | 0) * mul;
          w5 -= right & 67108863;
          carry = (w5 >> 26) - (right / 67108864 | 0);
          this.words[i3 + shift] = w5 & 67108863;
        }
        for (; i3 < this.length - shift; i3++) {
          w5 = (this.words[i3 + shift] | 0) + carry;
          carry = w5 >> 26;
          this.words[i3 + shift] = w5 & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i3 = 0; i3 < this.length; i3++) {
          w5 = -(this.words[i3] | 0) + carry;
          carry = w5 >> 26;
          this.words[i3] = w5 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN4.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a3 = this.clone();
        var b5 = num;
        var bhi = b5.words[b5.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b5 = b5.ushln(shift);
          a3.iushln(shift);
          bhi = b5.words[b5.length - 1] | 0;
        }
        var m5 = a3.length - b5.length;
        var q6;
        if (mode !== "mod") {
          q6 = new BN4(null);
          q6.length = m5 + 1;
          q6.words = new Array(q6.length);
          for (var i3 = 0; i3 < q6.length; i3++) {
            q6.words[i3] = 0;
          }
        }
        var diff = a3.clone()._ishlnsubmul(b5, 1, m5);
        if (diff.negative === 0) {
          a3 = diff;
          if (q6) {
            q6.words[m5] = 1;
          }
        }
        for (var j6 = m5 - 1; j6 >= 0; j6--) {
          var qj = (a3.words[b5.length + j6] | 0) * 67108864 + (a3.words[b5.length + j6 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a3._ishlnsubmul(b5, qj, j6);
          while (a3.negative !== 0) {
            qj--;
            a3.negative = 0;
            a3._ishlnsubmul(b5, 1, j6);
            if (!a3.isZero()) {
              a3.negative ^= 1;
            }
          }
          if (q6) {
            q6.words[j6] = qj;
          }
        }
        if (q6) {
          q6.strip();
        }
        a3.strip();
        if (mode !== "div" && shift !== 0) {
          a3.iushrn(shift);
        }
        return {
          div: q6 || null,
          mod: a3
        };
      };
      BN4.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN4(0),
            mod: new BN4(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN4(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN4(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN4(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN4.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN4.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN4.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN4.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN4.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p6 = (1 << 26) % num;
        var acc = 0;
        for (var i3 = this.length - 1; i3 >= 0; i3--) {
          acc = (p6 * acc + (this.words[i3] | 0)) % num;
        }
        return acc;
      };
      BN4.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i3 = this.length - 1; i3 >= 0; i3--) {
          var w5 = (this.words[i3] | 0) + carry * 67108864;
          this.words[i3] = w5 / num | 0;
          carry = w5 % num;
        }
        return this.strip();
      };
      BN4.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN4.prototype.egcd = function egcd(p6) {
        assert(p6.negative === 0);
        assert(!p6.isZero());
        var x4 = this;
        var y4 = p6.clone();
        if (x4.negative !== 0) {
          x4 = x4.umod(p6);
        } else {
          x4 = x4.clone();
        }
        var A3 = new BN4(1);
        var B2 = new BN4(0);
        var C7 = new BN4(0);
        var D3 = new BN4(1);
        var g5 = 0;
        while (x4.isEven() && y4.isEven()) {
          x4.iushrn(1);
          y4.iushrn(1);
          ++g5;
        }
        var yp = y4.clone();
        var xp = x4.clone();
        while (!x4.isZero()) {
          for (var i3 = 0, im = 1; (x4.words[0] & im) === 0 && i3 < 26; ++i3, im <<= 1)
            ;
          if (i3 > 0) {
            x4.iushrn(i3);
            while (i3-- > 0) {
              if (A3.isOdd() || B2.isOdd()) {
                A3.iadd(yp);
                B2.isub(xp);
              }
              A3.iushrn(1);
              B2.iushrn(1);
            }
          }
          for (var j6 = 0, jm = 1; (y4.words[0] & jm) === 0 && j6 < 26; ++j6, jm <<= 1)
            ;
          if (j6 > 0) {
            y4.iushrn(j6);
            while (j6-- > 0) {
              if (C7.isOdd() || D3.isOdd()) {
                C7.iadd(yp);
                D3.isub(xp);
              }
              C7.iushrn(1);
              D3.iushrn(1);
            }
          }
          if (x4.cmp(y4) >= 0) {
            x4.isub(y4);
            A3.isub(C7);
            B2.isub(D3);
          } else {
            y4.isub(x4);
            C7.isub(A3);
            D3.isub(B2);
          }
        }
        return {
          a: C7,
          b: D3,
          gcd: y4.iushln(g5)
        };
      };
      BN4.prototype._invmp = function _invmp(p6) {
        assert(p6.negative === 0);
        assert(!p6.isZero());
        var a3 = this;
        var b5 = p6.clone();
        if (a3.negative !== 0) {
          a3 = a3.umod(p6);
        } else {
          a3 = a3.clone();
        }
        var x1 = new BN4(1);
        var x22 = new BN4(0);
        var delta = b5.clone();
        while (a3.cmpn(1) > 0 && b5.cmpn(1) > 0) {
          for (var i3 = 0, im = 1; (a3.words[0] & im) === 0 && i3 < 26; ++i3, im <<= 1)
            ;
          if (i3 > 0) {
            a3.iushrn(i3);
            while (i3-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j6 = 0, jm = 1; (b5.words[0] & jm) === 0 && j6 < 26; ++j6, jm <<= 1)
            ;
          if (j6 > 0) {
            b5.iushrn(j6);
            while (j6-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a3.cmp(b5) >= 0) {
            a3.isub(b5);
            x1.isub(x22);
          } else {
            b5.isub(a3);
            x22.isub(x1);
          }
        }
        var res;
        if (a3.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p6);
        }
        return res;
      };
      BN4.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a3 = this.clone();
        var b5 = num.clone();
        a3.negative = 0;
        b5.negative = 0;
        for (var shift = 0; a3.isEven() && b5.isEven(); shift++) {
          a3.iushrn(1);
          b5.iushrn(1);
        }
        do {
          while (a3.isEven()) {
            a3.iushrn(1);
          }
          while (b5.isEven()) {
            b5.iushrn(1);
          }
          var r = a3.cmp(b5);
          if (r < 0) {
            var t = a3;
            a3 = b5;
            b5 = t;
          } else if (r === 0 || b5.cmpn(1) === 0) {
            break;
          }
          a3.isub(b5);
        } while (true);
        return b5.iushln(shift);
      };
      BN4.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN4.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN4.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN4.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN4.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q6 = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q6;
          return this;
        }
        var carry = q6;
        for (var i3 = s; carry !== 0 && i3 < this.length; i3++) {
          var w5 = this.words[i3] | 0;
          w5 += carry;
          carry = w5 >>> 26;
          w5 &= 67108863;
          this.words[i3] = w5;
        }
        if (carry !== 0) {
          this.words[i3] = carry;
          this.length++;
        }
        return this;
      };
      BN4.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN4.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w5 = this.words[0] | 0;
          res = w5 === num ? 0 : w5 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN4.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN4.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i3 = this.length - 1; i3 >= 0; i3--) {
          var a3 = this.words[i3] | 0;
          var b5 = num.words[i3] | 0;
          if (a3 === b5)
            continue;
          if (a3 < b5) {
            res = -1;
          } else if (a3 > b5) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN4.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN4.prototype.gt = function gt4(num) {
        return this.cmp(num) === 1;
      };
      BN4.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN4.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN4.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN4.prototype.lt = function lt6(num) {
        return this.cmp(num) === -1;
      };
      BN4.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN4.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN4.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN4.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN4.red = function red(num) {
        return new Red(num);
      };
      BN4.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN4.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN4.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN4.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN4.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN4.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN4.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN4.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN4.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN4.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN4.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN4.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN4.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN4.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN4.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN4.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN4.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p6) {
        this.name = name;
        this.p = new BN4(p6, 16);
        this.n = this.p.bitLength();
        this.k = new BN4(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN4(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          r.strip();
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i3 = 0; i3 < outLen; i3++) {
          output.words[i3] = input.words[i3];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i3 = 10; i3 < input.length; i3++) {
          var next = input.words[i3] | 0;
          input.words[i3 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i3 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i3 = 0; i3 < num.length; i3++) {
          var w5 = num.words[i3] | 0;
          lo += w5 * 977;
          num.words[i3] = lo & 67108863;
          lo = w5 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i3 = 0; i3 < num.length; i3++) {
          var hi = (num.words[i3] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i3] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN4._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m5) {
        if (typeof m5 === "string") {
          var prime = BN4._prime(m5);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m5.gtn(1), "modulus must be greater than 1");
          this.m = m5;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a3) {
        assert(a3.negative === 0, "red works only with positives");
        assert(a3.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a3, b5) {
        assert((a3.negative | b5.negative) === 0, "red works only with positives");
        assert(
          a3.red && a3.red === b5.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a3) {
        if (this.prime)
          return this.prime.ireduce(a3)._forceRed(this);
        return a3.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a3) {
        if (a3.isZero()) {
          return a3.clone();
        }
        return this.m.sub(a3)._forceRed(this);
      };
      Red.prototype.add = function add(a3, b5) {
        this._verify2(a3, b5);
        var res = a3.add(b5);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a3, b5) {
        this._verify2(a3, b5);
        var res = a3.iadd(b5);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a3, b5) {
        this._verify2(a3, b5);
        var res = a3.sub(b5);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a3, b5) {
        this._verify2(a3, b5);
        var res = a3.isub(b5);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a3, num) {
        this._verify1(a3);
        return this.imod(a3.ushln(num));
      };
      Red.prototype.imul = function imul(a3, b5) {
        this._verify2(a3, b5);
        return this.imod(a3.imul(b5));
      };
      Red.prototype.mul = function mul(a3, b5) {
        this._verify2(a3, b5);
        return this.imod(a3.mul(b5));
      };
      Red.prototype.isqr = function isqr(a3) {
        return this.imul(a3, a3.clone());
      };
      Red.prototype.sqr = function sqr(a3) {
        return this.mul(a3, a3);
      };
      Red.prototype.sqrt = function sqrt(a3) {
        if (a3.isZero())
          return a3.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN4(1)).iushrn(2);
          return this.pow(a3, pow);
        }
        var q6 = this.m.subn(1);
        var s = 0;
        while (!q6.isZero() && q6.andln(1) === 0) {
          s++;
          q6.iushrn(1);
        }
        assert(!q6.isZero());
        var one = new BN4(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z6 = this.m.bitLength();
        z6 = new BN4(2 * z6 * z6).toRed(this);
        while (this.pow(z6, lpow).cmp(nOne) !== 0) {
          z6.redIAdd(nOne);
        }
        var c3 = this.pow(z6, q6);
        var r = this.pow(a3, q6.addn(1).iushrn(1));
        var t = this.pow(a3, q6);
        var m5 = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i3 = 0; tmp.cmp(one) !== 0; i3++) {
            tmp = tmp.redSqr();
          }
          assert(i3 < m5);
          var b5 = this.pow(c3, new BN4(1).iushln(m5 - i3 - 1));
          r = r.redMul(b5);
          c3 = b5.redSqr();
          t = t.redMul(c3);
          m5 = i3;
        }
        return r;
      };
      Red.prototype.invm = function invm(a3) {
        var inv = a3._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a3, num) {
        if (num.isZero())
          return new BN4(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a3.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN4(1).toRed(this);
        wnd[1] = a3;
        for (var i3 = 2; i3 < wnd.length; i3++) {
          wnd[i3] = this.mul(wnd[i3 - 1], a3);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i3 = num.length - 1; i3 >= 0; i3--) {
          var word = num.words[i3];
          for (var j6 = start - 1; j6 >= 0; j6--) {
            var bit = word >> j6 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i3 !== 0 || j6 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN4.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m5) {
        Red.call(this, m5);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN4(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a3, b5) {
        if (a3.isZero() || b5.isZero()) {
          a3.words[0] = 0;
          a3.length = 1;
          return a3;
        }
        var t = a3.imul(b5);
        var c3 = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t.isub(c3).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a3, b5) {
        if (a3.isZero() || b5.isZero())
          return new BN4(0)._forceRed(this);
        var t = a3.mul(b5);
        var c3 = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t.isub(c3).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a3) {
        var res = this.imod(a3._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/@walletconnect/iso-crypto/node_modules/query-string/index.js
var require_query_string5 = __commonJS({
  "node_modules/@walletconnect/iso-crypto/node_modules/query-string/index.js"(exports) {
    "use strict";
    init_shim();
    var strictUriEncode = require_strict_uri_encode();
    var decodeComponent = require_decode_uri_component();
    var splitOnFirst = require_split_on_first();
    var isNullOrUndefined = (value) => value === null || value === void 0;
    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case "index":
          return (key) => (result, value) => {
            const index = result.length;
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), "[", index, "]"].join("")];
            }
            return [
              ...result,
              [encode(key, options), "[", encode(index, options), "]=", encode(value, options)].join("")
            ];
          };
        case "bracket":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), "[]"].join("")];
            }
            return [...result, [encode(key, options), "[]=", encode(value, options)].join("")];
          };
        case "comma":
        case "separator":
          return (key) => (result, value) => {
            if (value === null || value === void 0 || value.length === 0) {
              return result;
            }
            if (result.length === 0) {
              return [[encode(key, options), "=", encode(value, options)].join("")];
            }
            return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
          };
        default:
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, encode(key, options)];
            }
            return [...result, [encode(key, options), "=", encode(value, options)].join("")];
          };
      }
    }
    function parserForArrayFormat(options) {
      let result;
      switch (options.arrayFormat) {
        case "index":
          return (key, value, accumulator) => {
            result = /\[(\d*)\]$/.exec(key);
            key = key.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = {};
            }
            accumulator[key][result[1]] = value;
          };
        case "bracket":
          return (key, value, accumulator) => {
            result = /(\[\])$/.exec(key);
            key = key.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "comma":
        case "separator":
          return (key, value, accumulator) => {
            const isArray = typeof value === "string" && value.split("").indexOf(options.arrayFormatSeparator) > -1;
            const newValue = isArray ? value.split(options.arrayFormatSeparator).map((item) => decode(item, options)) : value === null ? value : decode(value, options);
            accumulator[key] = newValue;
          };
        default:
          return (key, value, accumulator) => {
            if (accumulator[key] === void 0) {
              accumulator[key] = value;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
      }
    }
    function validateArrayFormatSeparator(value) {
      if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
      }
    }
    function encode(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
      }
      return value;
    }
    function decode(value, options) {
      if (options.decode) {
        return decodeComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }
      if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort((a3, b5) => Number(a3) - Number(b5)).map((key) => input[key]);
      }
      return input;
    }
    function removeHash(input) {
      const hashStart = input.indexOf("#");
      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }
      return input;
    }
    function getHash(url) {
      let hash = "";
      const hashStart = url.indexOf("#");
      if (hashStart !== -1) {
        hash = url.slice(hashStart);
      }
      return hash;
    }
    function extract(input) {
      input = removeHash(input);
      const queryStart = input.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return input.slice(queryStart + 1);
    }
    function parseValue(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        value = value.toLowerCase() === "true";
      }
      return value;
    }
    function parse6(input, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const formatter = parserForArrayFormat(options);
      const ret = /* @__PURE__ */ Object.create(null);
      if (typeof input !== "string") {
        return ret;
      }
      input = input.trim().replace(/^[?#&]/, "");
      if (!input) {
        return ret;
      }
      for (const param of input.split("&")) {
        let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
        value = value === void 0 ? null : ["comma", "separator"].includes(options.arrayFormat) ? value : decode(value, options);
        formatter(decode(key, options), value, ret);
      }
      for (const key of Object.keys(ret)) {
        const value = ret[key];
        if (typeof value === "object" && value !== null) {
          for (const k3 of Object.keys(value)) {
            value[k3] = parseValue(value[k3], options);
          }
        } else {
          ret[key] = parseValue(value, options);
        }
      }
      if (options.sort === false) {
        return ret;
      }
      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
        const value = ret[key];
        if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
          result[key] = keysSorter(value);
        } else {
          result[key] = value;
        }
        return result;
      }, /* @__PURE__ */ Object.create(null));
    }
    exports.extract = extract;
    exports.parse = parse6;
    exports.stringify = (object, options) => {
      if (!object) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const shouldFilter = (key) => options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === "";
      const formatter = encoderForArrayFormat(options);
      const objectCopy = {};
      for (const key of Object.keys(object)) {
        if (!shouldFilter(key)) {
          objectCopy[key] = object[key];
        }
      }
      const keys = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys.sort(options.sort);
      }
      return keys.map((key) => {
        const value = object[key];
        if (value === void 0) {
          return "";
        }
        if (value === null) {
          return encode(key, options);
        }
        if (Array.isArray(value)) {
          return value.reduce(formatter(key), []).join("&");
        }
        return encode(key, options) + "=" + encode(value, options);
      }).filter((x4) => x4.length > 0).join("&");
    };
    exports.parseUrl = (input, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url, hash] = splitOnFirst(input, "#");
      return Object.assign(
        {
          url: url.split("?")[0] || "",
          query: parse6(extract(input), options)
        },
        options && options.parseFragmentIdentifier && hash ? { fragmentIdentifier: decode(hash, options) } : {}
      );
    };
    exports.stringifyUrl = (input, options) => {
      options = Object.assign({
        encode: true,
        strict: true
      }, options);
      const url = removeHash(input.url).split("?")[0] || "";
      const queryFromUrl = exports.extract(input.url);
      const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
      const query = Object.assign(parsedQueryFromUrl, input.query);
      let queryString = exports.stringify(query, options);
      if (queryString) {
        queryString = `?${queryString}`;
      }
      let hash = getHash(input.url);
      if (input.fragmentIdentifier) {
        hash = `#${encode(input.fragmentIdentifier, options)}`;
      }
      return `${url}${queryString}${hash}`;
    };
  }
});

// node_modules/@thirdweb-dev/wallets/dist/smart-wallet-e0f242d2.browser.esm.js
init_shim();

// node_modules/@thirdweb-dev/wallets/dist/base-4357a120.browser.esm.js
init_shim();

// node_modules/@thirdweb-dev/wallets/evm/wallets/abstract/dist/thirdweb-dev-wallets-evm-wallets-abstract.browser.esm.js
init_shim();
init_lib3();
function chainIdToThirdwebRpc(chainId) {
  return `https://${chainId}.rpc.thirdweb.com`;
}
var EIP1271_ABI = ["function isValidSignature(bytes32 _message, bytes _signature) public view returns (bytes4)"];
var EIP1271_MAGICVALUE = "0x1626ba7e";
async function checkContractWalletSignature(message, signature, address, chainId) {
  const provider = new lib_exports.JsonRpcProvider(chainIdToThirdwebRpc(chainId));
  const walletContract = new Contract(address, EIP1271_ABI, provider);
  const _hashMessage = utils_exports.hashMessage(message);
  try {
    const res = await walletContract.isValidSignature(_hashMessage, signature);
    return res === EIP1271_MAGICVALUE;
  } catch {
    return false;
  }
}
var AbstractWallet = class extends eventemitter3_default {
  constructor() {
    super(...arguments);
    _defineProperty(this, "type", "evm");
  }
  async getAddress() {
    const signer = await this.getSigner();
    return signer.getAddress();
  }
  async getChainId() {
    const signer = await this.getSigner();
    return signer.getChainId();
  }
  async signMessage(message) {
    const signer = await this.getSigner();
    return await signer.signMessage(message);
  }
  async verifySignature(message, signature, address, chainId) {
    try {
      const messageHash = utils_exports.hashMessage(message);
      const messageHashBytes = utils_exports.arrayify(messageHash);
      const recoveredAddress = utils_exports.recoverAddress(messageHashBytes, signature);
      if (recoveredAddress === address) {
        return true;
      }
    } catch {
    }
    if (chainId !== void 0) {
      try {
        const isValid = await checkContractWalletSignature(message, signature, address, chainId || 1);
        return isValid;
      } catch {
      }
    }
    return false;
  }
};

// node_modules/@thirdweb-dev/wallets/dist/base-4357a120.browser.esm.js
var PREFIX = "__TW__";
var AsyncLocalStorage = class {
  constructor(name) {
    _defineProperty(this, "name", void 0);
    this.name = name;
  }
  getItem(key) {
    return new Promise((res) => {
      res(localStorage.getItem(`${PREFIX}/${this.name}/${key}`));
    });
  }
  setItem(key, value) {
    return new Promise((res, rej) => {
      try {
        localStorage.setItem(`${PREFIX}/${this.name}/${key}`, value);
        res();
      } catch (e) {
        rej(e);
      }
    });
  }
  removeItem(key) {
    return new Promise((res) => {
      localStorage.removeItem(`${PREFIX}/${this.name}/${key}`);
      res();
    });
  }
};
function createAsyncLocalStorage(name) {
  return new AsyncLocalStorage(name);
}
var DEFAULT_DAPP_META = {
  name: "thirdweb powered dApp",
  url: "https://thirdweb.com",
  description: "thirdweb powered dApp",
  logoUrl: "https://thirdweb.com/favicon.ico",
  isDarkMode: true
};
var _connectParams = /* @__PURE__ */ new WeakMap();
var _connect = /* @__PURE__ */ new WeakSet();
var _subscribeToEvents = /* @__PURE__ */ new WeakSet();
var AbstractClientWallet = class extends AbstractWallet {
  getMeta() {
    return this.constructor.meta;
  }
  constructor(walletId, options) {
    super();
    _classPrivateMethodInitSpec(this, _subscribeToEvents);
    _classPrivateMethodInitSpec(this, _connect);
    _defineProperty(this, "walletId", void 0);
    _defineProperty(this, "walletStorage", void 0);
    _defineProperty(this, "chains", void 0);
    _defineProperty(this, "dappMetadata", void 0);
    _defineProperty(this, "options", void 0);
    _classPrivateFieldInitSpec(this, _connectParams, {
      writable: true,
      value: void 0
    });
    this.walletId = walletId;
    this.options = options;
    this.chains = (options == null ? void 0 : options.chains) || defaultChains;
    this.dappMetadata = (options == null ? void 0 : options.dappMetadata) || DEFAULT_DAPP_META;
    this.walletStorage = (options == null ? void 0 : options.walletStorage) || createAsyncLocalStorage(this.walletId);
  }
  async autoConnect(connectOptions) {
    const options = connectOptions ? {
      ...connectOptions,
      chainId: void 0
    } : void 0;
    return _classPrivateMethodGet(this, _connect, _connect2).call(this, true, options);
  }
  async connect(connectOptions) {
    _classPrivateFieldSet(this, _connectParams, connectOptions);
    const address = await _classPrivateMethodGet(this, _connect, _connect2).call(this, false, connectOptions);
    if (!address) {
      throw new Error("Failed to connect to the wallet.");
    }
    return address;
  }
  getConnectParams() {
    return _classPrivateFieldGet(this, _connectParams);
  }
  async getSigner() {
    const connector = await this.getConnector();
    if (!connector) {
      throw new Error("Wallet not connected");
    }
    return await connector.getSigner();
  }
  async disconnect() {
    const connector = await this.getConnector();
    if (connector) {
      await connector.disconnect();
      this.emit("disconnect");
      connector.removeAllListeners();
    }
  }
  async switchChain(chainId) {
    const connector = await this.getConnector();
    if (!connector) {
      throw new Error("Wallet not connected");
    }
    if (!connector.switchChain) {
      throw new Error("Wallet does not support switching chains");
    }
    return await connector.switchChain(chainId);
  }
  async updateChains(chains) {
    this.chains = chains;
    const connector = await this.getConnector();
    connector.updateChains(chains);
  }
  getPersonalWallet() {
    return void 0;
  }
};
async function _connect2(isAutoConnect, connectOptions) {
  const connector = await this.getConnector();
  _classPrivateMethodGet(this, _subscribeToEvents, _subscribeToEvents2).call(this, connector);
  const isConnected = await connector.isConnected();
  if (isConnected) {
    const address2 = await connector.getAddress();
    connector.setupListeners();
    if (connectOptions == null ? void 0 : connectOptions.chainId) {
      await connector.switchChain(connectOptions == null ? void 0 : connectOptions.chainId);
    }
    this.emit("connect", {
      address: address2,
      chainId: await this.getChainId()
    });
    return address2;
  }
  if (isAutoConnect) {
    throw new Error("Failed to auto connect to the wallet.");
  }
  const address = await connector.connect(connectOptions);
  return address;
}
async function _subscribeToEvents2(connector) {
  connector.on("connect", (data) => {
    var _a;
    this.emit("connect", {
      address: data.account,
      chainId: (_a = data.chain) == null ? void 0 : _a.id
    });
  });
  connector.on("change", (data) => {
    var _a;
    this.emit("change", {
      address: data.account,
      chainId: (_a = data.chain) == null ? void 0 : _a.id
    });
  });
  connector.on("message", (data) => {
    this.emit("message", data);
  });
  connector.on("disconnect", async () => {
    this.emit("disconnect");
  });
  connector.on("error", (error) => this.emit("error", error));
}
_defineProperty(AbstractClientWallet, "meta", void 0);

// node_modules/@walletconnect/core/dist/index.es.js
init_shim();
var import_events4 = __toESM(require_events());
var import_keyvaluestorage = __toESM(require_browser());
var import_heartbeat = __toESM(require_cjs5());
var import_logger = __toESM(require_cjs2());

// node_modules/@walletconnect/types/dist/index.es.js
init_shim();
init_esm();
var import_events2 = __toESM(require_events());
var n = class extends IEvents {
  constructor(s) {
    super(), this.opts = s, this.protocol = "wc", this.version = 2;
  }
};
var h = class extends IEvents {
  constructor(s, t) {
    super(), this.core = s, this.logger = t, this.records = /* @__PURE__ */ new Map();
  }
};
var a = class {
  constructor(s, t) {
    this.logger = s, this.core = t;
  }
};
var u = class extends IEvents {
  constructor(s, t) {
    super(), this.relayer = s, this.logger = t;
  }
};
var g = class extends IEvents {
  constructor(s) {
    super();
  }
};
var p = class {
  constructor(s, t, o2, w5) {
    this.core = s, this.logger = t, this.name = o2;
  }
};
var d = class extends IEvents {
  constructor(s, t) {
    super(), this.relayer = s, this.logger = t;
  }
};
var E = class extends IEvents {
  constructor(s, t) {
    super(), this.core = s, this.logger = t;
  }
};
var y = class {
  constructor(s, t) {
    this.projectId = s, this.logger = t;
  }
};

// node_modules/@walletconnect/core/dist/index.es.js
init_esm2();

// node_modules/@walletconnect/utils/dist/index.es.js
init_shim();
var import_chacha20poly1305 = __toESM(require_chacha20poly1305());
var import_hkdf = __toESM(require_hkdf());
var import_random = __toESM(require_random());
var import_sha256 = __toESM(require_sha256());
var ue = __toESM(require_x25519());
init_es();
var import_time = __toESM(require_cjs());
var import_window_getters = __toESM(require_cjs3());
var import_window_metadata = __toESM(require_cjs4());
var $ = __toESM(require_query_string());
var G = "base10";
var f = "base16";
var K = "base64pad";
var k = "utf8";
var Y = 0;
var U = 1;
var Tn = 0;
var Oe = 1;
var W = 12;
var J = 32;
function Rn() {
  const e = ue.generateKeyPair();
  return { privateKey: toString(e.secretKey, f), publicKey: toString(e.publicKey, f) };
}
function An() {
  const e = (0, import_random.randomBytes)(J);
  return toString(e, f);
}
function Un(e, n3) {
  const t = ue.sharedKey(fromString(e, f), fromString(n3, f)), r = new import_hkdf.HKDF(import_sha256.SHA256, t).expand(J);
  return toString(r, f);
}
function _n(e) {
  const n3 = (0, import_sha256.hash)(fromString(e, f));
  return toString(n3, f);
}
function wn(e) {
  const n3 = (0, import_sha256.hash)(fromString(e, k));
  return toString(n3, f);
}
function Se(e) {
  return fromString(`${e}`, G);
}
function j(e) {
  return Number(toString(e, G));
}
function jn(e) {
  const n3 = Se(typeof e.type < "u" ? e.type : Y);
  if (j(n3) === U && typeof e.senderPublicKey > "u")
    throw new Error("Missing sender public key for type 1 envelope");
  const t = typeof e.senderPublicKey < "u" ? fromString(e.senderPublicKey, f) : void 0, r = typeof e.iv < "u" ? fromString(e.iv, f) : (0, import_random.randomBytes)(W), o2 = new import_chacha20poly1305.ChaCha20Poly1305(fromString(e.symKey, f)).seal(r, fromString(e.message, k));
  return Ie({ type: n3, sealed: o2, iv: r, senderPublicKey: t });
}
function Cn(e) {
  const n3 = new import_chacha20poly1305.ChaCha20Poly1305(fromString(e.symKey, f)), { sealed: t, iv: r } = Q(e.encoded), o2 = n3.open(r, t);
  if (o2 === null)
    throw new Error("Failed to decrypt");
  return toString(o2, k);
}
function Ie(e) {
  if (j(e.type) === U) {
    if (typeof e.senderPublicKey > "u")
      throw new Error("Missing sender public key for type 1 envelope");
    return toString(concat([e.type, e.senderPublicKey, e.iv, e.sealed]), K);
  }
  return toString(concat([e.type, e.iv, e.sealed]), K);
}
function Q(e) {
  const n3 = fromString(e, K), t = n3.slice(Tn, Oe), r = Oe;
  if (j(t) === U) {
    const d5 = r + J, l2 = d5 + W, i3 = n3.slice(r, d5), u5 = n3.slice(d5, l2), a3 = n3.slice(l2);
    return { type: t, sealed: a3, iv: u5, senderPublicKey: i3 };
  }
  const o2 = r + W, s = n3.slice(r, o2), c3 = n3.slice(o2);
  return { type: t, sealed: c3, iv: s };
}
function $n(e, n3) {
  const t = Q(e);
  return Pe({ type: j(t.type), senderPublicKey: typeof t.senderPublicKey < "u" ? toString(t.senderPublicKey, f) : void 0, receiverPublicKey: n3 == null ? void 0 : n3.receiverPublicKey });
}
function Pe(e) {
  const n3 = (e == null ? void 0 : e.type) || Y;
  if (n3 === U) {
    if (typeof (e == null ? void 0 : e.senderPublicKey) > "u")
      throw new Error("missing sender public key");
    if (typeof (e == null ? void 0 : e.receiverPublicKey) > "u")
      throw new Error("missing receiver public key");
  }
  return { type: n3, senderPublicKey: e == null ? void 0 : e.senderPublicKey, receiverPublicKey: e == null ? void 0 : e.receiverPublicKey };
}
function Dn(e) {
  return e.type === U && typeof e.senderPublicKey == "string" && typeof e.receiverPublicKey == "string";
}
var Vn = Object.defineProperty;
var Te = Object.getOwnPropertySymbols;
var Mn = Object.prototype.hasOwnProperty;
var Kn = Object.prototype.propertyIsEnumerable;
var Re = (e, n3, t) => n3 in e ? Vn(e, n3, { enumerable: true, configurable: true, writable: true, value: t }) : e[n3] = t;
var Ae = (e, n3) => {
  for (var t in n3 || (n3 = {}))
    Mn.call(n3, t) && Re(e, t, n3[t]);
  if (Te)
    for (var t of Te(n3))
      Kn.call(n3, t) && Re(e, t, n3[t]);
  return e;
};
var Ue = "ReactNative";
var _ = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" };
var we = "js";
function X() {
  return typeof import_process.default < "u" && typeof import_process.default.versions < "u" && typeof import_process.default.versions.node < "u";
}
function je() {
  return !(0, import_window_getters.getDocument)() && !!(0, import_window_getters.getNavigator)() && navigator.product === Ue;
}
function Ce() {
  return !X() && !!(0, import_window_getters.getNavigator)();
}
function ee() {
  return je() ? _.reactNative : X() ? _.node : Ce() ? _.browser : _.unknown;
}
function $e(e, n3) {
  let t = $.parse(e);
  return t = Ae(Ae({}, t), n3), e = $.stringify(t), e;
}
function De() {
  const e = detect();
  if (e === null)
    return "unknown";
  const n3 = e.os ? e.os.replace(" ", "").toLowerCase() : "unknown";
  return e.type === "browser" ? [n3, e.name, e.version].join("-") : [n3, e.version].join("-");
}
function Ve() {
  var e;
  const n3 = ee();
  return n3 === _.browser ? [n3, ((e = (0, import_window_getters.getLocation)()) == null ? void 0 : e.host) || "unknown"].join(":") : n3;
}
function Me(e, n3, t) {
  const r = De(), o2 = Ve();
  return [[e, n3].join("-"), [we, t].join("-"), r, o2].join("/");
}
function Hn({ protocol: e, version: n3, relayUrl: t, sdkVersion: r, auth: o2, projectId: s, useOnCloseEvent: c3 }) {
  const d5 = t.split("?"), l2 = Me(e, n3, r), i3 = { auth: o2, ua: l2, projectId: s, useOnCloseEvent: c3 || void 0 }, u5 = $e(d5[1] || "", i3);
  return d5[0] + "?" + u5;
}
function Gn(e) {
  return Object.fromEntries(e.entries());
}
function Yn(e) {
  return new Map(Object.entries(e));
}
function Zn(e = import_time.FIVE_MINUTES, n3) {
  const t = (0, import_time.toMiliseconds)(e || import_time.FIVE_MINUTES);
  let r, o2, s;
  return { resolve: (c3) => {
    s && r && (clearTimeout(s), r(c3));
  }, reject: (c3) => {
    s && o2 && (clearTimeout(s), o2(c3));
  }, done: () => new Promise((c3, d5) => {
    s = setTimeout(() => {
      d5(new Error(n3));
    }, t), r = c3, o2 = d5;
  }) };
}
function Xn(e, n3, t) {
  return new Promise(async (r, o2) => {
    const s = setTimeout(() => o2(new Error(t)), n3);
    try {
      const c3 = await e;
      r(c3);
    } catch (c3) {
      o2(c3);
    }
    clearTimeout(s);
  });
}
function ne(e, n3) {
  if (typeof n3 == "string" && n3.startsWith(`${e}:`))
    return n3;
  if (e.toLowerCase() === "topic") {
    if (typeof n3 != "string")
      throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${n3}`;
  } else if (e.toLowerCase() === "id") {
    if (typeof n3 != "number")
      throw new Error('Value must be "number" for expirer target type: id');
    return `id:${n3}`;
  }
  throw new Error(`Unknown expirer target type: ${e}`);
}
function et(e) {
  return ne("topic", e);
}
function nt(e) {
  return ne("id", e);
}
function tt(e) {
  const [n3, t] = e.split(":"), r = { id: void 0, topic: void 0 };
  if (n3 === "topic" && typeof t == "string")
    r.topic = t;
  else if (n3 === "id" && Number.isInteger(Number(t)))
    r.id = Number(t);
  else
    throw new Error(`Invalid target, expected id:number or topic:string, got ${n3}:${t}`);
  return r;
}
function rt(e, n3) {
  return (0, import_time.fromMiliseconds)((n3 || Date.now()) + (0, import_time.toMiliseconds)(e));
}
function ot(e) {
  return Date.now() >= (0, import_time.toMiliseconds)(e);
}
function st(e, n3) {
  return `${e}${n3 ? `:${n3}` : ""}`;
}
var xe = "irn";
function it(e) {
  return (e == null ? void 0 : e.relay) || { protocol: xe };
}
function ct(e) {
  const n3 = RELAY_JSONRPC[e];
  if (typeof n3 > "u")
    throw new Error(`Relay Protocol not supported: ${e}`);
  return n3;
}
var at = Object.defineProperty;
var Fe = Object.getOwnPropertySymbols;
var ut = Object.prototype.hasOwnProperty;
var dt = Object.prototype.propertyIsEnumerable;
var He = (e, n3, t) => n3 in e ? at(e, n3, { enumerable: true, configurable: true, writable: true, value: t }) : e[n3] = t;
var lt = (e, n3) => {
  for (var t in n3 || (n3 = {}))
    ut.call(n3, t) && He(e, t, n3[t]);
  if (Fe)
    for (var t of Fe(n3))
      dt.call(n3, t) && He(e, t, n3[t]);
  return e;
};
function qe(e, n3 = "-") {
  const t = {}, r = "relay" + n3;
  return Object.keys(e).forEach((o2) => {
    if (o2.startsWith(r)) {
      const s = o2.replace(r, ""), c3 = e[o2];
      t[s] = c3;
    }
  }), t;
}
function ft(e) {
  const n3 = e.indexOf(":"), t = e.indexOf("?") !== -1 ? e.indexOf("?") : void 0, r = e.substring(0, n3), o2 = e.substring(n3 + 1, t).split("@"), s = typeof t < "u" ? e.substring(t) : "", c3 = $.parse(s);
  return { protocol: r, topic: o2[0], version: parseInt(o2[1], 10), symKey: c3.symKey, relay: qe(c3) };
}
function ze(e, n3 = "-") {
  const t = "relay", r = {};
  return Object.keys(e).forEach((o2) => {
    const s = t + n3 + o2;
    e[o2] && (r[s] = e[o2]);
  }), r;
}
function pt(e) {
  return `${e.protocol}:${e.topic}@${e.version}?` + $.stringify(lt({ symKey: e.symKey }, ze(e.relay)));
}
var St = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
var It = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function N(e, n3) {
  const { message: t, code: r } = It[e];
  return { message: n3 ? `${t} ${n3}` : t, code: r };
}
function R(e, n3) {
  const { message: t, code: r } = St[e];
  return { message: n3 ? `${t} ${n3}` : t, code: r };
}
function C(e, n3) {
  return Array.isArray(e) ? typeof n3 < "u" && e.length ? e.every(n3) : true : false;
}
function S(e) {
  return typeof e > "u";
}
function m(e, n3) {
  return n3 && S(e) ? true : typeof e == "string" && Boolean(e.trim().length);
}
function F(e, n3) {
  return n3 && S(e) ? true : typeof e == "number" && !isNaN(e);
}
function Tt(e) {
  if (m(e, false))
    try {
      return typeof new URL(e) < "u";
    } catch {
      return false;
    }
  return false;
}
function Rt(e) {
  var n3;
  return (n3 = e == null ? void 0 : e.proposer) == null ? void 0 : n3.publicKey;
}
function At(e) {
  return e == null ? void 0 : e.topic;
}
function Ct(e) {
  return typeof e < "u" && typeof e !== null;
}
function Ht(e, n3) {
  return F(e, false) && e <= n3.max && e >= n3.min;
}

// node_modules/@walletconnect/core/dist/index.es.js
var import_time2 = __toESM(require_cjs());
init_esm3();

// node_modules/@walletconnect/jsonrpc-ws-connection/dist/esm/index.js
init_shim();

// node_modules/@walletconnect/jsonrpc-ws-connection/dist/esm/ws.js
init_shim();
var import_events3 = __toESM(require_events());
init_esm2();
init_esm3();
var EVENT_EMITTER_MAX_LISTENERS_DEFAULT = 10;
var resolveWebSocketImplementation = () => {
  if (typeof global !== "undefined" && typeof global.WebSocket !== "undefined") {
    return global.WebSocket;
  }
  if (typeof window !== "undefined" && typeof window.WebSocket !== "undefined") {
    return window.WebSocket;
  }
  return require_browser2();
};
var isBrowser = () => typeof window !== "undefined";
var WS = resolveWebSocketImplementation();
var WsConnection = class {
  constructor(url) {
    this.url = url;
    this.events = new import_events3.EventEmitter();
    this.registering = false;
    if (!isWsUrl(url)) {
      throw new Error(`Provided URL is not compatible with WebSocket connection: ${url}`);
    }
    this.url = url;
  }
  get connected() {
    return typeof this.socket !== "undefined";
  }
  get connecting() {
    return this.registering;
  }
  on(event, listener) {
    this.events.on(event, listener);
  }
  once(event, listener) {
    this.events.once(event, listener);
  }
  off(event, listener) {
    this.events.off(event, listener);
  }
  removeListener(event, listener) {
    this.events.removeListener(event, listener);
  }
  async open(url = this.url) {
    await this.register(url);
  }
  async close() {
    return new Promise((resolve, reject) => {
      if (typeof this.socket === "undefined") {
        reject(new Error("Connection already closed"));
        return;
      }
      this.socket.onclose = (event) => {
        this.onClose(event);
        resolve();
      };
      this.socket.close();
    });
  }
  async send(payload, context) {
    if (typeof this.socket === "undefined") {
      this.socket = await this.register();
    }
    try {
      this.socket.send(safeJsonStringify(payload));
    } catch (e) {
      this.onError(payload.id, e);
    }
  }
  register(url = this.url) {
    if (!isWsUrl(url)) {
      throw new Error(`Provided URL is not compatible with WebSocket connection: ${url}`);
    }
    if (this.registering) {
      const currentMaxListeners = this.events.getMaxListeners();
      if (this.events.listenerCount("register_error") >= currentMaxListeners || this.events.listenerCount("open") >= currentMaxListeners) {
        this.events.setMaxListeners(currentMaxListeners + 1);
      }
      return new Promise((resolve, reject) => {
        this.events.once("register_error", (error) => {
          this.resetMaxListeners();
          reject(error);
        });
        this.events.once("open", () => {
          this.resetMaxListeners();
          if (typeof this.socket === "undefined") {
            return reject(new Error("WebSocket connection is missing or invalid"));
          }
          resolve(this.socket);
        });
      });
    }
    this.url = url;
    this.registering = true;
    return new Promise((resolve, reject) => {
      const opts = !(0, esm_exports2.isReactNative)() ? { rejectUnauthorized: !isLocalhostUrl(url) } : void 0;
      const socket = new WS(url, [], opts);
      if (isBrowser()) {
        socket.onerror = (event) => {
          const errorEvent = event;
          reject(this.emitError(errorEvent.error));
        };
      } else {
        socket.on("error", (errorEvent) => {
          reject(this.emitError(errorEvent));
        });
      }
      socket.onopen = () => {
        this.onOpen(socket);
        resolve(socket);
      };
    });
  }
  onOpen(socket) {
    socket.onmessage = (event) => this.onPayload(event);
    socket.onclose = (event) => this.onClose(event);
    this.socket = socket;
    this.registering = false;
    this.events.emit("open");
  }
  onClose(event) {
    this.socket = void 0;
    this.registering = false;
    this.events.emit("close", event);
  }
  onPayload(e) {
    if (typeof e.data === "undefined")
      return;
    const payload = typeof e.data === "string" ? safeJsonParse(e.data) : e.data;
    this.events.emit("payload", payload);
  }
  onError(id, e) {
    const error = this.parseError(e);
    const message = error.message || error.toString();
    const payload = formatJsonRpcError(id, message);
    this.events.emit("payload", payload);
  }
  parseError(e, url = this.url) {
    return parseConnectionError(e, url, "WS");
  }
  resetMaxListeners() {
    if (this.events.getMaxListeners() > EVENT_EMITTER_MAX_LISTENERS_DEFAULT) {
      this.events.setMaxListeners(EVENT_EMITTER_MAX_LISTENERS_DEFAULT);
    }
  }
  emitError(errorEvent) {
    const error = this.parseError(new Error((errorEvent === null || errorEvent === void 0 ? void 0 : errorEvent.message) || `WebSocket connection failed for URL: ${this.url}`));
    this.events.emit("register_error", error);
    return error;
  }
};
var ws_default = WsConnection;

// node_modules/@walletconnect/jsonrpc-ws-connection/dist/esm/index.js
var esm_default = ws_default;

// node_modules/@walletconnect/core/dist/index.es.js
var import_lodash = __toESM(require_lodash());
function Ai(r, e) {
  if (r.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), i3 = 0; i3 < t.length; i3++)
    t[i3] = 255;
  for (var s = 0; s < r.length; s++) {
    var n3 = r.charAt(s), a3 = n3.charCodeAt(0);
    if (t[a3] !== 255)
      throw new TypeError(n3 + " is ambiguous");
    t[a3] = s;
  }
  var o2 = r.length, h3 = r.charAt(0), d5 = Math.log(o2) / Math.log(256), l2 = Math.log(256) / Math.log(o2);
  function g5(u5) {
    if (u5 instanceof Uint8Array || (ArrayBuffer.isView(u5) ? u5 = new Uint8Array(u5.buffer, u5.byteOffset, u5.byteLength) : Array.isArray(u5) && (u5 = Uint8Array.from(u5))), !(u5 instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (u5.length === 0)
      return "";
    for (var y4 = 0, O6 = 0, w5 = 0, _4 = u5.length; w5 !== _4 && u5[w5] === 0; )
      w5++, y4++;
    for (var R5 = (_4 - w5) * l2 + 1 >>> 0, b5 = new Uint8Array(R5); w5 !== _4; ) {
      for (var S5 = u5[w5], x4 = 0, v = R5 - 1; (S5 !== 0 || x4 < O6) && v !== -1; v--, x4++)
        S5 += 256 * b5[v] >>> 0, b5[v] = S5 % o2 >>> 0, S5 = S5 / o2 >>> 0;
      if (S5 !== 0)
        throw new Error("Non-zero carry");
      O6 = x4, w5++;
    }
    for (var T3 = R5 - O6; T3 !== R5 && b5[T3] === 0; )
      T3++;
    for (var K4 = h3.repeat(y4); T3 < R5; ++T3)
      K4 += r.charAt(b5[T3]);
    return K4;
  }
  function L4(u5) {
    if (typeof u5 != "string")
      throw new TypeError("Expected String");
    if (u5.length === 0)
      return new Uint8Array();
    var y4 = 0;
    if (u5[y4] !== " ") {
      for (var O6 = 0, w5 = 0; u5[y4] === h3; )
        O6++, y4++;
      for (var _4 = (u5.length - y4) * d5 + 1 >>> 0, R5 = new Uint8Array(_4); u5[y4]; ) {
        var b5 = t[u5.charCodeAt(y4)];
        if (b5 === 255)
          return;
        for (var S5 = 0, x4 = _4 - 1; (b5 !== 0 || S5 < w5) && x4 !== -1; x4--, S5++)
          b5 += o2 * R5[x4] >>> 0, R5[x4] = b5 % 256 >>> 0, b5 = b5 / 256 >>> 0;
        if (b5 !== 0)
          throw new Error("Non-zero carry");
        w5 = S5, y4++;
      }
      if (u5[y4] !== " ") {
        for (var v = _4 - w5; v !== _4 && R5[v] === 0; )
          v++;
        for (var T3 = new Uint8Array(O6 + (_4 - v)), K4 = O6; v !== _4; )
          T3[K4++] = R5[v++];
        return T3;
      }
    }
  }
  function X5(u5) {
    var y4 = L4(u5);
    if (y4)
      return y4;
    throw new Error(`Non-${e} character`);
  }
  return { encode: g5, decodeUnsafe: L4, decode: X5 };
}
var zi = Ai;
var Ni = zi;
var Te2 = (r) => {
  if (r instanceof Uint8Array && r.constructor.name === "Uint8Array")
    return r;
  if (r instanceof ArrayBuffer)
    return new Uint8Array(r);
  if (ArrayBuffer.isView(r))
    return new Uint8Array(r.buffer, r.byteOffset, r.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var Ui = (r) => new TextEncoder().encode(r);
var Li = (r) => new TextDecoder().decode(r);
var Fi = class {
  constructor(e, t, i3) {
    this.name = e, this.prefix = t, this.baseEncode = i3;
  }
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var $i = class {
  constructor(e, t, i3) {
    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = i3;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e) {
    return Pe2(this, e);
  }
};
var Mi = class {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return Pe2(this, e);
  }
  decode(e) {
    const t = e[0], i3 = this.decoders[t];
    if (i3)
      return i3.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var Pe2 = (r, e) => new Mi({ ...r.decoders || { [r.prefix]: r }, ...e.decoders || { [e.prefix]: e } });
var Ki = class {
  constructor(e, t, i3, s) {
    this.name = e, this.prefix = t, this.baseEncode = i3, this.baseDecode = s, this.encoder = new Fi(e, t, i3), this.decoder = new $i(e, t, s);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
};
var G2 = ({ name: r, prefix: e, encode: t, decode: i3 }) => new Ki(r, e, t, i3);
var $2 = ({ prefix: r, name: e, alphabet: t }) => {
  const { encode: i3, decode: s } = Ni(t, e);
  return G2({ prefix: r, name: e, encode: i3, decode: (n3) => Te2(s(n3)) });
};
var Bi = (r, e, t, i3) => {
  const s = {};
  for (let l2 = 0; l2 < e.length; ++l2)
    s[e[l2]] = l2;
  let n3 = r.length;
  for (; r[n3 - 1] === "="; )
    --n3;
  const a3 = new Uint8Array(n3 * t / 8 | 0);
  let o2 = 0, h3 = 0, d5 = 0;
  for (let l2 = 0; l2 < n3; ++l2) {
    const g5 = s[r[l2]];
    if (g5 === void 0)
      throw new SyntaxError(`Non-${i3} character`);
    h3 = h3 << t | g5, o2 += t, o2 >= 8 && (o2 -= 8, a3[d5++] = 255 & h3 >> o2);
  }
  if (o2 >= t || 255 & h3 << 8 - o2)
    throw new SyntaxError("Unexpected end of data");
  return a3;
};
var ki = (r, e, t) => {
  const i3 = e[e.length - 1] === "=", s = (1 << t) - 1;
  let n3 = "", a3 = 0, o2 = 0;
  for (let h3 = 0; h3 < r.length; ++h3)
    for (o2 = o2 << 8 | r[h3], a3 += 8; a3 > t; )
      a3 -= t, n3 += e[s & o2 >> a3];
  if (a3 && (n3 += e[s & o2 << t - a3]), i3)
    for (; n3.length * t & 7; )
      n3 += "=";
  return n3;
};
var p2 = ({ name: r, prefix: e, bitsPerChar: t, alphabet: i3 }) => G2({ prefix: e, name: r, encode(s) {
  return ki(s, i3, t);
}, decode(s) {
  return Bi(s, i3, t, r);
} });
var ji = G2({ prefix: "\0", name: "identity", encode: (r) => Li(r), decode: (r) => Ui(r) });
var Vi = Object.freeze({ __proto__: null, identity: ji });
var qi = p2({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var Gi = Object.freeze({ __proto__: null, base2: qi });
var Yi = p2({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var Ji = Object.freeze({ __proto__: null, base8: Yi });
var Hi = $2({ prefix: "9", name: "base10", alphabet: "0123456789" });
var Xi = Object.freeze({ __proto__: null, base10: Hi });
var Wi = p2({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var Zi = p2({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Qi = Object.freeze({ __proto__: null, base16: Wi, base16upper: Zi });
var es = p2({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var ts = p2({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var is = p2({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var ss = p2({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var rs = p2({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var ns = p2({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var as = p2({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var os = p2({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var hs = p2({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var cs = Object.freeze({ __proto__: null, base32: es, base32upper: ts, base32pad: is, base32padupper: ss, base32hex: rs, base32hexupper: ns, base32hexpad: as, base32hexpadupper: os, base32z: hs });
var us = $2({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var ls = $2({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var ds = Object.freeze({ __proto__: null, base36: us, base36upper: ls });
var gs = $2({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var ps = $2({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var Ds = Object.freeze({ __proto__: null, base58btc: gs, base58flickr: ps });
var ys = p2({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var bs = p2({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var ms = p2({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var fs = p2({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Es = Object.freeze({ __proto__: null, base64: ys, base64pad: bs, base64url: ms, base64urlpad: fs });
var xe2 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var ws = xe2.reduce((r, e, t) => (r[t] = e, r), []);
var vs = xe2.reduce((r, e, t) => (r[e.codePointAt(0)] = t, r), []);
function Is(r) {
  return r.reduce((e, t) => (e += ws[t], e), "");
}
function Cs(r) {
  const e = [];
  for (const t of r) {
    const i3 = vs[t.codePointAt(0)];
    if (i3 === void 0)
      throw new Error(`Non-base256emoji character: ${t}`);
    e.push(i3);
  }
  return new Uint8Array(e);
}
var _s = G2({ prefix: "\u{1F680}", name: "base256emoji", encode: Is, decode: Cs });
var Rs = Object.freeze({ __proto__: null, base256emoji: _s });
var Ss = Ae2;
var Oe2 = 128;
var Ts = 127;
var Ps = ~Ts;
var xs = Math.pow(2, 31);
function Ae2(r, e, t) {
  e = e || [], t = t || 0;
  for (var i3 = t; r >= xs; )
    e[t++] = r & 255 | Oe2, r /= 128;
  for (; r & Ps; )
    e[t++] = r & 255 | Oe2, r >>>= 7;
  return e[t] = r | 0, Ae2.bytes = t - i3 + 1, e;
}
var Os = ne2;
var As = 128;
var ze2 = 127;
function ne2(r, i3) {
  var t = 0, i3 = i3 || 0, s = 0, n3 = i3, a3, o2 = r.length;
  do {
    if (n3 >= o2)
      throw ne2.bytes = 0, new RangeError("Could not decode varint");
    a3 = r[n3++], t += s < 28 ? (a3 & ze2) << s : (a3 & ze2) * Math.pow(2, s), s += 7;
  } while (a3 >= As);
  return ne2.bytes = n3 - i3, t;
}
var zs = Math.pow(2, 7);
var Ns = Math.pow(2, 14);
var Us = Math.pow(2, 21);
var Ls = Math.pow(2, 28);
var Fs = Math.pow(2, 35);
var $s = Math.pow(2, 42);
var Ms = Math.pow(2, 49);
var Ks = Math.pow(2, 56);
var Bs = Math.pow(2, 63);
var ks = function(r) {
  return r < zs ? 1 : r < Ns ? 2 : r < Us ? 3 : r < Ls ? 4 : r < Fs ? 5 : r < $s ? 6 : r < Ms ? 7 : r < Ks ? 8 : r < Bs ? 9 : 10;
};
var js = { encode: Ss, decode: Os, encodingLength: ks };
var Ne = js;
var Ue2 = (r, e, t = 0) => (Ne.encode(r, e, t), e);
var Le = (r) => Ne.encodingLength(r);
var ae2 = (r, e) => {
  const t = e.byteLength, i3 = Le(r), s = i3 + Le(t), n3 = new Uint8Array(s + t);
  return Ue2(r, n3, 0), Ue2(t, n3, i3), n3.set(e, s), new Vs(r, t, e, n3);
};
var Vs = class {
  constructor(e, t, i3, s) {
    this.code = e, this.size = t, this.digest = i3, this.bytes = s;
  }
};
var Fe2 = ({ name: r, code: e, encode: t }) => new qs(r, e, t);
var qs = class {
  constructor(e, t, i3) {
    this.name = e, this.code = t, this.encode = i3;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const t = this.encode(e);
      return t instanceof Uint8Array ? ae2(this.code, t) : t.then((i3) => ae2(this.code, i3));
    } else
      throw Error("Unknown type, must be binary type");
  }
};
var $e2 = (r) => async (e) => new Uint8Array(await crypto.subtle.digest(r, e));
var Gs = Fe2({ name: "sha2-256", code: 18, encode: $e2("SHA-256") });
var Ys = Fe2({ name: "sha2-512", code: 19, encode: $e2("SHA-512") });
var Js = Object.freeze({ __proto__: null, sha256: Gs, sha512: Ys });
var Me2 = 0;
var Hs = "identity";
var Ke = Te2;
var Xs = (r) => ae2(Me2, Ke(r));
var Ws = { code: Me2, name: Hs, encode: Ke, digest: Xs };
var Zs = Object.freeze({ __proto__: null, identity: Ws });
new TextEncoder(), new TextDecoder();
var Be = { ...Vi, ...Gi, ...Ji, ...Xi, ...Qi, ...cs, ...ds, ...Ds, ...Es, ...Rs };
({ ...Js, ...Zs });
function ke(r) {
  return globalThis.Buffer != null ? new Uint8Array(r.buffer, r.byteOffset, r.byteLength) : r;
}
function Qs(r = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? ke(globalThis.Buffer.allocUnsafe(r)) : new Uint8Array(r);
}
function je2(r, e, t, i3) {
  return { name: r, prefix: e, encoder: { name: r, prefix: e, encode: t }, decoder: { decode: i3 } };
}
var Ve2 = je2("utf8", "u", (r) => "u" + new TextDecoder("utf8").decode(r), (r) => new TextEncoder().encode(r.substring(1)));
var oe = je2("ascii", "a", (r) => {
  let e = "a";
  for (let t = 0; t < r.length; t++)
    e += String.fromCharCode(r[t]);
  return e;
}, (r) => {
  r = r.substring(1);
  const e = Qs(r.length);
  for (let t = 0; t < r.length; t++)
    e[t] = r.charCodeAt(t);
  return e;
});
var er = { utf8: Ve2, "utf-8": Ve2, hex: Be.base16, latin1: oe, ascii: oe, binary: oe, ...Be };
function tr(r, e = "utf8") {
  const t = er[e];
  if (!t)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? ke(globalThis.Buffer.from(r, "utf-8")) : t.decoder.decode(`${t.prefix}${r}`);
}
var he = "wc";
var qe2 = 2;
var Y2 = "core";
var P = `${he}@${2}:${Y2}:`;
var Ge = { name: Y2, logger: "error" };
var Ye = { database: ":memory:" };
var Je = "crypto";
var ce2 = "client_ed25519_seed";
var He2 = import_time2.ONE_DAY;
var Xe = "keychain";
var We = "0.3";
var Ze = "messages";
var Qe = "0.3";
var et2 = import_time2.SIX_HOURS;
var tt2 = "publisher";
var it2 = "irn";
var st2 = "error";
var ue2 = "wss://relay.walletconnect.com";
var rt2 = "relayer";
var D = { message: "relayer_message", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" };
var nt2 = "_subscription";
var N2 = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" };
var at2 = import_time2.ONE_SECOND / 2;
var ot2 = "2.7.3";
var ht = "0.3";
var I = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" };
var ct2 = "subscription";
var ut2 = "0.3";
var lt2 = import_time2.FIVE_SECONDS * 1e3;
var dt2 = "pairing";
var gt = "0.3";
var U2 = { wc_pairingDelete: { req: { ttl: import_time2.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: import_time2.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: import_time2.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: import_time2.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: import_time2.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: import_time2.ONE_DAY, prompt: false, tag: 0 } } };
var C2 = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" };
var pt2 = "history";
var Dt = "0.3";
var yt = "expirer";
var E2 = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" };
var bt = "0.3";
var J2 = "verify-api";
var le2 = "https://verify.walletconnect.com";
var mt = class {
  constructor(e, t) {
    this.core = e, this.logger = t, this.keychain = /* @__PURE__ */ new Map(), this.name = Xe, this.version = We, this.initialized = false, this.storagePrefix = P, this.init = async () => {
      if (!this.initialized) {
        const i3 = await this.getKeyChain();
        typeof i3 < "u" && (this.keychain = i3), this.initialized = true;
      }
    }, this.has = (i3) => (this.isInitialized(), this.keychain.has(i3)), this.set = async (i3, s) => {
      this.isInitialized(), this.keychain.set(i3, s), await this.persist();
    }, this.get = (i3) => {
      this.isInitialized();
      const s = this.keychain.get(i3);
      if (typeof s > "u") {
        const { message: n3 } = N("NO_MATCHING_KEY", `${this.name}: ${i3}`);
        throw new Error(n3);
      }
      return s;
    }, this.del = async (i3) => {
      this.isInitialized(), this.keychain.delete(i3), await this.persist();
    }, this.core = e, this.logger = (0, import_logger.generateChildLogger)(t, this.name);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, Gn(e));
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? Yn(e) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var ft2 = class {
  constructor(e, t, i3) {
    this.core = e, this.logger = t, this.name = Je, this.initialized = false, this.init = async () => {
      this.initialized || (await this.keychain.init(), this.initialized = true);
    }, this.hasKeys = (s) => (this.isInitialized(), this.keychain.has(s)), this.getClientId = async () => {
      this.isInitialized();
      const s = await this.getClientSeed(), n3 = generateKeyPair(s);
      return encodeIss(n3.publicKey);
    }, this.generateKeyPair = () => {
      this.isInitialized();
      const s = Rn();
      return this.setPrivateKey(s.publicKey, s.privateKey);
    }, this.signJWT = async (s) => {
      this.isInitialized();
      const n3 = await this.getClientSeed(), a3 = generateKeyPair(n3), o2 = An(), h3 = He2;
      return await signJWT(o2, s, h3, a3);
    }, this.generateSharedKey = (s, n3, a3) => {
      this.isInitialized();
      const o2 = this.getPrivateKey(s), h3 = Un(o2, n3);
      return this.setSymKey(h3, a3);
    }, this.setSymKey = async (s, n3) => {
      this.isInitialized();
      const a3 = n3 || _n(s);
      return await this.keychain.set(a3, s), a3;
    }, this.deleteKeyPair = async (s) => {
      this.isInitialized(), await this.keychain.del(s);
    }, this.deleteSymKey = async (s) => {
      this.isInitialized(), await this.keychain.del(s);
    }, this.encode = async (s, n3, a3) => {
      this.isInitialized();
      const o2 = Pe(a3), h3 = safeJsonStringify(n3);
      if (Dn(o2)) {
        const L4 = o2.senderPublicKey, X5 = o2.receiverPublicKey;
        s = await this.generateSharedKey(L4, X5);
      }
      const d5 = this.getSymKey(s), { type: l2, senderPublicKey: g5 } = o2;
      return jn({ type: l2, symKey: d5, message: h3, senderPublicKey: g5 });
    }, this.decode = async (s, n3, a3) => {
      this.isInitialized();
      const o2 = $n(n3, a3);
      if (Dn(o2)) {
        const l2 = o2.receiverPublicKey, g5 = o2.senderPublicKey;
        s = await this.generateSharedKey(l2, g5);
      }
      const h3 = this.getSymKey(s), d5 = Cn({ symKey: h3, encoded: n3 });
      return safeJsonParse(d5);
    }, this.getPayloadType = (s) => {
      const n3 = Q(s);
      return j(n3.type);
    }, this.getPayloadSenderPublicKey = (s) => {
      const n3 = Q(s);
      return n3.senderPublicKey ? toString(n3.senderPublicKey, f) : void 0;
    }, this.core = e, this.logger = (0, import_logger.generateChildLogger)(t, this.name), this.keychain = i3 || new mt(this.core, this.logger);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  async setPrivateKey(e, t) {
    return await this.keychain.set(e, t), e;
  }
  getPrivateKey(e) {
    return this.keychain.get(e);
  }
  async getClientSeed() {
    let e = "";
    try {
      e = this.keychain.get(ce2);
    } catch {
      e = An(), await this.keychain.set(ce2, e);
    }
    return tr(e, "base16");
  }
  getSymKey(e) {
    return this.keychain.get(e);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Et = class extends a {
  constructor(e, t) {
    super(e, t), this.logger = e, this.core = t, this.messages = /* @__PURE__ */ new Map(), this.name = Ze, this.version = Qe, this.initialized = false, this.storagePrefix = P, this.init = async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const i3 = await this.getRelayerMessages();
          typeof i3 < "u" && (this.messages = i3), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (i3) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(i3);
        } finally {
          this.initialized = true;
        }
      }
    }, this.set = async (i3, s) => {
      this.isInitialized();
      const n3 = wn(s);
      let a3 = this.messages.get(i3);
      return typeof a3 > "u" && (a3 = {}), typeof a3[n3] < "u" || (a3[n3] = s, this.messages.set(i3, a3), await this.persist()), n3;
    }, this.get = (i3) => {
      this.isInitialized();
      let s = this.messages.get(i3);
      return typeof s > "u" && (s = {}), s;
    }, this.has = (i3, s) => {
      this.isInitialized();
      const n3 = this.get(i3), a3 = wn(s);
      return typeof n3[a3] < "u";
    }, this.del = async (i3) => {
      this.isInitialized(), this.messages.delete(i3), await this.persist();
    }, this.logger = (0, import_logger.generateChildLogger)(e, this.name), this.core = t;
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, Gn(e));
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? Yn(e) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var ar = class extends u {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, this.events = new import_events4.EventEmitter(), this.name = tt2, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = 1e4, this.publish = async (i3, s, n3) => {
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i3, message: s, opts: n3 } });
      try {
        const a3 = (n3 == null ? void 0 : n3.ttl) || et2, o2 = it(n3), h3 = (n3 == null ? void 0 : n3.prompt) || false, d5 = (n3 == null ? void 0 : n3.tag) || 0, l2 = { topic: i3, message: s, opts: { ttl: a3, relay: o2, prompt: h3, tag: d5 } }, g5 = wn(s);
        this.queue.set(g5, l2);
        try {
          await await Xn(this.rpcPublish(i3, s, a3, o2, h3, d5), this.publishTimeout), this.relayer.events.emit(D.publish, l2);
        } catch {
          this.logger.debug("Publishing Payload stalled"), this.relayer.events.emit(D.connection_stalled);
          return;
        }
        this.onPublish(g5, l2), this.logger.debug("Successfully Published Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i3, message: s, opts: n3 } });
      } catch (a3) {
        throw this.logger.debug("Failed to Publish Payload"), this.logger.error(a3), a3;
      }
    }, this.on = (i3, s) => {
      this.events.on(i3, s);
    }, this.once = (i3, s) => {
      this.events.once(i3, s);
    }, this.off = (i3, s) => {
      this.events.off(i3, s);
    }, this.removeListener = (i3, s) => {
      this.events.removeListener(i3, s);
    }, this.relayer = e, this.logger = (0, import_logger.generateChildLogger)(t, this.name), this.registerEventListeners();
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  rpcPublish(e, t, i3, s, n3, a3) {
    var o2, h3, d5, l2;
    const g5 = { method: ct(s.protocol).publish, params: { topic: e, message: t, ttl: i3, prompt: n3, tag: a3 } };
    return S((o2 = g5.params) == null ? void 0 : o2.prompt) && ((h3 = g5.params) == null || delete h3.prompt), S((d5 = g5.params) == null ? void 0 : d5.tag) && ((l2 = g5.params) == null || delete l2.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: g5 }), this.relayer.request(g5);
  }
  onPublish(e, t) {
    this.queue.delete(e);
  }
  checkQueue() {
    this.queue.forEach(async (e) => {
      const { topic: t, message: i3, opts: s } = e;
      await this.publish(t, i3, s);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, () => {
      this.checkQueue();
    });
  }
};
var or = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map(), this.set = (e, t) => {
      const i3 = this.get(e);
      this.exists(e, t) || this.map.set(e, [...i3, t]);
    }, this.get = (e) => this.map.get(e) || [], this.exists = (e, t) => this.get(e).includes(t), this.delete = (e, t) => {
      if (typeof t > "u") {
        this.map.delete(e);
        return;
      }
      if (!this.map.has(e))
        return;
      const i3 = this.get(e);
      if (!this.exists(e, t))
        return;
      const s = i3.filter((n3) => n3 !== t);
      if (!s.length) {
        this.map.delete(e);
        return;
      }
      this.map.set(e, s);
    }, this.clear = () => {
      this.map.clear();
    };
  }
  get topics() {
    return Array.from(this.map.keys());
  }
};
var hr = Object.defineProperty;
var cr = Object.defineProperties;
var ur = Object.getOwnPropertyDescriptors;
var wt = Object.getOwnPropertySymbols;
var lr = Object.prototype.hasOwnProperty;
var dr = Object.prototype.propertyIsEnumerable;
var vt = (r, e, t) => e in r ? hr(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var M = (r, e) => {
  for (var t in e || (e = {}))
    lr.call(e, t) && vt(r, t, e[t]);
  if (wt)
    for (var t of wt(e))
      dr.call(e, t) && vt(r, t, e[t]);
  return r;
};
var de = (r, e) => cr(r, ur(e));
var It2 = class extends d {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new or(), this.events = new import_events4.EventEmitter(), this.name = ct2, this.version = ut2, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = false, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = P, this.subscribeTimeout = 1e4, this.restartInProgress = false, this.batchSubscribeTopicsLimit = 500, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restart(), this.registerEventListeners(), this.onEnable(), this.clientId = await this.relayer.core.crypto.getClientId());
    }, this.subscribe = async (i3, s) => {
      await this.restartToComplete(), this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i3, opts: s } });
      try {
        const n3 = it(s), a3 = { topic: i3, relay: n3 };
        this.pending.set(i3, a3);
        const o2 = await this.rpcSubscribe(i3, n3);
        return this.onSubscribe(o2, a3), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i3, opts: s } }), o2;
      } catch (n3) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(n3), n3;
      }
    }, this.unsubscribe = async (i3, s) => {
      await this.restartToComplete(), this.isInitialized(), typeof (s == null ? void 0 : s.id) < "u" ? await this.unsubscribeById(i3, s.id, s) : await this.unsubscribeByTopic(i3, s);
    }, this.isSubscribed = async (i3) => this.topics.includes(i3) ? true : await new Promise((s, n3) => {
      const a3 = new import_time2.Watch();
      a3.start(this.pendingSubscriptionWatchLabel);
      const o2 = setInterval(() => {
        !this.pending.has(i3) && this.topics.includes(i3) && (clearInterval(o2), a3.stop(this.pendingSubscriptionWatchLabel), s(true)), a3.elapsed(this.pendingSubscriptionWatchLabel) >= lt2 && (clearInterval(o2), a3.stop(this.pendingSubscriptionWatchLabel), n3(false));
      }, this.pollingInterval);
    }), this.on = (i3, s) => {
      this.events.on(i3, s);
    }, this.once = (i3, s) => {
      this.events.once(i3, s);
    }, this.off = (i3, s) => {
      this.events.off(i3, s);
    }, this.removeListener = (i3, s) => {
      this.events.removeListener(i3, s);
    }, this.restart = async () => {
      this.restartInProgress = true, await this.restore(), await this.reset(), this.restartInProgress = false;
    }, this.relayer = e, this.logger = (0, import_logger.generateChildLogger)(t, this.name), this.clientId = "";
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  hasSubscription(e, t) {
    let i3 = false;
    try {
      i3 = this.getSubscription(e).topic === t;
    } catch {
    }
    return i3;
  }
  onEnable() {
    this.cached = [], this.initialized = true;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e, t) {
    const i3 = this.topicMap.get(e);
    await Promise.all(i3.map(async (s) => await this.unsubscribeById(e, s, t)));
  }
  async unsubscribeById(e, t, i3) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: i3 } });
    try {
      const s = it(i3);
      await this.rpcUnsubscribe(e, t, s);
      const n3 = R("USER_DISCONNECTED", `${this.name}, ${e}`);
      await this.onUnsubscribe(e, t, n3), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: i3 } });
    } catch (s) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(s), s;
    }
  }
  async rpcSubscribe(e, t) {
    const i3 = { method: ct(t.protocol).subscribe, params: { topic: e } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i3 });
    try {
      await await Xn(this.relayer.request(i3), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(D.connection_stalled);
    }
    return wn(e + this.clientId);
  }
  async rpcBatchSubscribe(e) {
    if (!e.length)
      return;
    const t = e[0].relay, i3 = { method: ct(t.protocol).batchSubscribe, params: { topics: e.map((s) => s.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i3 });
    try {
      return await await Xn(this.relayer.request(i3), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Payload stalled"), this.relayer.events.emit(D.connection_stalled);
    }
  }
  rpcUnsubscribe(e, t, i3) {
    const s = { method: ct(i3.protocol).unsubscribe, params: { topic: e, id: t } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s }), this.relayer.request(s);
  }
  onSubscribe(e, t) {
    this.setSubscription(e, de(M({}, t), { id: e })), this.pending.delete(t.topic);
  }
  onBatchSubscribe(e) {
    e.length && e.forEach((t) => {
      this.setSubscription(t.id, M({}, t)), this.pending.delete(t.topic);
    });
  }
  async onUnsubscribe(e, t, i3) {
    this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, i3), await this.relayer.messages.del(e);
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e, t) {
    this.subscriptions.has(e) || (this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e, subscription: t }), this.addSubscription(e, t));
  }
  addSubscription(e, t) {
    this.subscriptions.set(e, M({}, t)), this.topicMap.set(t.topic, e), this.events.emit(I.created, t);
  }
  getSubscription(e) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e });
    const t = this.subscriptions.get(e);
    if (!t) {
      const { message: i3 } = N("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(i3);
    }
    return t;
  }
  deleteSubscription(e, t) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e, reason: t });
    const i3 = this.getSubscription(e);
    this.subscriptions.delete(e), this.topicMap.delete(i3.topic, e), this.events.emit(I.deleted, de(M({}, i3), { reason: t }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(I.sync);
  }
  async reset() {
    if (this.cached.length) {
      const e = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let t = 0; t < e; t++) {
        const i3 = this.cached.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(i3);
      }
    }
    this.events.emit(I.resubscribed);
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions();
      if (typeof e > "u" || !e.length)
        return;
      if (this.subscriptions.size) {
        const { message: t } = N("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);
    }
  }
  async batchSubscribe(e) {
    if (!e.length)
      return;
    const t = await this.rpcBatchSubscribe(e);
    C(t) && this.onBatchSubscribe(t.map((i3, s) => de(M({}, e[s]), { id: i3 })));
  }
  async onConnect() {
    this.restartInProgress || (await this.restart(), this.onEnable());
  }
  onDisconnect() {
    this.onDisable();
  }
  async checkPending() {
    if (this.relayer.transportExplicitlyClosed)
      return;
    const e = [];
    this.pending.forEach((t) => {
      e.push(t);
    }), await this.batchSubscribe(e);
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, async () => {
      await this.checkPending();
    }), this.relayer.on(D.connect, async () => {
      await this.onConnect();
    }), this.relayer.on(D.disconnect, () => {
      this.onDisconnect();
    }), this.events.on(I.created, async (e) => {
      const t = I.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), await this.persist();
    }), this.events.on(I.deleted, async (e) => {
      const t = I.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), await this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async restartToComplete() {
    this.restartInProgress && await new Promise((e) => {
      const t = setInterval(() => {
        this.restartInProgress || (clearInterval(t), e());
      }, this.pollingInterval);
    });
  }
};
var gr = Object.defineProperty;
var Ct2 = Object.getOwnPropertySymbols;
var pr = Object.prototype.hasOwnProperty;
var Dr = Object.prototype.propertyIsEnumerable;
var _t = (r, e, t) => e in r ? gr(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var yr = (r, e) => {
  for (var t in e || (e = {}))
    pr.call(e, t) && _t(r, t, e[t]);
  if (Ct2)
    for (var t of Ct2(e))
      Dr.call(e, t) && _t(r, t, e[t]);
  return r;
};
var Rt2 = class extends g {
  constructor(e) {
    super(e), this.protocol = "wc", this.version = 2, this.events = new import_events4.EventEmitter(), this.name = rt2, this.transportExplicitlyClosed = false, this.initialized = false, this.reconnecting = false, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "socket stalled"], this.request = async (t) => {
      this.logger.debug("Publishing Request Payload");
      try {
        return await this.toEstablishConnection(), await this.provider.request(t);
      } catch (i3) {
        throw this.logger.debug("Failed to Publish Request"), this.logger.error(i3), i3;
      }
    }, this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? (0, import_logger.generateChildLogger)(e.logger, this.name) : (0, import_logger.pino)((0, import_logger.getDefaultLoggerOptions)({ level: e.logger || st2 })), this.messages = new Et(this.logger, e.core), this.subscriber = new It2(this, this.logger), this.publisher = new ar(this, this.logger), this.relayUrl = (e == null ? void 0 : e.relayUrl) || ue2, this.projectId = e.projectId, this.provider = {};
  }
  async init() {
    this.logger.trace("Initialized"), await this.createProvider(), await Promise.all([this.messages.init(), this.transportOpen(), this.subscriber.init()]), this.registerEventListeners(), this.initialized = true;
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get connected() {
    return this.provider.connection.connected;
  }
  get connecting() {
    return this.provider.connection.connecting;
  }
  async publish(e, t, i3) {
    this.isInitialized(), await this.publisher.publish(e, t, i3), await this.recordMessageEvent({ topic: e, message: t, publishedAt: Date.now() });
  }
  async subscribe(e, t) {
    this.isInitialized();
    let i3 = "";
    return await Promise.all([new Promise((s) => {
      this.subscriber.once(I.created, (n3) => {
        n3.topic === e && s();
      });
    }), new Promise(async (s) => {
      i3 = await this.subscriber.subscribe(e, t), s();
    })]), i3;
  }
  async unsubscribe(e, t) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, t);
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async transportClose() {
    this.transportExplicitlyClosed = true, this.connected && (await this.provider.disconnect(), this.events.emit(D.transport_closed));
  }
  async transportOpen(e) {
    if (this.transportExplicitlyClosed = false, !this.reconnecting) {
      this.relayUrl = e || this.relayUrl, this.reconnecting = true;
      try {
        await Promise.all([new Promise((t) => {
          this.initialized || t(), this.subscriber.once(I.resubscribed, () => {
            t();
          });
        }), await Promise.race([new Promise(async (t, i3) => {
          await Xn(this.provider.connect(), 5e3, "socket stalled").catch((s) => i3(s)).then(() => t()).finally(() => this.removeListener(D.transport_closed, this.rejectTransportOpen));
        }), new Promise((t) => this.once(D.transport_closed, this.rejectTransportOpen))])]);
      } catch (t) {
        this.logger.error(t);
        const i3 = t;
        if (!this.isConnectionStalled(i3.message))
          throw t;
        this.events.emit(D.transport_closed);
      } finally {
        this.reconnecting = false;
      }
    }
  }
  async restartTransport(e) {
    this.transportExplicitlyClosed || (this.relayUrl = e || this.relayUrl, this.connected && await Promise.all([new Promise((t) => {
      this.provider.once(N2.disconnect, () => {
        t();
      });
    }), this.transportClose()]), await this.createProvider(), await this.transportOpen());
  }
  isConnectionStalled(e) {
    return this.staleConnectionErrors.some((t) => e.includes(t));
  }
  rejectTransportOpen() {
    throw new Error("closeTransport called before connection was established");
  }
  async createProvider() {
    const e = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new JsonRpcProvider(new esm_default(Hn({ sdkVersion: ot2, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: true }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e) {
    const { topic: t, message: i3 } = e;
    await this.messages.set(t, i3);
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: t, message: i3 } = e;
    return await this.subscriber.isSubscribed(t) ? this.messages.has(t, i3) : true;
  }
  async onProviderPayload(e) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e }), isJsonRpcRequest(e)) {
      if (!e.method.endsWith(nt2))
        return;
      const t = e.params, { topic: i3, message: s, publishedAt: n3 } = t.data, a3 = { topic: i3, message: s, publishedAt: n3 };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(yr({ type: "event", event: t.id }, a3)), this.events.emit(t.id, a3), await this.acknowledgePayload(e), await this.onMessageEvent(a3);
    }
  }
  async onMessageEvent(e) {
    await this.shouldIgnoreMessageEvent(e) || (this.events.emit(D.message, e), await this.recordMessageEvent(e));
  }
  async acknowledgePayload(e) {
    const t = formatJsonRpcResult(e.id, true);
    await this.provider.connection.send(t);
  }
  registerProviderListeners() {
    this.provider.on(N2.payload, (e) => this.onProviderPayload(e)), this.provider.on(N2.connect, () => {
      this.events.emit(D.connect);
    }), this.provider.on(N2.disconnect, () => {
      this.onProviderDisconnect();
    }), this.provider.on(N2.error, (e) => {
      this.logger.error(e), this.events.emit(D.error, e);
    });
  }
  registerEventListeners() {
    this.events.on(D.connection_stalled, async () => {
      await this.restartTransport();
    });
  }
  onProviderDisconnect() {
    this.events.emit(D.disconnect), this.attemptToReconnect();
  }
  attemptToReconnect() {
    this.transportExplicitlyClosed || setTimeout(async () => {
      await this.restartTransport();
    }, (0, import_time2.toMiliseconds)(at2));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async toEstablishConnection() {
    if (!this.connected) {
      if (this.connecting)
        return await new Promise((e) => {
          const t = setInterval(() => {
            this.connected && (clearInterval(t), e());
          }, this.connectionStatusPollingInterval);
        });
      await this.restartTransport();
    }
  }
};
var br = Object.defineProperty;
var St2 = Object.getOwnPropertySymbols;
var mr = Object.prototype.hasOwnProperty;
var fr = Object.prototype.propertyIsEnumerable;
var Tt2 = (r, e, t) => e in r ? br(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var Pt = (r, e) => {
  for (var t in e || (e = {}))
    mr.call(e, t) && Tt2(r, t, e[t]);
  if (St2)
    for (var t of St2(e))
      fr.call(e, t) && Tt2(r, t, e[t]);
  return r;
};
var xt = class extends p {
  constructor(e, t, i3, s = P, n3 = void 0) {
    super(e, t, i3, s), this.core = e, this.logger = t, this.name = i3, this.map = /* @__PURE__ */ new Map(), this.version = ht, this.cached = [], this.initialized = false, this.storagePrefix = P, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((a3) => {
        this.getKey && a3 !== null && !S(a3) ? this.map.set(this.getKey(a3), a3) : Rt(a3) ? this.map.set(a3.id, a3) : At(a3) && this.map.set(a3.topic, a3);
      }), this.cached = [], this.initialized = true);
    }, this.set = async (a3, o2) => {
      this.isInitialized(), this.map.has(a3) ? await this.update(a3, o2) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: a3, value: o2 }), this.map.set(a3, o2), await this.persist());
    }, this.get = (a3) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: a3 }), this.getData(a3)), this.getAll = (a3) => (this.isInitialized(), a3 ? this.values.filter((o2) => Object.keys(a3).every((h3) => (0, import_lodash.default)(o2[h3], a3[h3]))) : this.values), this.update = async (a3, o2) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: a3, update: o2 });
      const h3 = Pt(Pt({}, this.getData(a3)), o2);
      this.map.set(a3, h3), await this.persist();
    }, this.delete = async (a3, o2) => {
      this.isInitialized(), this.map.has(a3) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: a3, reason: o2 }), this.map.delete(a3), await this.persist());
    }, this.logger = (0, import_logger.generateChildLogger)(t, this.name), this.storagePrefix = s, this.getKey = n3;
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e) {
    const t = this.map.get(e);
    if (!t) {
      const { message: i3 } = N("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(i3), new Error(i3);
    }
    return t;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e = await this.getDataStore();
      if (typeof e > "u" || !e.length)
        return;
      if (this.map.size) {
        const { message: t } = N("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Ot = class {
  constructor(e, t) {
    this.core = e, this.logger = t, this.name = dt2, this.version = gt, this.events = new import_events4.default(), this.initialized = false, this.storagePrefix = P, this.ignoredPayloadTypes = [U], this.registeredMethods = [], this.init = async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
    }, this.register = ({ methods: i3 }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...i3])];
    }, this.create = async () => {
      this.isInitialized();
      const i3 = An(), s = await this.core.crypto.setSymKey(i3), n3 = rt(import_time2.FIVE_MINUTES), a3 = { protocol: it2 }, o2 = { topic: s, expiry: n3, relay: a3, active: false }, h3 = pt({ protocol: this.core.protocol, version: this.core.version, topic: s, symKey: i3, relay: a3 });
      return await this.pairings.set(s, o2), await this.core.relayer.subscribe(s), this.core.expirer.set(s, n3), { topic: s, uri: h3 };
    }, this.pair = async (i3) => {
      this.isInitialized(), this.isValidPair(i3);
      const { topic: s, symKey: n3, relay: a3 } = ft(i3.uri);
      if (this.pairings.keys.includes(s))
        throw new Error(`Pairing already exists: ${s}`);
      if (this.core.crypto.hasKeys(s))
        throw new Error(`Keychain already exists: ${s}`);
      const o2 = rt(import_time2.FIVE_MINUTES), h3 = { topic: s, relay: a3, expiry: o2, active: false };
      return await this.pairings.set(s, h3), await this.core.crypto.setSymKey(n3, s), await this.core.relayer.subscribe(s, { relay: a3 }), this.core.expirer.set(s, o2), i3.activatePairing && await this.activate({ topic: s }), h3;
    }, this.activate = async ({ topic: i3 }) => {
      this.isInitialized();
      const s = rt(import_time2.THIRTY_DAYS);
      await this.pairings.update(i3, { active: true, expiry: s }), this.core.expirer.set(i3, s);
    }, this.ping = async (i3) => {
      this.isInitialized(), await this.isValidPing(i3);
      const { topic: s } = i3;
      if (this.pairings.keys.includes(s)) {
        const n3 = await this.sendRequest(s, "wc_pairingPing", {}), { done: a3, resolve: o2, reject: h3 } = Zn();
        this.events.once(st("pairing_ping", n3), ({ error: d5 }) => {
          d5 ? h3(d5) : o2();
        }), await a3();
      }
    }, this.updateExpiry = async ({ topic: i3, expiry: s }) => {
      this.isInitialized(), await this.pairings.update(i3, { expiry: s });
    }, this.updateMetadata = async ({ topic: i3, metadata: s }) => {
      this.isInitialized(), await this.pairings.update(i3, { peerMetadata: s });
    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (i3) => {
      this.isInitialized(), await this.isValidDisconnect(i3);
      const { topic: s } = i3;
      this.pairings.keys.includes(s) && (await this.sendRequest(s, "wc_pairingDelete", R("USER_DISCONNECTED")), await this.deletePairing(s));
    }, this.sendRequest = async (i3, s, n3) => {
      const a3 = formatJsonRpcRequest(s, n3), o2 = await this.core.crypto.encode(i3, a3), h3 = U2[s].req;
      return this.core.history.set(i3, a3), await this.core.relayer.publish(i3, o2, h3), a3.id;
    }, this.sendResult = async (i3, s, n3) => {
      const a3 = formatJsonRpcResult(i3, n3), o2 = await this.core.crypto.encode(s, a3), h3 = await this.core.history.get(s, i3), d5 = U2[h3.request.method].res;
      await this.core.relayer.publish(s, o2, d5), await this.core.history.resolve(a3);
    }, this.sendError = async (i3, s, n3) => {
      const a3 = formatJsonRpcError(i3, n3), o2 = await this.core.crypto.encode(s, a3), h3 = await this.core.history.get(s, i3), d5 = U2[h3.request.method] ? U2[h3.request.method].res : U2.unregistered_method.res;
      await this.core.relayer.publish(s, o2, d5), await this.core.history.resolve(a3);
    }, this.deletePairing = async (i3, s) => {
      await this.core.relayer.unsubscribe(i3), await Promise.all([this.pairings.delete(i3, R("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(i3), s ? Promise.resolve() : this.core.expirer.del(i3)]);
    }, this.cleanup = async () => {
      const i3 = this.pairings.getAll().filter((s) => ot(s.expiry));
      await Promise.all(i3.map((s) => this.deletePairing(s.topic)));
    }, this.onRelayEventRequest = (i3) => {
      const { topic: s, payload: n3 } = i3, a3 = n3.method;
      if (this.pairings.keys.includes(s))
        switch (a3) {
          case "wc_pairingPing":
            return this.onPairingPingRequest(s, n3);
          case "wc_pairingDelete":
            return this.onPairingDeleteRequest(s, n3);
          default:
            return this.onUnknownRpcMethodRequest(s, n3);
        }
    }, this.onRelayEventResponse = async (i3) => {
      const { topic: s, payload: n3 } = i3, a3 = (await this.core.history.get(s, n3.id)).request.method;
      if (this.pairings.keys.includes(s))
        switch (a3) {
          case "wc_pairingPing":
            return this.onPairingPingResponse(s, n3);
          default:
            return this.onUnknownRpcMethodResponse(a3);
        }
    }, this.onPairingPingRequest = async (i3, s) => {
      const { id: n3 } = s;
      try {
        this.isValidPing({ topic: i3 }), await this.sendResult(n3, i3, true), this.events.emit("pairing_ping", { id: n3, topic: i3 });
      } catch (a3) {
        await this.sendError(n3, i3, a3), this.logger.error(a3);
      }
    }, this.onPairingPingResponse = (i3, s) => {
      const { id: n3 } = s;
      setTimeout(() => {
        isJsonRpcResult(s) ? this.events.emit(st("pairing_ping", n3), {}) : isJsonRpcError(s) && this.events.emit(st("pairing_ping", n3), { error: s.error });
      }, 500);
    }, this.onPairingDeleteRequest = async (i3, s) => {
      const { id: n3 } = s;
      try {
        this.isValidDisconnect({ topic: i3 }), await this.deletePairing(i3), this.events.emit("pairing_delete", { id: n3, topic: i3 });
      } catch (a3) {
        await this.sendError(n3, i3, a3), this.logger.error(a3);
      }
    }, this.onUnknownRpcMethodRequest = async (i3, s) => {
      const { id: n3, method: a3 } = s;
      try {
        if (this.registeredMethods.includes(a3))
          return;
        const o2 = R("WC_METHOD_UNSUPPORTED", a3);
        await this.sendError(n3, i3, o2), this.logger.error(o2);
      } catch (o2) {
        await this.sendError(n3, i3, o2), this.logger.error(o2);
      }
    }, this.onUnknownRpcMethodResponse = (i3) => {
      this.registeredMethods.includes(i3) || this.logger.error(R("WC_METHOD_UNSUPPORTED", i3));
    }, this.isValidPair = (i3) => {
      if (!Ct(i3)) {
        const { message: s } = N("MISSING_OR_INVALID", `pair() params: ${i3}`);
        throw new Error(s);
      }
      if (!Tt(i3.uri)) {
        const { message: s } = N("MISSING_OR_INVALID", `pair() uri: ${i3.uri}`);
        throw new Error(s);
      }
    }, this.isValidPing = async (i3) => {
      if (!Ct(i3)) {
        const { message: n3 } = N("MISSING_OR_INVALID", `ping() params: ${i3}`);
        throw new Error(n3);
      }
      const { topic: s } = i3;
      await this.isValidPairingTopic(s);
    }, this.isValidDisconnect = async (i3) => {
      if (!Ct(i3)) {
        const { message: n3 } = N("MISSING_OR_INVALID", `disconnect() params: ${i3}`);
        throw new Error(n3);
      }
      const { topic: s } = i3;
      await this.isValidPairingTopic(s);
    }, this.isValidPairingTopic = async (i3) => {
      if (!m(i3, false)) {
        const { message: s } = N("MISSING_OR_INVALID", `pairing topic should be a string: ${i3}`);
        throw new Error(s);
      }
      if (!this.pairings.keys.includes(i3)) {
        const { message: s } = N("NO_MATCHING_KEY", `pairing topic doesn't exist: ${i3}`);
        throw new Error(s);
      }
      if (ot(this.pairings.get(i3).expiry)) {
        await this.deletePairing(i3);
        const { message: s } = N("EXPIRED", `pairing topic: ${i3}`);
        throw new Error(s);
      }
    }, this.core = e, this.logger = (0, import_logger.generateChildLogger)(t, this.name), this.pairings = new xt(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(D.message, async (e) => {
      const { topic: t, message: i3 } = e;
      if (this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i3)))
        return;
      const s = await this.core.crypto.decode(t, i3);
      isJsonRpcRequest(s) ? (this.core.history.set(t, s), this.onRelayEventRequest({ topic: t, payload: s })) : isJsonRpcResponse(s) && (await this.core.history.resolve(s), this.onRelayEventResponse({ topic: t, payload: s }));
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(E2.expired, async (e) => {
      const { topic: t } = tt(e.target);
      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, true), this.events.emit("pairing_expire", { topic: t }));
    });
  }
};
var At2 = class extends h {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, this.records = /* @__PURE__ */ new Map(), this.events = new import_events4.EventEmitter(), this.name = pt2, this.version = Dt, this.cached = [], this.initialized = false, this.storagePrefix = P, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i3) => this.records.set(i3.id, i3)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.set = (i3, s, n3) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: i3, request: s, chainId: n3 }), this.records.has(s.id))
        return;
      const a3 = { id: s.id, topic: i3, request: { method: s.method, params: s.params || null }, chainId: n3 };
      this.records.set(a3.id, a3), this.events.emit(C2.created, a3);
    }, this.resolve = async (i3) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: i3 }), !this.records.has(i3.id))
        return;
      const s = await this.getRecord(i3.id);
      typeof s.response > "u" && (s.response = isJsonRpcError(i3) ? { error: i3.error } : { result: i3.result }, this.records.set(s.id, s), this.events.emit(C2.updated, s));
    }, this.get = async (i3, s) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: i3, id: s }), await this.getRecord(s)), this.delete = (i3, s) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: s }), this.values.forEach((n3) => {
        if (n3.topic === i3) {
          if (typeof s < "u" && n3.id !== s)
            return;
          this.records.delete(n3.id), this.events.emit(C2.deleted, n3);
        }
      });
    }, this.exists = async (i3, s) => (this.isInitialized(), this.records.has(s) ? (await this.getRecord(s)).topic === i3 : false), this.on = (i3, s) => {
      this.events.on(i3, s);
    }, this.once = (i3, s) => {
      this.events.once(i3, s);
    }, this.off = (i3, s) => {
      this.events.off(i3, s);
    }, this.removeListener = (i3, s) => {
      this.events.removeListener(i3, s);
    }, this.logger = (0, import_logger.generateChildLogger)(t, this.name);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e = [];
    return this.values.forEach((t) => {
      if (typeof t.response < "u")
        return;
      const i3 = { topic: t.topic, request: formatJsonRpcRequest(t.request.method, t.request.params, t.id), chainId: t.chainId };
      return e.push(i3);
    }), e;
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e) {
    this.isInitialized();
    const t = this.records.get(e);
    if (!t) {
      const { message: i3 } = N("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(i3);
    }
    return t;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(C2.sync);
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords();
      if (typeof e > "u" || !e.length)
        return;
      if (this.records.size) {
        const { message: t } = N("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
    }
  }
  registerEventListeners() {
    this.events.on(C2.created, (e) => {
      const t = C2.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e }), this.persist();
    }), this.events.on(C2.updated, (e) => {
      const t = C2.updated;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e }), this.persist();
    }), this.events.on(C2.deleted, (e) => {
      const t = C2.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var zt = class extends E {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, this.expirations = /* @__PURE__ */ new Map(), this.events = new import_events4.EventEmitter(), this.name = yt, this.version = bt, this.cached = [], this.initialized = false, this.storagePrefix = P, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i3) => this.expirations.set(i3.target, i3)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.has = (i3) => {
      try {
        const s = this.formatTarget(i3);
        return typeof this.getExpiration(s) < "u";
      } catch {
        return false;
      }
    }, this.set = (i3, s) => {
      this.isInitialized();
      const n3 = this.formatTarget(i3), a3 = { target: n3, expiry: s };
      this.expirations.set(n3, a3), this.checkExpiry(n3, a3), this.events.emit(E2.created, { target: n3, expiration: a3 });
    }, this.get = (i3) => {
      this.isInitialized();
      const s = this.formatTarget(i3);
      return this.getExpiration(s);
    }, this.del = (i3) => {
      if (this.isInitialized(), this.has(i3)) {
        const s = this.formatTarget(i3), n3 = this.getExpiration(s);
        this.expirations.delete(s), this.events.emit(E2.deleted, { target: s, expiration: n3 });
      }
    }, this.on = (i3, s) => {
      this.events.on(i3, s);
    }, this.once = (i3, s) => {
      this.events.once(i3, s);
    }, this.off = (i3, s) => {
      this.events.off(i3, s);
    }, this.removeListener = (i3, s) => {
      this.events.removeListener(i3, s);
    }, this.logger = (0, import_logger.generateChildLogger)(t, this.name);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e) {
    if (typeof e == "string")
      return et(e);
    if (typeof e == "number")
      return nt(e);
    const { message: t } = N("UNKNOWN_TYPE", `Target type: ${typeof e}`);
    throw new Error(t);
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(E2.sync);
  }
  async restore() {
    try {
      const e = await this.getExpirations();
      if (typeof e > "u" || !e.length)
        return;
      if (this.expirations.size) {
        const { message: t } = N("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);
    }
  }
  getExpiration(e) {
    const t = this.expirations.get(e);
    if (!t) {
      const { message: i3 } = N("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(i3), new Error(i3);
    }
    return t;
  }
  checkExpiry(e, t) {
    const { expiry: i3 } = t;
    (0, import_time2.toMiliseconds)(i3) - Date.now() <= 0 && this.expire(e, t);
  }
  expire(e, t) {
    this.expirations.delete(e), this.events.emit(E2.expired, { target: e, expiration: t });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e, t) => this.checkExpiry(t, e));
  }
  registerEventListeners() {
    this.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, () => this.checkExpirations()), this.events.on(E2.created, (e) => {
      const t = E2.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(E2.expired, (e) => {
      const t = E2.expired;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(E2.deleted, (e) => {
      const t = E2.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Nt = class extends y {
  constructor(e, t) {
    super(e, t), this.projectId = e, this.logger = t, this.name = J2, this.initialized = false, this.init = async (i3) => {
      je() || !Ce() || (this.verifyUrl = (i3 == null ? void 0 : i3.verifyUrl) || le2, await this.createIframe());
    }, this.register = async (i3) => {
      var s;
      this.initialized || await this.init(), this.iframe && ((s = this.iframe.contentWindow) == null || s.postMessage(i3.attestationId, this.verifyUrl), this.logger.info(`postMessage sent: ${i3.attestationId} ${this.verifyUrl}`));
    }, this.resolve = async (i3) => {
      var s;
      if (this.isDevEnv)
        return "";
      this.logger.info(`resolving attestation: ${i3.attestationId}`);
      const n3 = this.startAbortTimer(import_time2.FIVE_SECONDS), a3 = await fetch(`${this.verifyUrl}/attestation/${i3.attestationId}`, { signal: this.abortController.signal });
      return clearTimeout(n3), a3.status === 200 ? (s = await a3.json()) == null ? void 0 : s.origin : "";
    }, this.createIframe = async () => {
      try {
        await Promise.race([new Promise((i3, s) => {
          if (document.getElementById(J2))
            return i3();
          const n3 = document.createElement("iframe");
          n3.setAttribute("id", J2), n3.setAttribute("src", `${this.verifyUrl}/${this.projectId}`), n3.style.display = "none", n3.addEventListener("load", () => {
            this.initialized = true, i3();
          }), n3.addEventListener("error", (a3) => {
            s(a3);
          }), document.body.append(n3), this.iframe = n3;
        }), new Promise((i3) => {
          setTimeout(() => i3("iframe load timeout"), (0, import_time2.toMiliseconds)(import_time2.ONE_SECOND / 2));
        })]);
      } catch (i3) {
        this.logger.error(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.error(i3);
      }
    }, this.logger = (0, import_logger.generateChildLogger)(t, this.name), this.verifyUrl = le2, this.abortController = new AbortController(), this.isDevEnv = X() && import_process.default.env.IS_VITEST;
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  startAbortTimer(e) {
    return setTimeout(() => this.abortController.abort(), (0, import_time2.toMiliseconds)(e));
  }
};
var Er = Object.defineProperty;
var Ut = Object.getOwnPropertySymbols;
var wr = Object.prototype.hasOwnProperty;
var vr = Object.prototype.propertyIsEnumerable;
var Lt = (r, e, t) => e in r ? Er(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var Ft = (r, e) => {
  for (var t in e || (e = {}))
    wr.call(e, t) && Lt(r, t, e[t]);
  if (Ut)
    for (var t of Ut(e))
      vr.call(e, t) && Lt(r, t, e[t]);
  return r;
};
var H = class extends n {
  constructor(e) {
    super(e), this.protocol = he, this.version = qe2, this.name = Y2, this.events = new import_events4.EventEmitter(), this.initialized = false, this.on = (i3, s) => this.events.on(i3, s), this.once = (i3, s) => this.events.once(i3, s), this.off = (i3, s) => this.events.off(i3, s), this.removeListener = (i3, s) => this.events.removeListener(i3, s), this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || ue2;
    const t = typeof (e == null ? void 0 : e.logger) < "u" && typeof (e == null ? void 0 : e.logger) != "string" ? e.logger : (0, import_logger.pino)((0, import_logger.getDefaultLoggerOptions)({ level: (e == null ? void 0 : e.logger) || Ge.logger }));
    this.logger = (0, import_logger.generateChildLogger)(t, this.name), this.heartbeat = new import_heartbeat.HeartBeat(), this.crypto = new ft2(this, this.logger, e == null ? void 0 : e.keychain), this.history = new At2(this, this.logger), this.expirer = new zt(this, this.logger), this.storage = e != null && e.storage ? e.storage : new import_keyvaluestorage.default(Ft(Ft({}, Ye), e == null ? void 0 : e.storageOptions)), this.relayer = new Rt2({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new Ot(this, this.logger), this.verify = new Nt(this.projectId || "", this.logger);
  }
  static async init(e) {
    const t = new H(e);
    return await t.initialize(), t;
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.initialized = true, this.logger.info("Core Initialization Success");
    } catch (e) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;
    }
  }
};
var Ir = H;

// node_modules/@walletconnect/web3wallet/dist/index.es.js
init_shim();

// node_modules/@walletconnect/auth-client/dist/index.es.js
init_shim();
var import_logger2 = __toESM(require_cjs2());
var import_events5 = __toESM(require_events());
init_esm3();
var import_time3 = __toESM(require_cjs());
init_lib();
init_lib2();
var import_isomorphic_unfetch = __toESM(require_browser3());
var import_random2 = __toESM(require_random());
var import_sha2562 = __toESM(require_sha256());
var J3 = class {
  constructor(t) {
    this.client = t;
  }
};
var X2 = class {
  constructor(t) {
    this.opts = t;
  }
};
var G3 = "https://rpc.walletconnect.com/v1";
var R2 = { wc_authRequest: { req: { ttl: import_time3.ONE_DAY, prompt: true, tag: 3e3 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 3001 } } };
var U3 = { min: import_time3.FIVE_MINUTES, max: import_time3.SEVEN_DAYS };
var B = "wc";
var H2 = 1;
var Y3 = "auth";
var N3 = "authClient";
var F2 = `${B}@${1}:${Y3}:`;
var x = `${F2}:PUB_KEY`;
function P2(r) {
  return r == null ? void 0 : r.split(":");
}
function He3(r) {
  const t = r && P2(r);
  if (t)
    return t[3];
}
function Ye2(r) {
  const t = r && P2(r);
  if (t)
    return t[2] + ":" + t[3];
}
function Q2(r) {
  const t = r && P2(r);
  if (t)
    return t.pop();
}
async function Qe2(r, t, e, i3, n3) {
  switch (e.t) {
    case "eip191":
      return Ze2(r, t, e.s);
    case "eip1271":
      return await We2(r, t, e.s, i3, n3);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${e.t}`);
  }
}
function Ze2(r, t, e) {
  return recoverAddress(hashMessage(t), e).toLowerCase() === r.toLowerCase();
}
async function We2(r, t, e, i3, n3) {
  try {
    const s = "0x1626ba7e", u5 = "0000000000000000000000000000000000000000000000000000000000000040", o2 = "0000000000000000000000000000000000000000000000000000000000000041", a3 = e.substring(2), h3 = hashMessage(t).substring(2), D3 = s + h3 + u5 + o2 + a3, p6 = await (0, import_isomorphic_unfetch.default)(`${G3}/?chainId=${i3}&projectId=${n3}`, { method: "POST", body: JSON.stringify({ id: et3(), jsonrpc: "2.0", method: "eth_call", params: [{ to: r, data: D3 }, "latest"] }) }), { result: g5 } = await p6.json();
    return g5 ? g5.slice(0, s.length).toLowerCase() === s.toLowerCase() : false;
  } catch (s) {
    return console.error("isValidEip1271Signature: ", s), false;
  }
}
function et3() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
function Z(r) {
  return r.getAll().filter((t) => "requester" in t);
}
function W3(r, t) {
  return Z(r).find((e) => e.id === t);
}
function tt3(r) {
  const t = Tt(r.aud), e = new RegExp(`${r.domain}`).test(r.aud), i3 = !!r.nonce, n3 = r.type ? r.type === "eip4361" : true, s = r.expiry;
  if (s && !Ht(s, U3)) {
    const { message: u5 } = N("MISSING_OR_INVALID", `request() expiry: ${s}. Expiry must be a number (in seconds) between ${U3.min} and ${U3.max}`);
    throw new Error(u5);
  }
  return !!(t && e && i3 && n3);
}
function rt3(r, t) {
  return !!W3(t, r.id);
}
function it3(r = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(r) : new Uint8Array(r);
}
function nt3(r, t) {
  if (r.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var e = new Uint8Array(256), i3 = 0; i3 < e.length; i3++)
    e[i3] = 255;
  for (var n3 = 0; n3 < r.length; n3++) {
    var s = r.charAt(n3), u5 = s.charCodeAt(0);
    if (e[u5] !== 255)
      throw new TypeError(s + " is ambiguous");
    e[u5] = n3;
  }
  var o2 = r.length, a3 = r.charAt(0), h3 = Math.log(o2) / Math.log(256), D3 = Math.log(256) / Math.log(o2);
  function p6(c3) {
    if (c3 instanceof Uint8Array || (ArrayBuffer.isView(c3) ? c3 = new Uint8Array(c3.buffer, c3.byteOffset, c3.byteLength) : Array.isArray(c3) && (c3 = Uint8Array.from(c3))), !(c3 instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (c3.length === 0)
      return "";
    for (var f6 = 0, _4 = 0, b5 = 0, w5 = c3.length; b5 !== w5 && c3[b5] === 0; )
      b5++, f6++;
    for (var C7 = (w5 - b5) * D3 + 1 >>> 0, E6 = new Uint8Array(C7); b5 !== w5; ) {
      for (var m5 = c3[b5], A3 = 0, y4 = C7 - 1; (m5 !== 0 || A3 < _4) && y4 !== -1; y4--, A3++)
        m5 += 256 * E6[y4] >>> 0, E6[y4] = m5 % o2 >>> 0, m5 = m5 / o2 >>> 0;
      if (m5 !== 0)
        throw new Error("Non-zero carry");
      _4 = A3, b5++;
    }
    for (var v = C7 - _4; v !== C7 && E6[v] === 0; )
      v++;
    for (var I4 = a3.repeat(f6); v < C7; ++v)
      I4 += r.charAt(E6[v]);
    return I4;
  }
  function g5(c3) {
    if (typeof c3 != "string")
      throw new TypeError("Expected String");
    if (c3.length === 0)
      return new Uint8Array();
    var f6 = 0;
    if (c3[f6] !== " ") {
      for (var _4 = 0, b5 = 0; c3[f6] === a3; )
        _4++, f6++;
      for (var w5 = (c3.length - f6) * h3 + 1 >>> 0, C7 = new Uint8Array(w5); c3[f6]; ) {
        var E6 = e[c3.charCodeAt(f6)];
        if (E6 === 255)
          return;
        for (var m5 = 0, A3 = w5 - 1; (E6 !== 0 || m5 < b5) && A3 !== -1; A3--, m5++)
          E6 += o2 * C7[A3] >>> 0, C7[A3] = E6 % 256 >>> 0, E6 = E6 / 256 >>> 0;
        if (E6 !== 0)
          throw new Error("Non-zero carry");
        b5 = m5, f6++;
      }
      if (c3[f6] !== " ") {
        for (var y4 = w5 - b5; y4 !== w5 && C7[y4] === 0; )
          y4++;
        for (var v = new Uint8Array(_4 + (w5 - y4)), I4 = _4; y4 !== w5; )
          v[I4++] = C7[y4++];
        return v;
      }
    }
  }
  function l2(c3) {
    var f6 = g5(c3);
    if (f6)
      return f6;
    throw new Error(`Non-${t} character`);
  }
  return { encode: p6, decodeUnsafe: g5, decode: l2 };
}
var st3 = nt3;
var ut3 = st3;
var ee2 = (r) => {
  if (r instanceof Uint8Array && r.constructor.name === "Uint8Array")
    return r;
  if (r instanceof ArrayBuffer)
    return new Uint8Array(r);
  if (ArrayBuffer.isView(r))
    return new Uint8Array(r.buffer, r.byteOffset, r.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var ot3 = (r) => new TextEncoder().encode(r);
var at3 = (r) => new TextDecoder().decode(r);
var Dt2 = class {
  constructor(t, e, i3) {
    this.name = t, this.prefix = e, this.baseEncode = i3;
  }
  encode(t) {
    if (t instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(t)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var ct3 = class {
  constructor(t, e, i3) {
    if (this.name = t, this.prefix = e, e.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = e.codePointAt(0), this.baseDecode = i3;
  }
  decode(t) {
    if (typeof t == "string") {
      if (t.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(t.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(t) {
    return te(this, t);
  }
};
var ht2 = class {
  constructor(t) {
    this.decoders = t;
  }
  or(t) {
    return te(this, t);
  }
  decode(t) {
    const e = t[0], i3 = this.decoders[e];
    if (i3)
      return i3.decode(t);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var te = (r, t) => new ht2({ ...r.decoders || { [r.prefix]: r }, ...t.decoders || { [t.prefix]: t } });
var lt3 = class {
  constructor(t, e, i3, n3) {
    this.name = t, this.prefix = e, this.baseEncode = i3, this.baseDecode = n3, this.encoder = new Dt2(t, e, i3), this.decoder = new ct3(t, e, n3);
  }
  encode(t) {
    return this.encoder.encode(t);
  }
  decode(t) {
    return this.decoder.decode(t);
  }
};
var S2 = ({ name: r, prefix: t, encode: e, decode: i3 }) => new lt3(r, t, e, i3);
var T = ({ prefix: r, name: t, alphabet: e }) => {
  const { encode: i3, decode: n3 } = ut3(e, t);
  return S2({ prefix: r, name: t, encode: i3, decode: (s) => ee2(n3(s)) });
};
var dt3 = (r, t, e, i3) => {
  const n3 = {};
  for (let D3 = 0; D3 < t.length; ++D3)
    n3[t[D3]] = D3;
  let s = r.length;
  for (; r[s - 1] === "="; )
    --s;
  const u5 = new Uint8Array(s * e / 8 | 0);
  let o2 = 0, a3 = 0, h3 = 0;
  for (let D3 = 0; D3 < s; ++D3) {
    const p6 = n3[r[D3]];
    if (p6 === void 0)
      throw new SyntaxError(`Non-${i3} character`);
    a3 = a3 << e | p6, o2 += e, o2 >= 8 && (o2 -= 8, u5[h3++] = 255 & a3 >> o2);
  }
  if (o2 >= e || 255 & a3 << 8 - o2)
    throw new SyntaxError("Unexpected end of data");
  return u5;
};
var pt3 = (r, t, e) => {
  const i3 = t[t.length - 1] === "=", n3 = (1 << e) - 1;
  let s = "", u5 = 0, o2 = 0;
  for (let a3 = 0; a3 < r.length; ++a3)
    for (o2 = o2 << 8 | r[a3], u5 += 8; u5 > e; )
      u5 -= e, s += t[n3 & o2 >> u5];
  if (u5 && (s += t[n3 & o2 << e - u5]), i3)
    for (; s.length * e & 7; )
      s += "=";
  return s;
};
var d2 = ({ name: r, prefix: t, bitsPerChar: e, alphabet: i3 }) => S2({ prefix: t, name: r, encode(n3) {
  return pt3(n3, i3, e);
}, decode(n3) {
  return dt3(n3, i3, e, r);
} });
var ft3 = S2({ prefix: "\0", name: "identity", encode: (r) => at3(r), decode: (r) => ot3(r) });
var gt2 = Object.freeze({ __proto__: null, identity: ft3 });
var Et2 = d2({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var bt2 = Object.freeze({ __proto__: null, base2: Et2 });
var yt2 = d2({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var wt2 = Object.freeze({ __proto__: null, base8: yt2 });
var Ct3 = T({ prefix: "9", name: "base10", alphabet: "0123456789" });
var mt2 = Object.freeze({ __proto__: null, base10: Ct3 });
var vt2 = d2({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var At3 = d2({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var _t2 = Object.freeze({ __proto__: null, base16: vt2, base16upper: At3 });
var xt2 = d2({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var Rt3 = d2({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var Ft2 = d2({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var Tt3 = d2({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var It3 = d2({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var Ut2 = d2({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var St3 = d2({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var Ot2 = d2({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var qt = d2({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var $t2 = Object.freeze({ __proto__: null, base32: xt2, base32upper: Rt3, base32pad: Ft2, base32padupper: Tt3, base32hex: It3, base32hexupper: Ut2, base32hexpad: St3, base32hexpadupper: Ot2, base32z: qt });
var Bt = T({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var Nt2 = T({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var Pt2 = Object.freeze({ __proto__: null, base36: Bt, base36upper: Nt2 });
var zt2 = T({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var Mt2 = T({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var jt = Object.freeze({ __proto__: null, base58btc: zt2, base58flickr: Mt2 });
var Lt2 = d2({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var Kt2 = d2({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var Vt = d2({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var kt = d2({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Jt = Object.freeze({ __proto__: null, base64: Lt2, base64pad: Kt2, base64url: Vt, base64urlpad: kt });
var re2 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var Xt = re2.reduce((r, t, e) => (r[e] = t, r), []);
var Gt = re2.reduce((r, t, e) => (r[t.codePointAt(0)] = e, r), []);
function Ht2(r) {
  return r.reduce((t, e) => (t += Xt[e], t), "");
}
function Yt(r) {
  const t = [];
  for (const e of r) {
    const i3 = Gt[e.codePointAt(0)];
    if (i3 === void 0)
      throw new Error(`Non-base256emoji character: ${e}`);
    t.push(i3);
  }
  return new Uint8Array(t);
}
var Qt = S2({ prefix: "\u{1F680}", name: "base256emoji", encode: Ht2, decode: Yt });
var Zt = Object.freeze({ __proto__: null, base256emoji: Qt });
var Wt = ne3;
var ie2 = 128;
var er2 = 127;
var tr2 = ~er2;
var rr = Math.pow(2, 31);
function ne3(r, t, e) {
  t = t || [], e = e || 0;
  for (var i3 = e; r >= rr; )
    t[e++] = r & 255 | ie2, r /= 128;
  for (; r & tr2; )
    t[e++] = r & 255 | ie2, r >>>= 7;
  return t[e] = r | 0, ne3.bytes = e - i3 + 1, t;
}
var ir = z2;
var nr = 128;
var se = 127;
function z2(r, i3) {
  var e = 0, i3 = i3 || 0, n3 = 0, s = i3, u5, o2 = r.length;
  do {
    if (s >= o2)
      throw z2.bytes = 0, new RangeError("Could not decode varint");
    u5 = r[s++], e += n3 < 28 ? (u5 & se) << n3 : (u5 & se) * Math.pow(2, n3), n3 += 7;
  } while (u5 >= nr);
  return z2.bytes = s - i3, e;
}
var sr = Math.pow(2, 7);
var ur2 = Math.pow(2, 14);
var or2 = Math.pow(2, 21);
var ar2 = Math.pow(2, 28);
var Dr2 = Math.pow(2, 35);
var cr2 = Math.pow(2, 42);
var hr2 = Math.pow(2, 49);
var lr2 = Math.pow(2, 56);
var dr2 = Math.pow(2, 63);
var pr2 = function(r) {
  return r < sr ? 1 : r < ur2 ? 2 : r < or2 ? 3 : r < ar2 ? 4 : r < Dr2 ? 5 : r < cr2 ? 6 : r < hr2 ? 7 : r < lr2 ? 8 : r < dr2 ? 9 : 10;
};
var fr2 = { encode: Wt, decode: ir, encodingLength: pr2 };
var ue3 = fr2;
var oe2 = (r, t, e = 0) => (ue3.encode(r, t, e), t);
var ae3 = (r) => ue3.encodingLength(r);
var M2 = (r, t) => {
  const e = t.byteLength, i3 = ae3(r), n3 = i3 + ae3(e), s = new Uint8Array(n3 + e);
  return oe2(r, s, 0), oe2(e, s, i3), s.set(t, n3), new gr2(r, e, t, s);
};
var gr2 = class {
  constructor(t, e, i3, n3) {
    this.code = t, this.size = e, this.digest = i3, this.bytes = n3;
  }
};
var De2 = ({ name: r, code: t, encode: e }) => new Er2(r, t, e);
var Er2 = class {
  constructor(t, e, i3) {
    this.name = t, this.code = e, this.encode = i3;
  }
  digest(t) {
    if (t instanceof Uint8Array) {
      const e = this.encode(t);
      return e instanceof Uint8Array ? M2(this.code, e) : e.then((i3) => M2(this.code, i3));
    } else
      throw Error("Unknown type, must be binary type");
  }
};
var ce3 = (r) => async (t) => new Uint8Array(await crypto.subtle.digest(r, t));
var br2 = De2({ name: "sha2-256", code: 18, encode: ce3("SHA-256") });
var yr2 = De2({ name: "sha2-512", code: 19, encode: ce3("SHA-512") });
var wr2 = Object.freeze({ __proto__: null, sha256: br2, sha512: yr2 });
var he2 = 0;
var Cr = "identity";
var le3 = ee2;
var mr2 = (r) => M2(he2, le3(r));
var vr2 = { code: he2, name: Cr, encode: le3, digest: mr2 };
var Ar = Object.freeze({ __proto__: null, identity: vr2 });
new TextEncoder(), new TextDecoder();
var de2 = { ...gt2, ...bt2, ...wt2, ...mt2, ..._t2, ...$t2, ...Pt2, ...jt, ...Jt, ...Zt };
({ ...wr2, ...Ar });
function pe3(r, t, e, i3) {
  return { name: r, prefix: t, encoder: { name: r, prefix: t, encode: e }, decoder: { decode: i3 } };
}
var fe2 = pe3("utf8", "u", (r) => "u" + new TextDecoder("utf8").decode(r), (r) => new TextEncoder().encode(r.substring(1)));
var j2 = pe3("ascii", "a", (r) => {
  let t = "a";
  for (let e = 0; e < r.length; e++)
    t += String.fromCharCode(r[e]);
  return t;
}, (r) => {
  r = r.substring(1);
  const t = it3(r.length);
  for (let e = 0; e < r.length; e++)
    t[e] = r.charCodeAt(e);
  return t;
});
var ge2 = { utf8: fe2, "utf-8": fe2, hex: de2.base16, latin1: j2, ascii: j2, binary: j2, ...de2 };
function _r(r, t = "utf8") {
  const e = ge2[t];
  if (!e)
    throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r, "utf8") : e.decoder.decode(`${e.prefix}${r}`);
}
function xr(r, t = "utf8") {
  const e = ge2[t];
  if (!e)
    throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r.buffer, r.byteOffset, r.byteLength).toString("utf8") : e.encoder.encode(r).substring(1);
}
var Ee2 = "base16";
var be = "utf8";
function ye(r) {
  const t = (0, import_sha2562.hash)(_r(r, be));
  return xr(t, Ee2);
}
var Ir2 = Object.defineProperty;
var Ur = Object.defineProperties;
var Sr = Object.getOwnPropertyDescriptors;
var we3 = Object.getOwnPropertySymbols;
var Or = Object.prototype.hasOwnProperty;
var qr = Object.prototype.propertyIsEnumerable;
var Ce2 = (r, t, e) => t in r ? Ir2(r, t, { enumerable: true, configurable: true, writable: true, value: e }) : r[t] = e;
var L = (r, t) => {
  for (var e in t || (t = {}))
    Or.call(t, e) && Ce2(r, e, t[e]);
  if (we3)
    for (var e of we3(t))
      qr.call(t, e) && Ce2(r, e, t[e]);
  return r;
};
var $r = (r, t) => Ur(r, Sr(t));
var Br = class extends J3 {
  constructor(t) {
    super(t), this.initialized = false, this.name = "authEngine", this.init = () => {
      this.initialized || (this.registerRelayerEvents(), this.client.core.pairing.register({ methods: Object.keys(R2) }), this.initialized = true);
    }, this.request = async (e, i3) => {
      if (this.isInitialized(), !tt3(e))
        throw new Error("Invalid request");
      if (i3 != null && i3.topic)
        return await this.requestOnKnownPairing(i3.topic, e);
      const { chainId: n3, statement: s, aud: u5, domain: o2, nonce: a3, type: h3 } = e, { topic: D3, uri: p6 } = await this.client.core.pairing.create();
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: D3, uri: p6 } });
      const g5 = await this.client.core.crypto.generateKeyPair(), l2 = _n(g5);
      await this.client.authKeys.set(x, { responseTopic: l2, publicKey: g5 }), await this.client.pairingTopics.set(l2, { topic: l2, pairingTopic: D3 }), await this.client.core.relayer.subscribe(l2), this.client.logger.info(`sending request to new pairing topic: ${D3}`);
      const c3 = await this.sendRequest(D3, "wc_authRequest", { payloadParams: { type: h3 != null ? h3 : "eip4361", chainId: n3, statement: s, aud: u5, domain: o2, version: "1", nonce: a3, iat: new Date().toISOString() }, requester: { publicKey: g5, metadata: this.client.metadata } }, {}, e.expiry);
      return this.client.logger.info(`sent request to new pairing topic: ${D3}`), { uri: p6, id: c3 };
    }, this.respond = async (e, i3) => {
      if (this.isInitialized(), !rt3(e, this.client.requests))
        throw new Error("Invalid response");
      const n3 = W3(this.client.requests, e.id), s = n3.requester.publicKey, u5 = await this.client.core.crypto.generateKeyPair(), o2 = _n(s), a3 = { type: U, receiverPublicKey: s, senderPublicKey: u5 };
      if ("error" in e) {
        await this.sendError(n3.id, o2, e, a3);
        return;
      }
      const h3 = { h: { t: "eip4361" }, p: $r(L({}, n3.cacaoPayload), { iss: i3 }), s: e.signature }, D3 = await this.sendResult(n3.id, o2, h3, a3);
      await this.client.requests.update(D3, L({}, h3));
    }, this.getPendingRequests = () => Z(this.client.requests), this.formatMessage = (e, i3) => {
      this.client.logger.debug(`formatMessage, cacao is: ${JSON.stringify(e)}`);
      const n3 = `${e.domain} wants you to sign in with your Ethereum account:`, s = Q2(i3), u5 = e.statement, o2 = `URI: ${e.aud}`, a3 = `Version: ${e.version}`, h3 = `Chain ID: ${He3(i3)}`, D3 = `Nonce: ${e.nonce}`, p6 = `Issued At: ${e.iat}`, g5 = e.resources && e.resources.length > 0 ? `Resources:
${e.resources.map((l2) => `- ${l2}`).join(`
`)}` : void 0;
      return [n3, s, "", u5, "", o2, a3, h3, D3, p6, g5].filter((l2) => l2 != null).join(`
`);
    }, this.setExpiry = async (e, i3) => {
      this.client.core.pairing.pairings.keys.includes(e) && await this.client.core.pairing.updateExpiry({ topic: e, expiry: i3 }), this.client.core.expirer.set(e, i3);
    }, this.sendRequest = async (e, i3, n3, s, u5) => {
      const o2 = formatJsonRpcRequest(i3, n3), a3 = await this.client.core.crypto.encode(e, o2, s), h3 = R2[i3].req;
      return u5 && (h3.ttl = u5), this.client.core.history.set(e, o2), await this.client.core.relayer.publish(e, a3, h3), o2.id;
    }, this.sendResult = async (e, i3, n3, s) => {
      const u5 = formatJsonRpcResult(e, n3), o2 = await this.client.core.crypto.encode(i3, u5, s), a3 = await this.client.core.history.get(i3, e), h3 = R2[a3.request.method].res;
      return await this.client.core.relayer.publish(i3, o2, h3), await this.client.core.history.resolve(u5), u5.id;
    }, this.sendError = async (e, i3, n3, s) => {
      const u5 = formatJsonRpcError(e, n3.error), o2 = await this.client.core.crypto.encode(i3, u5, s), a3 = await this.client.core.history.get(i3, e), h3 = R2[a3.request.method].res;
      return await this.client.core.relayer.publish(i3, o2, h3), await this.client.core.history.resolve(u5), u5.id;
    }, this.requestOnKnownPairing = async (e, i3) => {
      const n3 = this.client.core.pairing.pairings.getAll({ active: true }).find((l2) => l2.topic === e);
      if (!n3)
        throw new Error(`Could not find pairing for provided topic ${e}`);
      const { publicKey: s } = this.client.authKeys.get(x), { chainId: u5, statement: o2, aud: a3, domain: h3, nonce: D3, type: p6 } = i3, g5 = await this.sendRequest(n3.topic, "wc_authRequest", { payloadParams: { type: p6 != null ? p6 : "eip4361", chainId: u5, statement: o2, aud: a3, domain: h3, version: "1", nonce: D3, iat: new Date().toISOString() }, requester: { publicKey: s, metadata: this.client.metadata } }, {}, i3.expiry);
      return this.client.logger.info(`sent request to known pairing topic: ${n3.topic}`), { id: g5 };
    }, this.onRelayEventRequest = (e) => {
      const { topic: i3, payload: n3 } = e, s = n3.method;
      switch (s) {
        case "wc_authRequest":
          return this.onAuthRequest(i3, n3);
        default:
          return this.client.logger.info(`Unsupported request method ${s}`);
      }
    }, this.onRelayEventResponse = async (e) => {
      const { topic: i3, payload: n3 } = e, s = (await this.client.core.history.get(i3, n3.id)).request.method;
      switch (s) {
        case "wc_authRequest":
          return this.onAuthResponse(i3, n3);
        default:
          return this.client.logger.info(`Unsupported response method ${s}`);
      }
    }, this.onAuthRequest = async (e, i3) => {
      const { requester: n3, payloadParams: { resources: s, statement: u5, aud: o2, domain: a3, version: h3, nonce: D3, iat: p6, chainId: g5 } } = i3.params;
      this.client.logger.info({ type: "onAuthRequest", topic: e, payload: i3 });
      try {
        const l2 = { aud: o2, domain: a3, version: h3, nonce: D3, iat: p6, statement: u5, resources: s, chainId: g5 };
        await this.client.requests.set(i3.id, { requester: n3, pairingTopic: e, id: i3.id, cacaoPayload: l2 });
        const c3 = ye(JSON.stringify(i3)), f6 = await this.getVerifyContext(c3, this.client.metadata);
        this.client.emit("auth_request", { id: i3.id, topic: e, params: { requester: n3, cacaoPayload: l2 }, verifyContext: f6 });
      } catch (l2) {
        await this.sendError(i3.id, e, l2), this.client.logger.error(l2);
      }
    }, this.onAuthResponse = async (e, i3) => {
      const { id: n3 } = i3;
      if (this.client.logger.info({ type: "onAuthResponse", topic: e, response: i3 }), isJsonRpcResult(i3)) {
        const { pairingTopic: s } = this.client.pairingTopics.get(e);
        await this.client.core.pairing.activate({ topic: s });
        const { s: u5, p: o2 } = i3.result;
        await this.client.requests.set(n3, L({ id: n3, pairingTopic: s }, i3.result));
        const a3 = this.formatMessage(o2, o2.iss);
        this.client.logger.debug(`reconstructed message:
`, JSON.stringify(a3)), this.client.logger.debug("payload.iss:", o2.iss), this.client.logger.debug("signature:", u5);
        const h3 = Q2(o2.iss), D3 = Ye2(o2.iss);
        if (!h3)
          throw new Error("Could not derive address from `payload.iss`");
        if (!D3)
          throw new Error("Could not derive chainId from `payload.iss`");
        this.client.logger.debug("walletAddress extracted from `payload.iss`:", h3), await Qe2(h3, a3, u5, D3, this.client.projectId) ? this.client.emit("auth_response", { id: n3, topic: e, params: i3 }) : this.client.emit("auth_response", { id: n3, topic: e, params: { message: "Invalid signature", code: -1 } });
      } else
        isJsonRpcError(i3) && this.client.emit("auth_response", { id: n3, topic: e, params: i3 });
    }, this.getVerifyContext = async (e, i3) => {
      const n3 = { verified: { verifyUrl: i3.verifyUrl || "", validation: "UNKNOWN", origin: i3.url || "" } };
      try {
        const s = await this.client.core.verify.resolve({ attestationId: e, verifyUrl: i3.verifyUrl });
        s && (n3.verified.origin = s, n3.verified.validation = s === i3.url ? "VALID" : "INVALID");
      } catch (s) {
        this.client.logger.error(s);
      }
      return this.client.logger.info(`Verify context: ${JSON.stringify(n3)}`), n3;
    };
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = N("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(D.message, async (t) => {
      const { topic: e, message: i3 } = t, { responseTopic: n3, publicKey: s } = this.client.authKeys.keys.includes(x) ? this.client.authKeys.get(x) : { responseTopic: void 0, publicKey: void 0 };
      if (n3 && e !== n3) {
        this.client.logger.debug("[Auth] Ignoring message from unknown topic", e);
        return;
      }
      const u5 = await this.client.core.crypto.decode(e, i3, { receiverPublicKey: s });
      isJsonRpcRequest(u5) ? (this.client.core.history.set(e, u5), this.onRelayEventRequest({ topic: e, payload: u5 })) : isJsonRpcResponse(u5) && (await this.client.core.history.resolve(u5), this.onRelayEventResponse({ topic: e, payload: u5 }));
    });
  }
};
var O = class extends X2 {
  constructor(t) {
    super(t), this.protocol = B, this.version = H2, this.name = N3, this.events = new import_events5.EventEmitter(), this.emit = (i3, n3) => this.events.emit(i3, n3), this.on = (i3, n3) => this.events.on(i3, n3), this.once = (i3, n3) => this.events.once(i3, n3), this.off = (i3, n3) => this.events.off(i3, n3), this.removeListener = (i3, n3) => this.events.removeListener(i3, n3), this.request = async (i3, n3) => {
      try {
        return await this.engine.request(i3, n3);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.respond = async (i3, n3) => {
      try {
        return await this.engine.respond(i3, n3);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.getPendingRequests = () => {
      try {
        return this.engine.getPendingRequests();
      } catch (i3) {
        throw this.logger.error(i3.message), i3;
      }
    }, this.formatMessage = (i3, n3) => {
      try {
        return this.engine.formatMessage(i3, n3);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    };
    const e = typeof t.logger < "u" && typeof t.logger != "string" ? t.logger : (0, import_logger2.pino)((0, import_logger2.getDefaultLoggerOptions)({ level: t.logger || "error" }));
    this.name = (t == null ? void 0 : t.name) || N3, this.metadata = t.metadata, this.projectId = t.projectId, this.core = t.core || new Ir(t), this.logger = (0, import_logger2.generateChildLogger)(e, this.name), this.authKeys = new xt(this.core, this.logger, "authKeys", F2, () => x), this.pairingTopics = new xt(this.core, this.logger, "pairingTopics", F2), this.requests = new xt(this.core, this.logger, "requests", F2), this.engine = new Br(this);
  }
  static async init(t) {
    const e = new O(t);
    return await e.initialize(), e;
  }
  get context() {
    return (0, import_logger2.getLoggerContext)(this.logger);
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.authKeys.init(), await this.requests.init(), await this.pairingTopics.init(), await this.engine.init(), this.logger.info("AuthClient Initialization Success"), this.logger.info({ authClient: this });
    } catch (t) {
      throw this.logger.info("AuthClient Initialization Failure"), this.logger.error(t.message), t;
    }
  }
};
var Nr = O;

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/sign-client/dist/index.es.js
init_shim();

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/core/dist/index.es.js
init_shim();
var import_events8 = __toESM(require_events());
var import_keyvaluestorage2 = __toESM(require_browser());
var import_heartbeat2 = __toESM(require_cjs5());
var import_logger3 = __toESM(require_cjs2());

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/types/dist/index.es.js
init_shim();
init_esm();
var import_events7 = __toESM(require_events());
var n2 = class extends IEvents {
  constructor(s) {
    super(), this.opts = s, this.protocol = "wc", this.version = 2;
  }
};
var h2 = class extends IEvents {
  constructor(s, t) {
    super(), this.core = s, this.logger = t, this.records = /* @__PURE__ */ new Map();
  }
};
var a2 = class {
  constructor(s, t) {
    this.logger = s, this.core = t;
  }
};
var u2 = class extends IEvents {
  constructor(s, t) {
    super(), this.relayer = s, this.logger = t;
  }
};
var g2 = class extends IEvents {
  constructor(s) {
    super();
  }
};
var p3 = class {
  constructor(s, t, o2, w5) {
    this.core = s, this.logger = t, this.name = o2;
  }
};
var d3 = class extends IEvents {
  constructor(s, t) {
    super(), this.relayer = s, this.logger = t;
  }
};
var E3 = class extends IEvents {
  constructor(s, t) {
    super(), this.core = s, this.logger = t;
  }
};
var y2 = class {
  constructor(s, t) {
    this.projectId = s, this.logger = t;
  }
};
var b = class {
  constructor(s) {
    this.opts = s, this.protocol = "wc", this.version = 2;
  }
};
var S3 = class {
  constructor(s) {
    this.client = s;
  }
};

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/core/dist/index.es.js
init_esm2();

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/utils/dist/index.es.js
init_shim();
var import_chacha20poly13052 = __toESM(require_chacha20poly1305());
var import_hkdf2 = __toESM(require_hkdf());
var import_random3 = __toESM(require_random());
var import_sha2563 = __toESM(require_sha256());
var ue4 = __toESM(require_x25519());
init_es();
var import_time4 = __toESM(require_cjs());
var import_window_getters2 = __toESM(require_cjs3());
var import_window_metadata2 = __toESM(require_cjs4());
var C3 = __toESM(require_query_string2());
function V(e, n3) {
  return e.includes(":") ? [e] : n3.chains || [];
}
var W4 = "base10";
var f3 = "base16";
var K2 = "base64pad";
var k2 = "utf8";
var Y4 = 0;
var A2 = 1;
var Rn2 = 0;
var Oe3 = 1;
var J4 = 12;
var Q3 = 32;
function wn2() {
  const e = ue4.generateKeyPair();
  return { privateKey: toString(e.secretKey, f3), publicKey: toString(e.publicKey, f3) };
}
function Un2() {
  const e = (0, import_random3.randomBytes)(Q3);
  return toString(e, f3);
}
function An2(e, n3) {
  const t = ue4.sharedKey(fromString(e, f3), fromString(n3, f3)), r = new import_hkdf2.HKDF(import_sha2563.SHA256, t).expand(Q3);
  return toString(r, f3);
}
function _n2(e) {
  const n3 = (0, import_sha2563.hash)(fromString(e, f3));
  return toString(n3, f3);
}
function $n2(e) {
  const n3 = (0, import_sha2563.hash)(fromString(e, k2));
  return toString(n3, f3);
}
function Se2(e) {
  return fromString(`${e}`, W4);
}
function $4(e) {
  return Number(toString(e, W4));
}
function jn2(e) {
  const n3 = Se2(typeof e.type < "u" ? e.type : Y4);
  if ($4(n3) === A2 && typeof e.senderPublicKey > "u")
    throw new Error("Missing sender public key for type 1 envelope");
  const t = typeof e.senderPublicKey < "u" ? fromString(e.senderPublicKey, f3) : void 0, r = typeof e.iv < "u" ? fromString(e.iv, f3) : (0, import_random3.randomBytes)(J4), o2 = new import_chacha20poly13052.ChaCha20Poly1305(fromString(e.symKey, f3)).seal(r, fromString(e.message, k2));
  return Ie3({ type: n3, sealed: o2, iv: r, senderPublicKey: t });
}
function Cn2(e) {
  const n3 = new import_chacha20poly13052.ChaCha20Poly1305(fromString(e.symKey, f3)), { sealed: t, iv: r } = Z2(e.encoded), o2 = n3.open(r, t);
  if (o2 === null)
    throw new Error("Failed to decrypt");
  return toString(o2, k2);
}
function Ie3(e) {
  if ($4(e.type) === A2) {
    if (typeof e.senderPublicKey > "u")
      throw new Error("Missing sender public key for type 1 envelope");
    return toString(concat([e.type, e.senderPublicKey, e.iv, e.sealed]), K2);
  }
  return toString(concat([e.type, e.iv, e.sealed]), K2);
}
function Z2(e) {
  const n3 = fromString(e, K2), t = n3.slice(Rn2, Oe3), r = Oe3;
  if ($4(t) === A2) {
    const d5 = r + Q3, l2 = d5 + J4, c3 = n3.slice(r, d5), u5 = n3.slice(d5, l2), a3 = n3.slice(l2);
    return { type: t, sealed: a3, iv: u5, senderPublicKey: c3 };
  }
  const o2 = r + J4, s = n3.slice(r, o2), i3 = n3.slice(o2);
  return { type: t, sealed: i3, iv: s };
}
function Dn2(e, n3) {
  const t = Z2(e);
  return Pe3({ type: $4(t.type), senderPublicKey: typeof t.senderPublicKey < "u" ? toString(t.senderPublicKey, f3) : void 0, receiverPublicKey: n3 == null ? void 0 : n3.receiverPublicKey });
}
function Pe3(e) {
  const n3 = (e == null ? void 0 : e.type) || Y4;
  if (n3 === A2) {
    if (typeof (e == null ? void 0 : e.senderPublicKey) > "u")
      throw new Error("missing sender public key");
    if (typeof (e == null ? void 0 : e.receiverPublicKey) > "u")
      throw new Error("missing receiver public key");
  }
  return { type: n3, senderPublicKey: e == null ? void 0 : e.senderPublicKey, receiverPublicKey: e == null ? void 0 : e.receiverPublicKey };
}
function Vn2(e) {
  return e.type === A2 && typeof e.senderPublicKey == "string" && typeof e.receiverPublicKey == "string";
}
var Mn2 = Object.defineProperty;
var Te3 = Object.getOwnPropertySymbols;
var Kn2 = Object.prototype.hasOwnProperty;
var kn = Object.prototype.propertyIsEnumerable;
var Re3 = (e, n3, t) => n3 in e ? Mn2(e, n3, { enumerable: true, configurable: true, writable: true, value: t }) : e[n3] = t;
var we4 = (e, n3) => {
  for (var t in n3 || (n3 = {}))
    Kn2.call(n3, t) && Re3(e, t, n3[t]);
  if (Te3)
    for (var t of Te3(n3))
      kn.call(n3, t) && Re3(e, t, n3[t]);
  return e;
};
var Ue3 = "ReactNative";
var b2 = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" };
var _e2 = "js";
function ee3() {
  return typeof import_process.default < "u" && typeof import_process.default.versions < "u" && typeof import_process.default.versions.node < "u";
}
function $e3() {
  return !(0, import_window_getters2.getDocument)() && !!(0, import_window_getters2.getNavigator)() && navigator.product === Ue3;
}
function je3() {
  return !ee3() && !!(0, import_window_getters2.getNavigator)();
}
function x2() {
  return $e3() ? b2.reactNative : ee3() ? b2.node : je3() ? b2.browser : b2.unknown;
}
function Ce3(e, n3) {
  let t = C3.parse(e);
  return t = we4(we4({}, t), n3), e = C3.stringify(t), e;
}
function Fn() {
  return (0, import_window_metadata2.getWindowMetadata)() || { name: "", description: "", url: "", icons: [""] };
}
function De3() {
  const e = detect();
  if (e === null)
    return "unknown";
  const n3 = e.os ? e.os.replace(" ", "").toLowerCase() : "unknown";
  return e.type === "browser" ? [n3, e.name, e.version].join("-") : [n3, e.version].join("-");
}
function Ve4() {
  var e;
  const n3 = x2();
  return n3 === b2.browser ? [n3, ((e = (0, import_window_getters2.getLocation)()) == null ? void 0 : e.host) || "unknown"].join(":") : n3;
}
function Me4(e, n3, t) {
  const r = De3(), o2 = Ve4();
  return [[e, n3].join("-"), [_e2, t].join("-"), r, o2].join("/");
}
function qn({ protocol: e, version: n3, relayUrl: t, sdkVersion: r, auth: o2, projectId: s, useOnCloseEvent: i3 }) {
  const d5 = t.split("?"), l2 = Me4(e, n3, r), c3 = { auth: o2, ua: l2, projectId: s, useOnCloseEvent: i3 || void 0 }, u5 = Ce3(d5[1] || "", c3);
  return d5[0] + "?" + u5;
}
function O2(e, n3) {
  return e.filter((t) => n3.includes(t)).length === e.length;
}
function Wn(e) {
  return Object.fromEntries(e.entries());
}
function Yn2(e) {
  return new Map(Object.entries(e));
}
function Xn2(e = import_time4.FIVE_MINUTES, n3) {
  const t = (0, import_time4.toMiliseconds)(e || import_time4.FIVE_MINUTES);
  let r, o2, s;
  return { resolve: (i3) => {
    s && r && (clearTimeout(s), r(i3));
  }, reject: (i3) => {
    s && o2 && (clearTimeout(s), o2(i3));
  }, done: () => new Promise((i3, d5) => {
    s = setTimeout(() => {
      d5(new Error(n3));
    }, t), r = i3, o2 = d5;
  }) };
}
function et4(e, n3, t) {
  return new Promise(async (r, o2) => {
    const s = setTimeout(() => o2(new Error(t)), n3);
    try {
      const i3 = await e;
      r(i3);
    } catch (i3) {
      o2(i3);
    }
    clearTimeout(s);
  });
}
function ne4(e, n3) {
  if (typeof n3 == "string" && n3.startsWith(`${e}:`))
    return n3;
  if (e.toLowerCase() === "topic") {
    if (typeof n3 != "string")
      throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${n3}`;
  } else if (e.toLowerCase() === "id") {
    if (typeof n3 != "number")
      throw new Error('Value must be "number" for expirer target type: id');
    return `id:${n3}`;
  }
  throw new Error(`Unknown expirer target type: ${e}`);
}
function nt4(e) {
  return ne4("topic", e);
}
function tt4(e) {
  return ne4("id", e);
}
function rt4(e) {
  const [n3, t] = e.split(":"), r = { id: void 0, topic: void 0 };
  if (n3 === "topic" && typeof t == "string")
    r.topic = t;
  else if (n3 === "id" && Number.isInteger(Number(t)))
    r.id = Number(t);
  else
    throw new Error(`Invalid target, expected id:number or topic:string, got ${n3}:${t}`);
  return r;
}
function ot4(e, n3) {
  return (0, import_time4.fromMiliseconds)((n3 || Date.now()) + (0, import_time4.toMiliseconds)(e));
}
function st4(e) {
  return Date.now() >= (0, import_time4.toMiliseconds)(e);
}
function it4(e, n3) {
  return `${e}${n3 ? `:${n3}` : ""}`;
}
async function ct4({ id: e, topic: n3, wcDeepLink: t }) {
  try {
    if (!t)
      return;
    const r = typeof t == "string" ? JSON.parse(t) : t;
    let o2 = r == null ? void 0 : r.href;
    if (typeof o2 != "string")
      return;
    o2.endsWith("/") && (o2 = o2.slice(0, -1));
    const s = `${o2}/wc?requestId=${e}&sessionTopic=${n3}`, i3 = x2();
    i3 === b2.browser ? window.open(s, "_self", "noreferrer noopener") : i3 === b2.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(s);
  } catch (r) {
    console.error(r);
  }
}
var xe4 = "irn";
function at4(e) {
  return (e == null ? void 0 : e.relay) || { protocol: xe4 };
}
function ut4(e) {
  const n3 = RELAY_JSONRPC[e];
  if (typeof n3 > "u")
    throw new Error(`Relay Protocol not supported: ${e}`);
  return n3;
}
var dt4 = Object.defineProperty;
var Fe4 = Object.getOwnPropertySymbols;
var lt4 = Object.prototype.hasOwnProperty;
var ft4 = Object.prototype.propertyIsEnumerable;
var He4 = (e, n3, t) => n3 in e ? dt4(e, n3, { enumerable: true, configurable: true, writable: true, value: t }) : e[n3] = t;
var pt4 = (e, n3) => {
  for (var t in n3 || (n3 = {}))
    lt4.call(n3, t) && He4(e, t, n3[t]);
  if (Fe4)
    for (var t of Fe4(n3))
      ft4.call(n3, t) && He4(e, t, n3[t]);
  return e;
};
function qe3(e, n3 = "-") {
  const t = {}, r = "relay" + n3;
  return Object.keys(e).forEach((o2) => {
    if (o2.startsWith(r)) {
      const s = o2.replace(r, ""), i3 = e[o2];
      t[s] = i3;
    }
  }), t;
}
function mt3(e) {
  const n3 = e.indexOf(":"), t = e.indexOf("?") !== -1 ? e.indexOf("?") : void 0, r = e.substring(0, n3), o2 = e.substring(n3 + 1, t).split("@"), s = typeof t < "u" ? e.substring(t) : "", i3 = C3.parse(s);
  return { protocol: r, topic: ze4(o2[0]), version: parseInt(o2[1], 10), symKey: i3.symKey, relay: qe3(i3) };
}
function ze4(e) {
  return e.startsWith("//") ? e.substring(2) : e;
}
function Ge2(e, n3 = "-") {
  const t = "relay", r = {};
  return Object.keys(e).forEach((o2) => {
    const s = t + n3 + o2;
    e[o2] && (r[s] = e[o2]);
  }), r;
}
function yt3(e) {
  return `${e.protocol}:${e.topic}@${e.version}?` + C3.stringify(pt4({ symKey: e.symKey }, Ge2(e.relay)));
}
function R3(e) {
  const n3 = [];
  return e.forEach((t) => {
    const [r, o2] = t.split(":");
    n3.push(`${r}:${o2}`);
  }), n3;
}
function Ye3(e) {
  const n3 = [];
  return Object.values(e).forEach((t) => {
    n3.push(...R3(t.accounts));
  }), n3;
}
function Je2(e, n3) {
  const t = [];
  return Object.values(e).forEach((r) => {
    R3(r.accounts).includes(n3) && t.push(...r.methods);
  }), t;
}
function Qe3(e, n3) {
  const t = [];
  return Object.values(e).forEach((r) => {
    R3(r.accounts).includes(n3) && t.push(...r.events);
  }), t;
}
function St4(e, n3) {
  const t = sn(e, n3);
  if (t)
    throw new Error(t.message);
  const r = {};
  for (const [o2, s] of Object.entries(e))
    r[o2] = { methods: s.methods, events: s.events, chains: s.accounts.map((i3) => `${i3.split(":")[0]}:${i3.split(":")[1]}`) };
  return r;
}
var Pt3 = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
var Tt4 = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function N4(e, n3) {
  const { message: t, code: r } = Tt4[e];
  return { message: n3 ? `${t} ${n3}` : t, code: r };
}
function w(e, n3) {
  const { message: t, code: r } = Pt3[e];
  return { message: n3 ? `${t} ${n3}` : t, code: r };
}
function j3(e, n3) {
  return Array.isArray(e) ? typeof n3 < "u" && e.length ? e.every(n3) : true : false;
}
function F3(e) {
  return Object.getPrototypeOf(e) === Object.prototype && Object.keys(e).length;
}
function I2(e) {
  return typeof e > "u";
}
function m3(e, n3) {
  return n3 && I2(e) ? true : typeof e == "string" && !!e.trim().length;
}
function H3(e, n3) {
  return n3 && I2(e) ? true : typeof e == "number" && !isNaN(e);
}
function Rt4(e, n3) {
  const { requiredNamespaces: t } = n3, r = Object.keys(e.namespaces), o2 = Object.keys(t);
  let s = true;
  return O2(o2, r) ? (r.forEach((i3) => {
    const { accounts: d5, methods: l2, events: c3 } = e.namespaces[i3], u5 = R3(d5), a3 = t[i3];
    (!O2(V(i3, a3), u5) || !O2(a3.methods, l2) || !O2(a3.events, c3)) && (s = false);
  }), s) : false;
}
function q3(e) {
  return m3(e, false) && e.includes(":") ? e.split(":").length === 2 : false;
}
function Xe2(e) {
  if (m3(e, false) && e.includes(":")) {
    const n3 = e.split(":");
    if (n3.length === 3) {
      const t = n3[0] + ":" + n3[1];
      return !!n3[2] && q3(t);
    }
  }
  return false;
}
function wt3(e) {
  if (m3(e, false))
    try {
      return typeof new URL(e) < "u";
    } catch {
      return false;
    }
  return false;
}
function Ut3(e) {
  var n3;
  return (n3 = e == null ? void 0 : e.proposer) == null ? void 0 : n3.publicKey;
}
function At4(e) {
  return e == null ? void 0 : e.topic;
}
function _t3(e, n3) {
  let t = null;
  return m3(e == null ? void 0 : e.publicKey, false) || (t = N4("MISSING_OR_INVALID", `${n3} controller public key should be a string`)), t;
}
function oe3(e) {
  let n3 = true;
  return j3(e) ? e.length && (n3 = e.every((t) => m3(t, false))) : n3 = false, n3;
}
function en(e, n3, t) {
  let r = null;
  return j3(n3) ? n3.forEach((o2) => {
    r || (!q3(o2) || !o2.includes(e)) && (r = w("UNSUPPORTED_CHAINS", `${t}, chain ${o2} should be a string and conform to "namespace:chainId" format`));
  }) : r = w("UNSUPPORTED_CHAINS", `${t}, chains ${n3} should be an array of strings conforming to "namespace:chainId" format`), r;
}
function nn(e, n3) {
  let t = null;
  return Object.entries(e).forEach(([r, o2]) => {
    if (t)
      return;
    const s = en(r, V(r, o2), `${n3} requiredNamespace`);
    s && (t = s);
  }), t;
}
function tn(e, n3) {
  let t = null;
  return j3(e) ? e.forEach((r) => {
    t || Xe2(r) || (t = w("UNSUPPORTED_ACCOUNTS", `${n3}, account ${r} should be a string and conform to "namespace:chainId:address" format`));
  }) : t = w("UNSUPPORTED_ACCOUNTS", `${n3}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), t;
}
function rn(e, n3) {
  let t = null;
  return Object.values(e).forEach((r) => {
    if (t)
      return;
    const o2 = tn(r == null ? void 0 : r.accounts, `${n3} namespace`);
    o2 && (t = o2);
  }), t;
}
function on(e, n3) {
  let t = null;
  return oe3(e == null ? void 0 : e.methods) ? oe3(e == null ? void 0 : e.events) || (t = w("UNSUPPORTED_EVENTS", `${n3}, events should be an array of strings or empty array for no events`)) : t = w("UNSUPPORTED_METHODS", `${n3}, methods should be an array of strings or empty array for no methods`), t;
}
function se2(e, n3) {
  let t = null;
  return Object.values(e).forEach((r) => {
    if (t)
      return;
    const o2 = on(r, `${n3}, namespace`);
    o2 && (t = o2);
  }), t;
}
function $t3(e, n3, t) {
  let r = null;
  if (e && F3(e)) {
    const o2 = se2(e, n3);
    o2 && (r = o2);
    const s = nn(e, n3);
    s && (r = s);
  } else
    r = N4("MISSING_OR_INVALID", `${n3}, ${t} should be an object with data`);
  return r;
}
function sn(e, n3) {
  let t = null;
  if (e && F3(e)) {
    const r = se2(e, n3);
    r && (t = r);
    const o2 = rn(e, n3);
    o2 && (t = o2);
  } else
    t = N4("MISSING_OR_INVALID", `${n3}, namespaces should be an object with data`);
  return t;
}
function cn(e) {
  return m3(e.protocol, true);
}
function jt2(e, n3) {
  let t = false;
  return n3 && !e ? t = true : e && j3(e) && e.length && e.forEach((r) => {
    t = cn(r);
  }), t;
}
function Ct4(e) {
  return typeof e == "number";
}
function Dt3(e) {
  return typeof e < "u" && typeof e !== null;
}
function Vt2(e) {
  return !(!e || typeof e != "object" || !e.code || !H3(e.code, false) || !e.message || !m3(e.message, false));
}
function Mt3(e) {
  return !(I2(e) || !m3(e.method, false));
}
function Kt3(e) {
  return !(I2(e) || I2(e.result) && I2(e.error) || !H3(e.id, false) || !m3(e.jsonrpc, false));
}
function kt2(e) {
  return !(I2(e) || !m3(e.name, false));
}
function Lt3(e, n3) {
  return !(!q3(n3) || !Ye3(e).includes(n3));
}
function xt3(e, n3, t) {
  return m3(t, false) ? Je2(e, n3).includes(t) : false;
}
function Ft3(e, n3, t) {
  return m3(t, false) ? Qe3(e, n3).includes(t) : false;
}
function an(e, n3, t) {
  let r = null;
  const o2 = Ht3(e), s = qt2(n3), i3 = Object.keys(o2), d5 = Object.keys(s), l2 = un(Object.keys(e)), c3 = un(Object.keys(n3)), u5 = l2.filter((a3) => !c3.includes(a3));
  return u5.length && (r = N4("NON_CONFORMING_NAMESPACES", `${t} namespaces keys don't satisfy requiredNamespaces.
      Required: ${u5.toString()}
      Received: ${Object.keys(n3).toString()}`)), O2(i3, d5) || (r = N4("NON_CONFORMING_NAMESPACES", `${t} namespaces chains don't satisfy required namespaces.
      Required: ${i3.toString()}
      Approved: ${d5.toString()}`)), Object.keys(n3).forEach((a3) => {
    if (!a3.includes(":") || r)
      return;
    const g5 = R3(n3[a3].accounts);
    g5.includes(a3) || (r = N4("NON_CONFORMING_NAMESPACES", `${t} namespaces accounts don't satisfy namespace accounts for ${a3}
        Required: ${a3}
        Approved: ${g5.toString()}`));
  }), i3.forEach((a3) => {
    r || (O2(o2[a3].methods, s[a3].methods) ? O2(o2[a3].events, s[a3].events) || (r = N4("NON_CONFORMING_NAMESPACES", `${t} namespaces events don't satisfy namespace events for ${a3}`)) : r = N4("NON_CONFORMING_NAMESPACES", `${t} namespaces methods don't satisfy namespace methods for ${a3}`));
  }), r;
}
function Ht3(e) {
  const n3 = {};
  return Object.keys(e).forEach((t) => {
    var r;
    t.includes(":") ? n3[t] = e[t] : (r = e[t].chains) == null || r.forEach((o2) => {
      n3[o2] = { methods: e[t].methods, events: e[t].events };
    });
  }), n3;
}
function un(e) {
  return [...new Set(e.map((n3) => n3.includes(":") ? n3.split(":")[0] : n3))];
}
function qt2(e) {
  const n3 = {};
  return Object.keys(e).forEach((t) => {
    if (t.includes(":"))
      n3[t] = e[t];
    else {
      const r = R3(e[t].accounts);
      r == null ? void 0 : r.forEach((o2) => {
        n3[o2] = { accounts: e[t].accounts.filter((s) => s.includes(`${o2}:`)), methods: e[t].methods, events: e[t].events };
      });
    }
  }), n3;
}
function zt3(e, n3) {
  return H3(e, false) && e <= n3.max && e >= n3.min;
}

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/core/dist/index.es.js
var import_time5 = __toESM(require_cjs());
init_esm3();
var import_lodash2 = __toESM(require_lodash());
function Ui2(r, e) {
  if (r.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), i3 = 0; i3 < t.length; i3++)
    t[i3] = 255;
  for (var s = 0; s < r.length; s++) {
    var n3 = r.charAt(s), a3 = n3.charCodeAt(0);
    if (t[a3] !== 255)
      throw new TypeError(n3 + " is ambiguous");
    t[a3] = s;
  }
  var o2 = r.length, h3 = r.charAt(0), d5 = Math.log(o2) / Math.log(256), l2 = Math.log(256) / Math.log(o2);
  function D3(u5) {
    if (u5 instanceof Uint8Array || (ArrayBuffer.isView(u5) ? u5 = new Uint8Array(u5.buffer, u5.byteOffset, u5.byteLength) : Array.isArray(u5) && (u5 = Uint8Array.from(u5))), !(u5 instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (u5.length === 0)
      return "";
    for (var y4 = 0, A3 = 0, v = 0, R5 = u5.length; v !== R5 && u5[v] === 0; )
      v++, y4++;
    for (var S5 = (R5 - v) * l2 + 1 >>> 0, m5 = new Uint8Array(S5); v !== R5; ) {
      for (var T3 = u5[v], x4 = 0, I4 = S5 - 1; (T3 !== 0 || x4 < A3) && I4 !== -1; I4--, x4++)
        T3 += 256 * m5[I4] >>> 0, m5[I4] = T3 % o2 >>> 0, T3 = T3 / o2 >>> 0;
      if (T3 !== 0)
        throw new Error("Non-zero carry");
      A3 = x4, v++;
    }
    for (var P4 = S5 - A3; P4 !== S5 && m5[P4] === 0; )
      P4++;
    for (var K4 = h3.repeat(y4); P4 < S5; ++P4)
      K4 += r.charAt(m5[P4]);
    return K4;
  }
  function b5(u5) {
    if (typeof u5 != "string")
      throw new TypeError("Expected String");
    if (u5.length === 0)
      return new Uint8Array();
    var y4 = 0;
    if (u5[y4] !== " ") {
      for (var A3 = 0, v = 0; u5[y4] === h3; )
        A3++, y4++;
      for (var R5 = (u5.length - y4) * d5 + 1 >>> 0, S5 = new Uint8Array(R5); u5[y4]; ) {
        var m5 = t[u5.charCodeAt(y4)];
        if (m5 === 255)
          return;
        for (var T3 = 0, x4 = R5 - 1; (m5 !== 0 || T3 < v) && x4 !== -1; x4--, T3++)
          m5 += o2 * S5[x4] >>> 0, S5[x4] = m5 % 256 >>> 0, m5 = m5 / 256 >>> 0;
        if (m5 !== 0)
          throw new Error("Non-zero carry");
        v = T3, y4++;
      }
      if (u5[y4] !== " ") {
        for (var I4 = R5 - v; I4 !== R5 && S5[I4] === 0; )
          I4++;
        for (var P4 = new Uint8Array(A3 + (R5 - I4)), K4 = A3; I4 !== R5; )
          P4[K4++] = S5[I4++];
        return P4;
      }
    }
  }
  function H5(u5) {
    var y4 = b5(u5);
    if (y4)
      return y4;
    throw new Error(`Non-${e} character`);
  }
  return { encode: D3, decodeUnsafe: b5, decode: H5 };
}
var Li2 = Ui2;
var Fi2 = Li2;
var Pe4 = (r) => {
  if (r instanceof Uint8Array && r.constructor.name === "Uint8Array")
    return r;
  if (r instanceof ArrayBuffer)
    return new Uint8Array(r);
  if (ArrayBuffer.isView(r))
    return new Uint8Array(r.buffer, r.byteOffset, r.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var $i2 = (r) => new TextEncoder().encode(r);
var Mi2 = (r) => new TextDecoder().decode(r);
var Ki2 = class {
  constructor(e, t, i3) {
    this.name = e, this.prefix = t, this.baseEncode = i3;
  }
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var ki2 = class {
  constructor(e, t, i3) {
    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = i3;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e) {
    return Oe4(this, e);
  }
};
var Bi2 = class {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return Oe4(this, e);
  }
  decode(e) {
    const t = e[0], i3 = this.decoders[t];
    if (i3)
      return i3.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var Oe4 = (r, e) => new Bi2({ ...r.decoders || { [r.prefix]: r }, ...e.decoders || { [e.prefix]: e } });
var ji2 = class {
  constructor(e, t, i3, s) {
    this.name = e, this.prefix = t, this.baseEncode = i3, this.baseDecode = s, this.encoder = new Ki2(e, t, i3), this.decoder = new ki2(e, t, s);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
};
var q4 = ({ name: r, prefix: e, encode: t, decode: i3 }) => new ji2(r, e, t, i3);
var $5 = ({ prefix: r, name: e, alphabet: t }) => {
  const { encode: i3, decode: s } = Fi2(t, e);
  return q4({ prefix: r, name: e, encode: i3, decode: (n3) => Pe4(s(n3)) });
};
var Vi2 = (r, e, t, i3) => {
  const s = {};
  for (let l2 = 0; l2 < e.length; ++l2)
    s[e[l2]] = l2;
  let n3 = r.length;
  for (; r[n3 - 1] === "="; )
    --n3;
  const a3 = new Uint8Array(n3 * t / 8 | 0);
  let o2 = 0, h3 = 0, d5 = 0;
  for (let l2 = 0; l2 < n3; ++l2) {
    const D3 = s[r[l2]];
    if (D3 === void 0)
      throw new SyntaxError(`Non-${i3} character`);
    h3 = h3 << t | D3, o2 += t, o2 >= 8 && (o2 -= 8, a3[d5++] = 255 & h3 >> o2);
  }
  if (o2 >= t || 255 & h3 << 8 - o2)
    throw new SyntaxError("Unexpected end of data");
  return a3;
};
var qi2 = (r, e, t) => {
  const i3 = e[e.length - 1] === "=", s = (1 << t) - 1;
  let n3 = "", a3 = 0, o2 = 0;
  for (let h3 = 0; h3 < r.length; ++h3)
    for (o2 = o2 << 8 | r[h3], a3 += 8; a3 > t; )
      a3 -= t, n3 += e[s & o2 >> a3];
  if (a3 && (n3 += e[s & o2 << t - a3]), i3)
    for (; n3.length * t & 7; )
      n3 += "=";
  return n3;
};
var p4 = ({ name: r, prefix: e, bitsPerChar: t, alphabet: i3 }) => q4({ prefix: e, name: r, encode(s) {
  return qi2(s, i3, t);
}, decode(s) {
  return Vi2(s, i3, t, r);
} });
var Gi2 = q4({ prefix: "\0", name: "identity", encode: (r) => Mi2(r), decode: (r) => $i2(r) });
var Yi2 = Object.freeze({ __proto__: null, identity: Gi2 });
var Ji2 = p4({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var Hi2 = Object.freeze({ __proto__: null, base2: Ji2 });
var Wi2 = p4({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var Xi2 = Object.freeze({ __proto__: null, base8: Wi2 });
var Zi2 = $5({ prefix: "9", name: "base10", alphabet: "0123456789" });
var Qi2 = Object.freeze({ __proto__: null, base10: Zi2 });
var es2 = p4({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var ts2 = p4({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var is2 = Object.freeze({ __proto__: null, base16: es2, base16upper: ts2 });
var ss2 = p4({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var rs2 = p4({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var ns2 = p4({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var as2 = p4({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var os2 = p4({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var hs2 = p4({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var cs2 = p4({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var us2 = p4({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var ls2 = p4({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var ds2 = Object.freeze({ __proto__: null, base32: ss2, base32upper: rs2, base32pad: ns2, base32padupper: as2, base32hex: os2, base32hexupper: hs2, base32hexpad: cs2, base32hexpadupper: us2, base32z: ls2 });
var gs2 = $5({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var ps2 = $5({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var Ds2 = Object.freeze({ __proto__: null, base36: gs2, base36upper: ps2 });
var ys2 = $5({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var bs2 = $5({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var ms2 = Object.freeze({ __proto__: null, base58btc: ys2, base58flickr: bs2 });
var Es2 = p4({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var fs2 = p4({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var ws2 = p4({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var vs2 = p4({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Is2 = Object.freeze({ __proto__: null, base64: Es2, base64pad: fs2, base64url: ws2, base64urlpad: vs2 });
var xe5 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var Cs2 = xe5.reduce((r, e, t) => (r[t] = e, r), []);
var _s2 = xe5.reduce((r, e, t) => (r[e.codePointAt(0)] = t, r), []);
function Rs2(r) {
  return r.reduce((e, t) => (e += Cs2[t], e), "");
}
function Ss2(r) {
  const e = [];
  for (const t of r) {
    const i3 = _s2[t.codePointAt(0)];
    if (i3 === void 0)
      throw new Error(`Non-base256emoji character: ${t}`);
    e.push(i3);
  }
  return new Uint8Array(e);
}
var Ts2 = q4({ prefix: "\u{1F680}", name: "base256emoji", encode: Rs2, decode: Ss2 });
var Ps2 = Object.freeze({ __proto__: null, base256emoji: Ts2 });
var Os2 = ze5;
var Ae4 = 128;
var xs2 = 127;
var As2 = ~xs2;
var zs2 = Math.pow(2, 31);
function ze5(r, e, t) {
  e = e || [], t = t || 0;
  for (var i3 = t; r >= zs2; )
    e[t++] = r & 255 | Ae4, r /= 128;
  for (; r & As2; )
    e[t++] = r & 255 | Ae4, r >>>= 7;
  return e[t] = r | 0, ze5.bytes = t - i3 + 1, e;
}
var Ns2 = ne5;
var Us2 = 128;
var Ne2 = 127;
function ne5(r, i3) {
  var t = 0, i3 = i3 || 0, s = 0, n3 = i3, a3, o2 = r.length;
  do {
    if (n3 >= o2)
      throw ne5.bytes = 0, new RangeError("Could not decode varint");
    a3 = r[n3++], t += s < 28 ? (a3 & Ne2) << s : (a3 & Ne2) * Math.pow(2, s), s += 7;
  } while (a3 >= Us2);
  return ne5.bytes = n3 - i3, t;
}
var Ls2 = Math.pow(2, 7);
var Fs2 = Math.pow(2, 14);
var $s2 = Math.pow(2, 21);
var Ms2 = Math.pow(2, 28);
var Ks2 = Math.pow(2, 35);
var ks2 = Math.pow(2, 42);
var Bs2 = Math.pow(2, 49);
var js2 = Math.pow(2, 56);
var Vs2 = Math.pow(2, 63);
var qs2 = function(r) {
  return r < Ls2 ? 1 : r < Fs2 ? 2 : r < $s2 ? 3 : r < Ms2 ? 4 : r < Ks2 ? 5 : r < ks2 ? 6 : r < Bs2 ? 7 : r < js2 ? 8 : r < Vs2 ? 9 : 10;
};
var Gs2 = { encode: Os2, decode: Ns2, encodingLength: qs2 };
var Ue4 = Gs2;
var Le3 = (r, e, t = 0) => (Ue4.encode(r, e, t), e);
var Fe5 = (r) => Ue4.encodingLength(r);
var ae5 = (r, e) => {
  const t = e.byteLength, i3 = Fe5(r), s = i3 + Fe5(t), n3 = new Uint8Array(s + t);
  return Le3(r, n3, 0), Le3(t, n3, i3), n3.set(e, s), new Ys2(r, t, e, n3);
};
var Ys2 = class {
  constructor(e, t, i3, s) {
    this.code = e, this.size = t, this.digest = i3, this.bytes = s;
  }
};
var $e4 = ({ name: r, code: e, encode: t }) => new Js2(r, e, t);
var Js2 = class {
  constructor(e, t, i3) {
    this.name = e, this.code = t, this.encode = i3;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const t = this.encode(e);
      return t instanceof Uint8Array ? ae5(this.code, t) : t.then((i3) => ae5(this.code, i3));
    } else
      throw Error("Unknown type, must be binary type");
  }
};
var Me5 = (r) => async (e) => new Uint8Array(await crypto.subtle.digest(r, e));
var Hs2 = $e4({ name: "sha2-256", code: 18, encode: Me5("SHA-256") });
var Ws2 = $e4({ name: "sha2-512", code: 19, encode: Me5("SHA-512") });
var Xs2 = Object.freeze({ __proto__: null, sha256: Hs2, sha512: Ws2 });
var Ke3 = 0;
var Zs2 = "identity";
var ke2 = Pe4;
var Qs2 = (r) => ae5(Ke3, ke2(r));
var er3 = { code: Ke3, name: Zs2, encode: ke2, digest: Qs2 };
var tr3 = Object.freeze({ __proto__: null, identity: er3 });
new TextEncoder(), new TextDecoder();
var Be2 = { ...Yi2, ...Hi2, ...Xi2, ...Qi2, ...is2, ...ds2, ...Ds2, ...ms2, ...Is2, ...Ps2 };
({ ...Xs2, ...tr3 });
function je4(r) {
  return globalThis.Buffer != null ? new Uint8Array(r.buffer, r.byteOffset, r.byteLength) : r;
}
function ir2(r = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? je4(globalThis.Buffer.allocUnsafe(r)) : new Uint8Array(r);
}
function Ve5(r, e, t, i3) {
  return { name: r, prefix: e, encoder: { name: r, prefix: e, encode: t }, decoder: { decode: i3 } };
}
var qe4 = Ve5("utf8", "u", (r) => "u" + new TextDecoder("utf8").decode(r), (r) => new TextEncoder().encode(r.substring(1)));
var oe4 = Ve5("ascii", "a", (r) => {
  let e = "a";
  for (let t = 0; t < r.length; t++)
    e += String.fromCharCode(r[t]);
  return e;
}, (r) => {
  r = r.substring(1);
  const e = ir2(r.length);
  for (let t = 0; t < r.length; t++)
    e[t] = r.charCodeAt(t);
  return e;
});
var sr2 = { utf8: qe4, "utf-8": qe4, hex: Be2.base16, latin1: oe4, ascii: oe4, binary: oe4, ...Be2 };
function rr2(r, e = "utf8") {
  const t = sr2[e];
  if (!t)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? je4(globalThis.Buffer.from(r, "utf-8")) : t.decoder.decode(`${t.prefix}${r}`);
}
var he3 = "wc";
var Ge3 = 2;
var G4 = "core";
var O3 = `${he3}@2:${G4}:`;
var Ye4 = { name: G4, logger: "error" };
var Je3 = { database: ":memory:" };
var He5 = "crypto";
var ce5 = "client_ed25519_seed";
var We3 = import_time5.ONE_DAY;
var Xe3 = "keychain";
var Ze3 = "0.3";
var Qe4 = "messages";
var et5 = "0.3";
var tt5 = import_time5.SIX_HOURS;
var it5 = "publisher";
var st5 = "irn";
var rt5 = "error";
var ue5 = "wss://relay.walletconnect.com";
var nt5 = "relayer";
var g3 = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" };
var at5 = "_subscription";
var U4 = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" };
var ot5 = import_time5.ONE_SECOND / 2;
var ht3 = "2.8.0";
var ct5 = 1e4;
var ut5 = "0.3";
var lt5 = "WALLETCONNECT_CLIENT_ID";
var C4 = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" };
var dt5 = "subscription";
var gt3 = "0.3";
var pt5 = import_time5.FIVE_SECONDS * 1e3;
var Dt4 = "pairing";
var yt4 = "0.3";
var L2 = { wc_pairingDelete: { req: { ttl: import_time5.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: import_time5.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: import_time5.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: import_time5.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: import_time5.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: import_time5.ONE_DAY, prompt: false, tag: 0 } } };
var _2 = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" };
var bt3 = "history";
var mt4 = "0.3";
var Et3 = "expirer";
var w2 = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" };
var ft5 = "0.3";
var Y5 = "verify-api";
var le5 = "https://verify.walletconnect.com";
var wt4 = class {
  constructor(e, t) {
    this.core = e, this.logger = t, this.keychain = /* @__PURE__ */ new Map(), this.name = Xe3, this.version = Ze3, this.initialized = false, this.storagePrefix = O3, this.init = async () => {
      if (!this.initialized) {
        const i3 = await this.getKeyChain();
        typeof i3 < "u" && (this.keychain = i3), this.initialized = true;
      }
    }, this.has = (i3) => (this.isInitialized(), this.keychain.has(i3)), this.set = async (i3, s) => {
      this.isInitialized(), this.keychain.set(i3, s), await this.persist();
    }, this.get = (i3) => {
      this.isInitialized();
      const s = this.keychain.get(i3);
      if (typeof s > "u") {
        const { message: n3 } = N4("NO_MATCHING_KEY", `${this.name}: ${i3}`);
        throw new Error(n3);
      }
      return s;
    }, this.del = async (i3) => {
      this.isInitialized(), this.keychain.delete(i3), await this.persist();
    }, this.core = e, this.logger = (0, import_logger3.generateChildLogger)(t, this.name);
  }
  get context() {
    return (0, import_logger3.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, Wn(e));
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? Yn2(e) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N4("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var vt3 = class {
  constructor(e, t, i3) {
    this.core = e, this.logger = t, this.name = He5, this.initialized = false, this.init = async () => {
      this.initialized || (await this.keychain.init(), this.initialized = true);
    }, this.hasKeys = (s) => (this.isInitialized(), this.keychain.has(s)), this.getClientId = async () => {
      this.isInitialized();
      const s = await this.getClientSeed(), n3 = generateKeyPair(s);
      return encodeIss(n3.publicKey);
    }, this.generateKeyPair = () => {
      this.isInitialized();
      const s = wn2();
      return this.setPrivateKey(s.publicKey, s.privateKey);
    }, this.signJWT = async (s) => {
      this.isInitialized();
      const n3 = await this.getClientSeed(), a3 = generateKeyPair(n3), o2 = Un2(), h3 = We3;
      return await signJWT(o2, s, h3, a3);
    }, this.generateSharedKey = (s, n3, a3) => {
      this.isInitialized();
      const o2 = this.getPrivateKey(s), h3 = An2(o2, n3);
      return this.setSymKey(h3, a3);
    }, this.setSymKey = async (s, n3) => {
      this.isInitialized();
      const a3 = n3 || _n2(s);
      return await this.keychain.set(a3, s), a3;
    }, this.deleteKeyPair = async (s) => {
      this.isInitialized(), await this.keychain.del(s);
    }, this.deleteSymKey = async (s) => {
      this.isInitialized(), await this.keychain.del(s);
    }, this.encode = async (s, n3, a3) => {
      this.isInitialized();
      const o2 = Pe3(a3), h3 = safeJsonStringify(n3);
      if (Vn2(o2)) {
        const b5 = o2.senderPublicKey, H5 = o2.receiverPublicKey;
        s = await this.generateSharedKey(b5, H5);
      }
      const d5 = this.getSymKey(s), { type: l2, senderPublicKey: D3 } = o2;
      return jn2({ type: l2, symKey: d5, message: h3, senderPublicKey: D3 });
    }, this.decode = async (s, n3, a3) => {
      this.isInitialized();
      const o2 = Dn2(n3, a3);
      if (Vn2(o2)) {
        const l2 = o2.receiverPublicKey, D3 = o2.senderPublicKey;
        s = await this.generateSharedKey(l2, D3);
      }
      const h3 = this.getSymKey(s), d5 = Cn2({ symKey: h3, encoded: n3 });
      return safeJsonParse(d5);
    }, this.getPayloadType = (s) => {
      const n3 = Z2(s);
      return $4(n3.type);
    }, this.getPayloadSenderPublicKey = (s) => {
      const n3 = Z2(s);
      return n3.senderPublicKey ? toString(n3.senderPublicKey, f3) : void 0;
    }, this.core = e, this.logger = (0, import_logger3.generateChildLogger)(t, this.name), this.keychain = i3 || new wt4(this.core, this.logger);
  }
  get context() {
    return (0, import_logger3.getLoggerContext)(this.logger);
  }
  async setPrivateKey(e, t) {
    return await this.keychain.set(e, t), e;
  }
  getPrivateKey(e) {
    return this.keychain.get(e);
  }
  async getClientSeed() {
    let e = "";
    try {
      e = this.keychain.get(ce5);
    } catch {
      e = Un2(), await this.keychain.set(ce5, e);
    }
    return rr2(e, "base16");
  }
  getSymKey(e) {
    return this.keychain.get(e);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N4("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var It4 = class extends a2 {
  constructor(e, t) {
    super(e, t), this.logger = e, this.core = t, this.messages = /* @__PURE__ */ new Map(), this.name = Qe4, this.version = et5, this.initialized = false, this.storagePrefix = O3, this.init = async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const i3 = await this.getRelayerMessages();
          typeof i3 < "u" && (this.messages = i3), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (i3) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(i3);
        } finally {
          this.initialized = true;
        }
      }
    }, this.set = async (i3, s) => {
      this.isInitialized();
      const n3 = $n2(s);
      let a3 = this.messages.get(i3);
      return typeof a3 > "u" && (a3 = {}), typeof a3[n3] < "u" || (a3[n3] = s, this.messages.set(i3, a3), await this.persist()), n3;
    }, this.get = (i3) => {
      this.isInitialized();
      let s = this.messages.get(i3);
      return typeof s > "u" && (s = {}), s;
    }, this.has = (i3, s) => {
      this.isInitialized();
      const n3 = this.get(i3), a3 = $n2(s);
      return typeof n3[a3] < "u";
    }, this.del = async (i3) => {
      this.isInitialized(), this.messages.delete(i3), await this.persist();
    }, this.logger = (0, import_logger3.generateChildLogger)(e, this.name), this.core = t;
  }
  get context() {
    return (0, import_logger3.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, Wn(e));
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? Yn2(e) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N4("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var cr3 = class extends u2 {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, this.events = new import_events8.EventEmitter(), this.name = it5, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = 1e4, this.publish = async (i3, s, n3) => {
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i3, message: s, opts: n3 } });
      try {
        const a3 = (n3 == null ? void 0 : n3.ttl) || tt5, o2 = at4(n3), h3 = (n3 == null ? void 0 : n3.prompt) || false, d5 = (n3 == null ? void 0 : n3.tag) || 0, l2 = (n3 == null ? void 0 : n3.id) || getBigIntRpcId().toString(), D3 = { topic: i3, message: s, opts: { ttl: a3, relay: o2, prompt: h3, tag: d5, id: l2 } };
        this.queue.set(l2, D3);
        try {
          await await et4(this.rpcPublish(i3, s, a3, o2, h3, d5, l2), this.publishTimeout), this.relayer.events.emit(g3.publish, D3);
        } catch {
          this.logger.debug("Publishing Payload stalled"), this.relayer.events.emit(g3.connection_stalled);
          return;
        }
        this.logger.debug("Successfully Published Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i3, message: s, opts: n3 } });
      } catch (a3) {
        throw this.logger.debug("Failed to Publish Payload"), this.logger.error(a3), a3;
      }
    }, this.on = (i3, s) => {
      this.events.on(i3, s);
    }, this.once = (i3, s) => {
      this.events.once(i3, s);
    }, this.off = (i3, s) => {
      this.events.off(i3, s);
    }, this.removeListener = (i3, s) => {
      this.events.removeListener(i3, s);
    }, this.relayer = e, this.logger = (0, import_logger3.generateChildLogger)(t, this.name), this.registerEventListeners();
  }
  get context() {
    return (0, import_logger3.getLoggerContext)(this.logger);
  }
  rpcPublish(e, t, i3, s, n3, a3, o2) {
    var h3, d5, l2, D3;
    const b5 = { method: ut4(s.protocol).publish, params: { topic: e, message: t, ttl: i3, prompt: n3, tag: a3 }, id: o2 };
    return I2((h3 = b5.params) == null ? void 0 : h3.prompt) && ((d5 = b5.params) == null || delete d5.prompt), I2((l2 = b5.params) == null ? void 0 : l2.tag) && ((D3 = b5.params) == null || delete D3.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: b5 }), this.relayer.request(b5);
  }
  onPublish(e) {
    this.queue.delete(e);
  }
  checkQueue() {
    this.queue.forEach(async (e) => {
      const { topic: t, message: i3, opts: s } = e;
      await this.publish(t, i3, s);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(import_heartbeat2.HEARTBEAT_EVENTS.pulse, () => {
      this.checkQueue();
    }), this.relayer.on(g3.message_ack, (e) => {
      this.onPublish(e.id.toString());
    });
  }
};
var ur3 = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map(), this.set = (e, t) => {
      const i3 = this.get(e);
      this.exists(e, t) || this.map.set(e, [...i3, t]);
    }, this.get = (e) => this.map.get(e) || [], this.exists = (e, t) => this.get(e).includes(t), this.delete = (e, t) => {
      if (typeof t > "u") {
        this.map.delete(e);
        return;
      }
      if (!this.map.has(e))
        return;
      const i3 = this.get(e);
      if (!this.exists(e, t))
        return;
      const s = i3.filter((n3) => n3 !== t);
      if (!s.length) {
        this.map.delete(e);
        return;
      }
      this.map.set(e, s);
    }, this.clear = () => {
      this.map.clear();
    };
  }
  get topics() {
    return Array.from(this.map.keys());
  }
};
var lr3 = Object.defineProperty;
var dr3 = Object.defineProperties;
var gr3 = Object.getOwnPropertyDescriptors;
var Ct5 = Object.getOwnPropertySymbols;
var pr3 = Object.prototype.hasOwnProperty;
var Dr3 = Object.prototype.propertyIsEnumerable;
var _t4 = (r, e, t) => e in r ? lr3(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var M3 = (r, e) => {
  for (var t in e || (e = {}))
    pr3.call(e, t) && _t4(r, t, e[t]);
  if (Ct5)
    for (var t of Ct5(e))
      Dr3.call(e, t) && _t4(r, t, e[t]);
  return r;
};
var de3 = (r, e) => dr3(r, gr3(e));
var Rt5 = class extends d3 {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new ur3(), this.events = new import_events8.EventEmitter(), this.name = dt5, this.version = gt3, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = false, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = O3, this.subscribeTimeout = 1e4, this.restartInProgress = false, this.batchSubscribeTopicsLimit = 500, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restart(), this.registerEventListeners(), this.onEnable(), this.clientId = await this.relayer.core.crypto.getClientId());
    }, this.subscribe = async (i3, s) => {
      await this.restartToComplete(), this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i3, opts: s } });
      try {
        const n3 = at4(s), a3 = { topic: i3, relay: n3 };
        this.pending.set(i3, a3);
        const o2 = await this.rpcSubscribe(i3, n3);
        return this.onSubscribe(o2, a3), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i3, opts: s } }), o2;
      } catch (n3) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(n3), n3;
      }
    }, this.unsubscribe = async (i3, s) => {
      await this.restartToComplete(), this.isInitialized(), typeof (s == null ? void 0 : s.id) < "u" ? await this.unsubscribeById(i3, s.id, s) : await this.unsubscribeByTopic(i3, s);
    }, this.isSubscribed = async (i3) => this.topics.includes(i3) ? true : await new Promise((s, n3) => {
      const a3 = new import_time5.Watch();
      a3.start(this.pendingSubscriptionWatchLabel);
      const o2 = setInterval(() => {
        !this.pending.has(i3) && this.topics.includes(i3) && (clearInterval(o2), a3.stop(this.pendingSubscriptionWatchLabel), s(true)), a3.elapsed(this.pendingSubscriptionWatchLabel) >= pt5 && (clearInterval(o2), a3.stop(this.pendingSubscriptionWatchLabel), n3(new Error("Subscription resolution timeout")));
      }, this.pollingInterval);
    }).catch(() => false), this.on = (i3, s) => {
      this.events.on(i3, s);
    }, this.once = (i3, s) => {
      this.events.once(i3, s);
    }, this.off = (i3, s) => {
      this.events.off(i3, s);
    }, this.removeListener = (i3, s) => {
      this.events.removeListener(i3, s);
    }, this.restart = async () => {
      this.restartInProgress = true, await this.restore(), await this.reset(), this.restartInProgress = false;
    }, this.relayer = e, this.logger = (0, import_logger3.generateChildLogger)(t, this.name), this.clientId = "";
  }
  get context() {
    return (0, import_logger3.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  hasSubscription(e, t) {
    let i3 = false;
    try {
      i3 = this.getSubscription(e).topic === t;
    } catch {
    }
    return i3;
  }
  onEnable() {
    this.cached = [], this.initialized = true;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e, t) {
    const i3 = this.topicMap.get(e);
    await Promise.all(i3.map(async (s) => await this.unsubscribeById(e, s, t)));
  }
  async unsubscribeById(e, t, i3) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: i3 } });
    try {
      const s = at4(i3);
      await this.rpcUnsubscribe(e, t, s);
      const n3 = w("USER_DISCONNECTED", `${this.name}, ${e}`);
      await this.onUnsubscribe(e, t, n3), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: i3 } });
    } catch (s) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(s), s;
    }
  }
  async rpcSubscribe(e, t) {
    const i3 = { method: ut4(t.protocol).subscribe, params: { topic: e } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i3 });
    try {
      await await et4(this.relayer.request(i3), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(g3.connection_stalled);
    }
    return $n2(e + this.clientId);
  }
  async rpcBatchSubscribe(e) {
    if (!e.length)
      return;
    const t = e[0].relay, i3 = { method: ut4(t.protocol).batchSubscribe, params: { topics: e.map((s) => s.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i3 });
    try {
      return await await et4(this.relayer.request(i3), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Payload stalled"), this.relayer.events.emit(g3.connection_stalled);
    }
  }
  rpcUnsubscribe(e, t, i3) {
    const s = { method: ut4(i3.protocol).unsubscribe, params: { topic: e, id: t } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s }), this.relayer.request(s);
  }
  onSubscribe(e, t) {
    this.setSubscription(e, de3(M3({}, t), { id: e })), this.pending.delete(t.topic);
  }
  onBatchSubscribe(e) {
    e.length && e.forEach((t) => {
      this.setSubscription(t.id, M3({}, t)), this.pending.delete(t.topic);
    });
  }
  async onUnsubscribe(e, t, i3) {
    this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, i3), await this.relayer.messages.del(e);
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e, t) {
    this.subscriptions.has(e) || (this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e, subscription: t }), this.addSubscription(e, t));
  }
  addSubscription(e, t) {
    this.subscriptions.set(e, M3({}, t)), this.topicMap.set(t.topic, e), this.events.emit(C4.created, t);
  }
  getSubscription(e) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e });
    const t = this.subscriptions.get(e);
    if (!t) {
      const { message: i3 } = N4("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(i3);
    }
    return t;
  }
  deleteSubscription(e, t) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e, reason: t });
    const i3 = this.getSubscription(e);
    this.subscriptions.delete(e), this.topicMap.delete(i3.topic, e), this.events.emit(C4.deleted, de3(M3({}, i3), { reason: t }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(C4.sync);
  }
  async reset() {
    if (this.cached.length) {
      const e = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let t = 0; t < e; t++) {
        const i3 = this.cached.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(i3);
      }
    }
    this.events.emit(C4.resubscribed);
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions();
      if (typeof e > "u" || !e.length)
        return;
      if (this.subscriptions.size) {
        const { message: t } = N4("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);
    }
  }
  async batchSubscribe(e) {
    if (!e.length)
      return;
    const t = await this.rpcBatchSubscribe(e);
    j3(t) && this.onBatchSubscribe(t.map((i3, s) => de3(M3({}, e[s]), { id: i3 })));
  }
  async onConnect() {
    this.restartInProgress || (await this.restart(), this.onEnable());
  }
  onDisconnect() {
    this.onDisable();
  }
  async checkPending() {
    if (this.relayer.transportExplicitlyClosed)
      return;
    const e = [];
    this.pending.forEach((t) => {
      e.push(t);
    }), await this.batchSubscribe(e);
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(import_heartbeat2.HEARTBEAT_EVENTS.pulse, async () => {
      await this.checkPending();
    }), this.relayer.on(g3.connect, async () => {
      await this.onConnect();
    }), this.relayer.on(g3.disconnect, () => {
      this.onDisconnect();
    }), this.events.on(C4.created, async (e) => {
      const t = C4.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), await this.persist();
    }), this.events.on(C4.deleted, async (e) => {
      const t = C4.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), await this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N4("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async restartToComplete() {
    this.restartInProgress && await new Promise((e) => {
      const t = setInterval(() => {
        this.restartInProgress || (clearInterval(t), e());
      }, this.pollingInterval);
    });
  }
};
var yr3 = Object.defineProperty;
var St5 = Object.getOwnPropertySymbols;
var br3 = Object.prototype.hasOwnProperty;
var mr3 = Object.prototype.propertyIsEnumerable;
var Tt5 = (r, e, t) => e in r ? yr3(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var Er3 = (r, e) => {
  for (var t in e || (e = {}))
    br3.call(e, t) && Tt5(r, t, e[t]);
  if (St5)
    for (var t of St5(e))
      mr3.call(e, t) && Tt5(r, t, e[t]);
  return r;
};
var Pt4 = class extends g2 {
  constructor(e) {
    super(e), this.protocol = "wc", this.version = 2, this.events = new import_events8.EventEmitter(), this.name = nt5, this.transportExplicitlyClosed = false, this.initialized = false, this.reconnecting = false, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "socket stalled"], this.request = async (t) => {
      this.logger.debug("Publishing Request Payload");
      try {
        return await this.toEstablishConnection(), await this.provider.request(t);
      } catch (i3) {
        throw this.logger.debug("Failed to Publish Request"), this.logger.error(i3), i3;
      }
    }, this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? (0, import_logger3.generateChildLogger)(e.logger, this.name) : (0, import_logger3.pino)((0, import_logger3.getDefaultLoggerOptions)({ level: e.logger || rt5 })), this.messages = new It4(this.logger, e.core), this.subscriber = new Rt5(this, this.logger), this.publisher = new cr3(this, this.logger), this.relayUrl = (e == null ? void 0 : e.relayUrl) || ue5, this.projectId = e.projectId, this.provider = {};
  }
  async init() {
    this.logger.trace("Initialized"), await this.createProvider(), await Promise.all([this.messages.init(), this.transportOpen(), this.subscriber.init()]), this.registerEventListeners(), this.initialized = true, setTimeout(async () => {
      this.subscriber.topics.length === 0 && (this.logger.info("No topics subscribted to after init, closing transport"), await this.transportClose(), this.transportExplicitlyClosed = false);
    }, ct5);
  }
  get context() {
    return (0, import_logger3.getLoggerContext)(this.logger);
  }
  get connected() {
    return this.provider.connection.connected;
  }
  get connecting() {
    return this.provider.connection.connecting;
  }
  async publish(e, t, i3) {
    this.isInitialized(), await this.publisher.publish(e, t, i3), await this.recordMessageEvent({ topic: e, message: t, publishedAt: Date.now() });
  }
  async subscribe(e, t) {
    var i3;
    this.isInitialized();
    let s = ((i3 = this.subscriber.topicMap.get(e)) == null ? void 0 : i3[0]) || "";
    return s || (await Promise.all([new Promise((n3) => {
      this.subscriber.once(C4.created, (a3) => {
        a3.topic === e && n3();
      });
    }), new Promise(async (n3) => {
      s = await this.subscriber.subscribe(e, t), n3();
    })]), s);
  }
  async unsubscribe(e, t) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, t);
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async transportClose() {
    this.transportExplicitlyClosed = true, this.connected && (await this.provider.disconnect(), this.events.emit(g3.transport_closed));
  }
  async transportOpen(e) {
    if (this.transportExplicitlyClosed = false, !this.reconnecting) {
      this.relayUrl = e || this.relayUrl, this.reconnecting = true;
      try {
        await Promise.all([new Promise((t) => {
          this.initialized || t(), this.subscriber.once(C4.resubscribed, () => {
            t();
          });
        }), await Promise.race([new Promise(async (t, i3) => {
          await et4(this.provider.connect(), 5e3, "socket stalled").catch((s) => i3(s)).then(() => t()).finally(() => this.removeListener(g3.transport_closed, this.rejectTransportOpen));
        }), new Promise((t) => this.once(g3.transport_closed, this.rejectTransportOpen))])]);
      } catch (t) {
        this.logger.error(t);
        const i3 = t;
        if (!this.isConnectionStalled(i3.message))
          throw t;
        this.events.emit(g3.transport_closed);
      } finally {
        this.reconnecting = false;
      }
    }
  }
  async restartTransport(e) {
    this.transportExplicitlyClosed || this.reconnecting || (this.relayUrl = e || this.relayUrl, this.connected && await Promise.all([new Promise((t) => {
      this.provider.once(U4.disconnect, () => {
        t();
      });
    }), this.transportClose()]), await this.createProvider(), await this.transportOpen());
  }
  isConnectionStalled(e) {
    return this.staleConnectionErrors.some((t) => e.includes(t));
  }
  rejectTransportOpen() {
    throw new Error("closeTransport called before connection was established");
  }
  async createProvider() {
    const e = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new JsonRpcProvider(new esm_default(qn({ sdkVersion: ht3, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: true }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e) {
    const { topic: t, message: i3 } = e;
    await this.messages.set(t, i3);
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: t, message: i3 } = e;
    return await this.subscriber.isSubscribed(t) ? this.messages.has(t, i3) : true;
  }
  async onProviderPayload(e) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e }), isJsonRpcRequest(e)) {
      if (!e.method.endsWith(at5))
        return;
      const t = e.params, { topic: i3, message: s, publishedAt: n3 } = t.data, a3 = { topic: i3, message: s, publishedAt: n3 };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(Er3({ type: "event", event: t.id }, a3)), this.events.emit(t.id, a3), await this.acknowledgePayload(e), await this.onMessageEvent(a3);
    } else
      isJsonRpcResponse(e) && this.events.emit(g3.message_ack, e);
  }
  async onMessageEvent(e) {
    await this.shouldIgnoreMessageEvent(e) || (this.events.emit(g3.message, e), await this.recordMessageEvent(e));
  }
  async acknowledgePayload(e) {
    const t = formatJsonRpcResult(e.id, true);
    await this.provider.connection.send(t);
  }
  registerProviderListeners() {
    this.provider.on(U4.payload, (e) => this.onProviderPayload(e)), this.provider.on(U4.connect, () => {
      this.events.emit(g3.connect);
    }), this.provider.on(U4.disconnect, () => {
      this.onProviderDisconnect();
    }), this.provider.on(U4.error, (e) => {
      this.logger.error(e), this.events.emit(g3.error, e);
    });
  }
  registerEventListeners() {
    this.events.on(g3.connection_stalled, async () => {
      await this.restartTransport();
    });
  }
  onProviderDisconnect() {
    this.events.emit(g3.disconnect), this.attemptToReconnect();
  }
  attemptToReconnect() {
    this.transportExplicitlyClosed || setTimeout(async () => {
      await this.restartTransport();
    }, (0, import_time5.toMiliseconds)(ot5));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N4("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async toEstablishConnection() {
    if (!this.connected) {
      if (this.connecting)
        return await new Promise((e) => {
          const t = setInterval(() => {
            this.connected && (clearInterval(t), e());
          }, this.connectionStatusPollingInterval);
        });
      await this.restartTransport();
    }
  }
};
var fr3 = Object.defineProperty;
var Ot3 = Object.getOwnPropertySymbols;
var wr3 = Object.prototype.hasOwnProperty;
var vr3 = Object.prototype.propertyIsEnumerable;
var xt4 = (r, e, t) => e in r ? fr3(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var At5 = (r, e) => {
  for (var t in e || (e = {}))
    wr3.call(e, t) && xt4(r, t, e[t]);
  if (Ot3)
    for (var t of Ot3(e))
      vr3.call(e, t) && xt4(r, t, e[t]);
  return r;
};
var zt4 = class extends p3 {
  constructor(e, t, i3, s = O3, n3 = void 0) {
    super(e, t, i3, s), this.core = e, this.logger = t, this.name = i3, this.map = /* @__PURE__ */ new Map(), this.version = ut5, this.cached = [], this.initialized = false, this.storagePrefix = O3, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((a3) => {
        this.getKey && a3 !== null && !I2(a3) ? this.map.set(this.getKey(a3), a3) : Ut3(a3) ? this.map.set(a3.id, a3) : At4(a3) && this.map.set(a3.topic, a3);
      }), this.cached = [], this.initialized = true);
    }, this.set = async (a3, o2) => {
      this.isInitialized(), this.map.has(a3) ? await this.update(a3, o2) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: a3, value: o2 }), this.map.set(a3, o2), await this.persist());
    }, this.get = (a3) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: a3 }), this.getData(a3)), this.getAll = (a3) => (this.isInitialized(), a3 ? this.values.filter((o2) => Object.keys(a3).every((h3) => (0, import_lodash2.default)(o2[h3], a3[h3]))) : this.values), this.update = async (a3, o2) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: a3, update: o2 });
      const h3 = At5(At5({}, this.getData(a3)), o2);
      this.map.set(a3, h3), await this.persist();
    }, this.delete = async (a3, o2) => {
      this.isInitialized(), this.map.has(a3) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: a3, reason: o2 }), this.map.delete(a3), await this.persist());
    }, this.logger = (0, import_logger3.generateChildLogger)(t, this.name), this.storagePrefix = s, this.getKey = n3;
  }
  get context() {
    return (0, import_logger3.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e) {
    const t = this.map.get(e);
    if (!t) {
      const { message: i3 } = N4("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(i3), new Error(i3);
    }
    return t;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e = await this.getDataStore();
      if (typeof e > "u" || !e.length)
        return;
      if (this.map.size) {
        const { message: t } = N4("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N4("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Nt3 = class {
  constructor(e, t) {
    this.core = e, this.logger = t, this.name = Dt4, this.version = yt4, this.events = new import_events8.default(), this.initialized = false, this.storagePrefix = O3, this.ignoredPayloadTypes = [A2], this.registeredMethods = [], this.init = async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
    }, this.register = ({ methods: i3 }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...i3])];
    }, this.create = async () => {
      this.isInitialized();
      const i3 = Un2(), s = await this.core.crypto.setSymKey(i3), n3 = ot4(import_time5.FIVE_MINUTES), a3 = { protocol: st5 }, o2 = { topic: s, expiry: n3, relay: a3, active: false }, h3 = yt3({ protocol: this.core.protocol, version: this.core.version, topic: s, symKey: i3, relay: a3 });
      return await this.pairings.set(s, o2), await this.core.relayer.subscribe(s), this.core.expirer.set(s, n3), { topic: s, uri: h3 };
    }, this.pair = async (i3) => {
      this.isInitialized(), this.isValidPair(i3);
      const { topic: s, symKey: n3, relay: a3 } = mt3(i3.uri);
      if (this.pairings.keys.includes(s))
        throw new Error(`Pairing already exists: ${s}`);
      if (this.core.crypto.hasKeys(s))
        throw new Error(`Keychain already exists: ${s}`);
      const o2 = ot4(import_time5.FIVE_MINUTES), h3 = { topic: s, relay: a3, expiry: o2, active: false };
      return await this.pairings.set(s, h3), await this.core.crypto.setSymKey(n3, s), await this.core.relayer.subscribe(s, { relay: a3 }), this.core.expirer.set(s, o2), i3.activatePairing && await this.activate({ topic: s }), h3;
    }, this.activate = async ({ topic: i3 }) => {
      this.isInitialized();
      const s = ot4(import_time5.THIRTY_DAYS);
      await this.pairings.update(i3, { active: true, expiry: s }), this.core.expirer.set(i3, s);
    }, this.ping = async (i3) => {
      this.isInitialized(), await this.isValidPing(i3);
      const { topic: s } = i3;
      if (this.pairings.keys.includes(s)) {
        const n3 = await this.sendRequest(s, "wc_pairingPing", {}), { done: a3, resolve: o2, reject: h3 } = Xn2();
        this.events.once(it4("pairing_ping", n3), ({ error: d5 }) => {
          d5 ? h3(d5) : o2();
        }), await a3();
      }
    }, this.updateExpiry = async ({ topic: i3, expiry: s }) => {
      this.isInitialized(), await this.pairings.update(i3, { expiry: s });
    }, this.updateMetadata = async ({ topic: i3, metadata: s }) => {
      this.isInitialized(), await this.pairings.update(i3, { peerMetadata: s });
    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (i3) => {
      this.isInitialized(), await this.isValidDisconnect(i3);
      const { topic: s } = i3;
      this.pairings.keys.includes(s) && (await this.sendRequest(s, "wc_pairingDelete", w("USER_DISCONNECTED")), await this.deletePairing(s));
    }, this.sendRequest = async (i3, s, n3) => {
      const a3 = formatJsonRpcRequest(s, n3), o2 = await this.core.crypto.encode(i3, a3), h3 = L2[s].req;
      return this.core.history.set(i3, a3), this.core.relayer.publish(i3, o2, h3), a3.id;
    }, this.sendResult = async (i3, s, n3) => {
      const a3 = formatJsonRpcResult(i3, n3), o2 = await this.core.crypto.encode(s, a3), h3 = await this.core.history.get(s, i3), d5 = L2[h3.request.method].res;
      await this.core.relayer.publish(s, o2, d5), await this.core.history.resolve(a3);
    }, this.sendError = async (i3, s, n3) => {
      const a3 = formatJsonRpcError(i3, n3), o2 = await this.core.crypto.encode(s, a3), h3 = await this.core.history.get(s, i3), d5 = L2[h3.request.method] ? L2[h3.request.method].res : L2.unregistered_method.res;
      await this.core.relayer.publish(s, o2, d5), await this.core.history.resolve(a3);
    }, this.deletePairing = async (i3, s) => {
      await this.core.relayer.unsubscribe(i3), await Promise.all([this.pairings.delete(i3, w("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(i3), s ? Promise.resolve() : this.core.expirer.del(i3)]);
    }, this.cleanup = async () => {
      const i3 = this.pairings.getAll().filter((s) => st4(s.expiry));
      await Promise.all(i3.map((s) => this.deletePairing(s.topic)));
    }, this.onRelayEventRequest = (i3) => {
      const { topic: s, payload: n3 } = i3, a3 = n3.method;
      if (this.pairings.keys.includes(s))
        switch (a3) {
          case "wc_pairingPing":
            return this.onPairingPingRequest(s, n3);
          case "wc_pairingDelete":
            return this.onPairingDeleteRequest(s, n3);
          default:
            return this.onUnknownRpcMethodRequest(s, n3);
        }
    }, this.onRelayEventResponse = async (i3) => {
      const { topic: s, payload: n3 } = i3, a3 = (await this.core.history.get(s, n3.id)).request.method;
      if (this.pairings.keys.includes(s))
        switch (a3) {
          case "wc_pairingPing":
            return this.onPairingPingResponse(s, n3);
          default:
            return this.onUnknownRpcMethodResponse(a3);
        }
    }, this.onPairingPingRequest = async (i3, s) => {
      const { id: n3 } = s;
      try {
        this.isValidPing({ topic: i3 }), await this.sendResult(n3, i3, true), this.events.emit("pairing_ping", { id: n3, topic: i3 });
      } catch (a3) {
        await this.sendError(n3, i3, a3), this.logger.error(a3);
      }
    }, this.onPairingPingResponse = (i3, s) => {
      const { id: n3 } = s;
      setTimeout(() => {
        isJsonRpcResult(s) ? this.events.emit(it4("pairing_ping", n3), {}) : isJsonRpcError(s) && this.events.emit(it4("pairing_ping", n3), { error: s.error });
      }, 500);
    }, this.onPairingDeleteRequest = async (i3, s) => {
      const { id: n3 } = s;
      try {
        this.isValidDisconnect({ topic: i3 }), await this.deletePairing(i3), this.events.emit("pairing_delete", { id: n3, topic: i3 });
      } catch (a3) {
        await this.sendError(n3, i3, a3), this.logger.error(a3);
      }
    }, this.onUnknownRpcMethodRequest = async (i3, s) => {
      const { id: n3, method: a3 } = s;
      try {
        if (this.registeredMethods.includes(a3))
          return;
        const o2 = w("WC_METHOD_UNSUPPORTED", a3);
        await this.sendError(n3, i3, o2), this.logger.error(o2);
      } catch (o2) {
        await this.sendError(n3, i3, o2), this.logger.error(o2);
      }
    }, this.onUnknownRpcMethodResponse = (i3) => {
      this.registeredMethods.includes(i3) || this.logger.error(w("WC_METHOD_UNSUPPORTED", i3));
    }, this.isValidPair = (i3) => {
      if (!Dt3(i3)) {
        const { message: s } = N4("MISSING_OR_INVALID", `pair() params: ${i3}`);
        throw new Error(s);
      }
      if (!wt3(i3.uri)) {
        const { message: s } = N4("MISSING_OR_INVALID", `pair() uri: ${i3.uri}`);
        throw new Error(s);
      }
    }, this.isValidPing = async (i3) => {
      if (!Dt3(i3)) {
        const { message: n3 } = N4("MISSING_OR_INVALID", `ping() params: ${i3}`);
        throw new Error(n3);
      }
      const { topic: s } = i3;
      await this.isValidPairingTopic(s);
    }, this.isValidDisconnect = async (i3) => {
      if (!Dt3(i3)) {
        const { message: n3 } = N4("MISSING_OR_INVALID", `disconnect() params: ${i3}`);
        throw new Error(n3);
      }
      const { topic: s } = i3;
      await this.isValidPairingTopic(s);
    }, this.isValidPairingTopic = async (i3) => {
      if (!m3(i3, false)) {
        const { message: s } = N4("MISSING_OR_INVALID", `pairing topic should be a string: ${i3}`);
        throw new Error(s);
      }
      if (!this.pairings.keys.includes(i3)) {
        const { message: s } = N4("NO_MATCHING_KEY", `pairing topic doesn't exist: ${i3}`);
        throw new Error(s);
      }
      if (st4(this.pairings.get(i3).expiry)) {
        await this.deletePairing(i3);
        const { message: s } = N4("EXPIRED", `pairing topic: ${i3}`);
        throw new Error(s);
      }
    }, this.core = e, this.logger = (0, import_logger3.generateChildLogger)(t, this.name), this.pairings = new zt4(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return (0, import_logger3.getLoggerContext)(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N4("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(g3.message, async (e) => {
      const { topic: t, message: i3 } = e;
      if (this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i3)))
        return;
      const s = await this.core.crypto.decode(t, i3);
      isJsonRpcRequest(s) ? (this.core.history.set(t, s), this.onRelayEventRequest({ topic: t, payload: s })) : isJsonRpcResponse(s) && (await this.core.history.resolve(s), this.onRelayEventResponse({ topic: t, payload: s }));
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(w2.expired, async (e) => {
      const { topic: t } = rt4(e.target);
      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, true), this.events.emit("pairing_expire", { topic: t }));
    });
  }
};
var Ut4 = class extends h2 {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, this.records = /* @__PURE__ */ new Map(), this.events = new import_events8.EventEmitter(), this.name = bt3, this.version = mt4, this.cached = [], this.initialized = false, this.storagePrefix = O3, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i3) => this.records.set(i3.id, i3)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.set = (i3, s, n3) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: i3, request: s, chainId: n3 }), this.records.has(s.id))
        return;
      const a3 = { id: s.id, topic: i3, request: { method: s.method, params: s.params || null }, chainId: n3 };
      this.records.set(a3.id, a3), this.events.emit(_2.created, a3);
    }, this.resolve = async (i3) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: i3 }), !this.records.has(i3.id))
        return;
      const s = await this.getRecord(i3.id);
      typeof s.response > "u" && (s.response = isJsonRpcError(i3) ? { error: i3.error } : { result: i3.result }, this.records.set(s.id, s), this.events.emit(_2.updated, s));
    }, this.get = async (i3, s) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: i3, id: s }), await this.getRecord(s)), this.delete = (i3, s) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: s }), this.values.forEach((n3) => {
        if (n3.topic === i3) {
          if (typeof s < "u" && n3.id !== s)
            return;
          this.records.delete(n3.id), this.events.emit(_2.deleted, n3);
        }
      });
    }, this.exists = async (i3, s) => (this.isInitialized(), this.records.has(s) ? (await this.getRecord(s)).topic === i3 : false), this.on = (i3, s) => {
      this.events.on(i3, s);
    }, this.once = (i3, s) => {
      this.events.once(i3, s);
    }, this.off = (i3, s) => {
      this.events.off(i3, s);
    }, this.removeListener = (i3, s) => {
      this.events.removeListener(i3, s);
    }, this.logger = (0, import_logger3.generateChildLogger)(t, this.name);
  }
  get context() {
    return (0, import_logger3.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e = [];
    return this.values.forEach((t) => {
      if (typeof t.response < "u")
        return;
      const i3 = { topic: t.topic, request: formatJsonRpcRequest(t.request.method, t.request.params, t.id), chainId: t.chainId };
      return e.push(i3);
    }), e;
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e) {
    this.isInitialized();
    const t = this.records.get(e);
    if (!t) {
      const { message: i3 } = N4("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(i3);
    }
    return t;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(_2.sync);
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords();
      if (typeof e > "u" || !e.length)
        return;
      if (this.records.size) {
        const { message: t } = N4("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
    }
  }
  registerEventListeners() {
    this.events.on(_2.created, (e) => {
      const t = _2.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e }), this.persist();
    }), this.events.on(_2.updated, (e) => {
      const t = _2.updated;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e }), this.persist();
    }), this.events.on(_2.deleted, (e) => {
      const t = _2.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N4("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Lt4 = class extends E3 {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, this.expirations = /* @__PURE__ */ new Map(), this.events = new import_events8.EventEmitter(), this.name = Et3, this.version = ft5, this.cached = [], this.initialized = false, this.storagePrefix = O3, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i3) => this.expirations.set(i3.target, i3)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.has = (i3) => {
      try {
        const s = this.formatTarget(i3);
        return typeof this.getExpiration(s) < "u";
      } catch {
        return false;
      }
    }, this.set = (i3, s) => {
      this.isInitialized();
      const n3 = this.formatTarget(i3), a3 = { target: n3, expiry: s };
      this.expirations.set(n3, a3), this.checkExpiry(n3, a3), this.events.emit(w2.created, { target: n3, expiration: a3 });
    }, this.get = (i3) => {
      this.isInitialized();
      const s = this.formatTarget(i3);
      return this.getExpiration(s);
    }, this.del = (i3) => {
      if (this.isInitialized(), this.has(i3)) {
        const s = this.formatTarget(i3), n3 = this.getExpiration(s);
        this.expirations.delete(s), this.events.emit(w2.deleted, { target: s, expiration: n3 });
      }
    }, this.on = (i3, s) => {
      this.events.on(i3, s);
    }, this.once = (i3, s) => {
      this.events.once(i3, s);
    }, this.off = (i3, s) => {
      this.events.off(i3, s);
    }, this.removeListener = (i3, s) => {
      this.events.removeListener(i3, s);
    }, this.logger = (0, import_logger3.generateChildLogger)(t, this.name);
  }
  get context() {
    return (0, import_logger3.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e) {
    if (typeof e == "string")
      return nt4(e);
    if (typeof e == "number")
      return tt4(e);
    const { message: t } = N4("UNKNOWN_TYPE", `Target type: ${typeof e}`);
    throw new Error(t);
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(w2.sync);
  }
  async restore() {
    try {
      const e = await this.getExpirations();
      if (typeof e > "u" || !e.length)
        return;
      if (this.expirations.size) {
        const { message: t } = N4("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);
    }
  }
  getExpiration(e) {
    const t = this.expirations.get(e);
    if (!t) {
      const { message: i3 } = N4("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(i3), new Error(i3);
    }
    return t;
  }
  checkExpiry(e, t) {
    const { expiry: i3 } = t;
    (0, import_time5.toMiliseconds)(i3) - Date.now() <= 0 && this.expire(e, t);
  }
  expire(e, t) {
    this.expirations.delete(e), this.events.emit(w2.expired, { target: e, expiration: t });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e, t) => this.checkExpiry(t, e));
  }
  registerEventListeners() {
    this.core.heartbeat.on(import_heartbeat2.HEARTBEAT_EVENTS.pulse, () => this.checkExpirations()), this.events.on(w2.created, (e) => {
      const t = w2.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(w2.expired, (e) => {
      const t = w2.expired;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(w2.deleted, (e) => {
      const t = w2.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N4("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Ft4 = class extends y2 {
  constructor(e, t) {
    super(e, t), this.projectId = e, this.logger = t, this.name = Y5, this.initialized = false, this.init = async (i3) => {
      $e3() || !je3() || (this.verifyUrl = (i3 == null ? void 0 : i3.verifyUrl) || le5, await this.createIframe());
    }, this.register = async (i3) => {
      var s;
      this.initialized || await this.init(), this.iframe && ((s = this.iframe.contentWindow) == null || s.postMessage(i3.attestationId, this.verifyUrl), this.logger.info(`postMessage sent: ${i3.attestationId} ${this.verifyUrl}`));
    }, this.resolve = async (i3) => {
      var s;
      if (this.isDevEnv)
        return "";
      this.logger.info(`resolving attestation: ${i3.attestationId}`);
      const n3 = this.startAbortTimer(import_time5.FIVE_SECONDS), a3 = await fetch(`${this.verifyUrl}/attestation/${i3.attestationId}`, { signal: this.abortController.signal });
      return clearTimeout(n3), a3.status === 200 ? (s = await a3.json()) == null ? void 0 : s.origin : "";
    }, this.createIframe = async () => {
      try {
        await Promise.race([new Promise((i3, s) => {
          if (document.getElementById(Y5))
            return i3();
          const n3 = document.createElement("iframe");
          n3.setAttribute("id", Y5), n3.setAttribute("src", `${this.verifyUrl}/${this.projectId}`), n3.style.display = "none", n3.addEventListener("load", () => {
            this.initialized = true, i3();
          }), n3.addEventListener("error", (a3) => {
            s(a3);
          }), document.body.append(n3), this.iframe = n3;
        }), new Promise((i3) => {
          setTimeout(() => i3("iframe load timeout"), (0, import_time5.toMiliseconds)(import_time5.ONE_SECOND / 2));
        })]);
      } catch (i3) {
        this.logger.error(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.error(i3);
      }
    }, this.logger = (0, import_logger3.generateChildLogger)(t, this.name), this.verifyUrl = le5, this.abortController = new AbortController(), this.isDevEnv = ee3() && import_process.default.env.IS_VITEST;
  }
  get context() {
    return (0, import_logger3.getLoggerContext)(this.logger);
  }
  startAbortTimer(e) {
    return setTimeout(() => this.abortController.abort(), (0, import_time5.toMiliseconds)(e));
  }
};
var Ir3 = Object.defineProperty;
var $t4 = Object.getOwnPropertySymbols;
var Cr2 = Object.prototype.hasOwnProperty;
var _r2 = Object.prototype.propertyIsEnumerable;
var Mt4 = (r, e, t) => e in r ? Ir3(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var Kt4 = (r, e) => {
  for (var t in e || (e = {}))
    Cr2.call(e, t) && Mt4(r, t, e[t]);
  if ($t4)
    for (var t of $t4(e))
      _r2.call(e, t) && Mt4(r, t, e[t]);
  return r;
};
var J5 = class extends n2 {
  constructor(e) {
    super(e), this.protocol = he3, this.version = Ge3, this.name = G4, this.events = new import_events8.EventEmitter(), this.initialized = false, this.on = (i3, s) => this.events.on(i3, s), this.once = (i3, s) => this.events.once(i3, s), this.off = (i3, s) => this.events.off(i3, s), this.removeListener = (i3, s) => this.events.removeListener(i3, s), this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || ue5;
    const t = typeof (e == null ? void 0 : e.logger) < "u" && typeof (e == null ? void 0 : e.logger) != "string" ? e.logger : (0, import_logger3.pino)((0, import_logger3.getDefaultLoggerOptions)({ level: (e == null ? void 0 : e.logger) || Ye4.logger }));
    this.logger = (0, import_logger3.generateChildLogger)(t, this.name), this.heartbeat = new import_heartbeat2.HeartBeat(), this.crypto = new vt3(this, this.logger, e == null ? void 0 : e.keychain), this.history = new Ut4(this, this.logger), this.expirer = new Lt4(this, this.logger), this.storage = e != null && e.storage ? e.storage : new import_keyvaluestorage2.default(Kt4(Kt4({}, Je3), e == null ? void 0 : e.storageOptions)), this.relayer = new Pt4({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new Nt3(this, this.logger), this.verify = new Ft4(this.projectId || "", this.logger);
  }
  static async init(e) {
    const t = new J5(e);
    await t.initialize();
    const i3 = await t.crypto.getClientId();
    return await t.storage.setItem(lt5, i3), t;
  }
  get context() {
    return (0, import_logger3.getLoggerContext)(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.initialized = true, this.logger.info("Core Initialization Success");
    } catch (e) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;
    }
  }
};
var Rr = J5;

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/sign-client/dist/index.es.js
var import_logger4 = __toESM(require_cjs2());
var import_events9 = __toESM(require_events());
var import_time6 = __toESM(require_cjs());
init_esm3();
var j4 = "wc";
var J6 = 2;
var X3 = "client";
var b3 = `${j4}@${J6}:${X3}:`;
var G5 = { name: X3, logger: "error", controller: false, relayUrl: "wss://relay.walletconnect.com" };
var ee4 = "WALLETCONNECT_DEEPLINK_CHOICE";
var se3 = "proposal";
var te2 = "Proposal expired";
var ie4 = "session";
var C5 = import_time6.SEVEN_DAYS;
var ne6 = "engine";
var O4 = { wc_sessionPropose: { req: { ttl: import_time6.FIVE_MINUTES, prompt: true, tag: 1100 }, res: { ttl: import_time6.FIVE_MINUTES, prompt: false, tag: 1101 } }, wc_sessionSettle: { req: { ttl: import_time6.FIVE_MINUTES, prompt: false, tag: 1102 }, res: { ttl: import_time6.FIVE_MINUTES, prompt: false, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: import_time6.ONE_DAY, prompt: false, tag: 1104 }, res: { ttl: import_time6.ONE_DAY, prompt: false, tag: 1105 } }, wc_sessionExtend: { req: { ttl: import_time6.ONE_DAY, prompt: false, tag: 1106 }, res: { ttl: import_time6.ONE_DAY, prompt: false, tag: 1107 } }, wc_sessionRequest: { req: { ttl: import_time6.FIVE_MINUTES, prompt: true, tag: 1108 }, res: { ttl: import_time6.FIVE_MINUTES, prompt: false, tag: 1109 } }, wc_sessionEvent: { req: { ttl: import_time6.FIVE_MINUTES, prompt: true, tag: 1110 }, res: { ttl: import_time6.FIVE_MINUTES, prompt: false, tag: 1111 } }, wc_sessionDelete: { req: { ttl: import_time6.ONE_DAY, prompt: false, tag: 1112 }, res: { ttl: import_time6.ONE_DAY, prompt: false, tag: 1113 } }, wc_sessionPing: { req: { ttl: import_time6.THIRTY_SECONDS, prompt: false, tag: 1114 }, res: { ttl: import_time6.THIRTY_SECONDS, prompt: false, tag: 1115 } } };
var $6 = { min: import_time6.FIVE_MINUTES, max: import_time6.SEVEN_DAYS };
var re4 = "request";
var oe5 = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest"];
var Ze4 = Object.defineProperty;
var es3 = Object.defineProperties;
var ss3 = Object.getOwnPropertyDescriptors;
var ae6 = Object.getOwnPropertySymbols;
var ts3 = Object.prototype.hasOwnProperty;
var is3 = Object.prototype.propertyIsEnumerable;
var ce6 = (d5, n3, e) => n3 in d5 ? Ze4(d5, n3, { enumerable: true, configurable: true, writable: true, value: e }) : d5[n3] = e;
var w3 = (d5, n3) => {
  for (var e in n3 || (n3 = {}))
    ts3.call(n3, e) && ce6(d5, e, n3[e]);
  if (ae6)
    for (var e of ae6(n3))
      is3.call(n3, e) && ce6(d5, e, n3[e]);
  return d5;
};
var H4 = (d5, n3) => es3(d5, ss3(n3));
var ns3 = class extends S3 {
  constructor(n3) {
    super(n3), this.name = ne6, this.events = new import_events9.default(), this.initialized = false, this.ignoredPayloadTypes = [A2], this.init = async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.client.core.pairing.register({ methods: Object.keys(O4) }), this.initialized = true);
    }, this.connect = async (e) => {
      this.isInitialized();
      const s = H4(w3({}, e), { requiredNamespaces: e.requiredNamespaces || {}, optionalNamespaces: e.optionalNamespaces || {} });
      await this.isValidConnect(s);
      const { pairingTopic: t, requiredNamespaces: i3, optionalNamespaces: r, sessionProperties: o2, relays: a3 } = s;
      let l2 = t, h3, I4 = false;
      if (l2 && (I4 = this.client.core.pairing.pairings.get(l2).active), !l2 || !I4) {
        const { topic: v, uri: y4 } = await this.client.core.pairing.create();
        l2 = v, h3 = y4;
      }
      const g5 = await this.client.core.crypto.generateKeyPair(), E6 = w3({ requiredNamespaces: i3, optionalNamespaces: r, relays: a3 != null ? a3 : [{ protocol: st5 }], proposer: { publicKey: g5, metadata: this.client.metadata } }, o2 && { sessionProperties: o2 }), { reject: m5, resolve: V3, done: U5 } = Xn2(import_time6.FIVE_MINUTES, te2);
      if (this.events.once(it4("session_connect"), async ({ error: v, session: y4 }) => {
        if (v)
          m5(v);
        else if (y4) {
          y4.self.publicKey = g5;
          const F4 = H4(w3({}, y4), { requiredNamespaces: y4.requiredNamespaces, optionalNamespaces: y4.optionalNamespaces });
          await this.client.session.set(y4.topic, F4), await this.setExpiry(y4.topic, y4.expiry), l2 && await this.client.core.pairing.updateMetadata({ topic: l2, metadata: y4.peer.metadata }), V3(F4);
        }
      }), !l2) {
        const { message: v } = N4("NO_MATCHING_KEY", `connect() pairing topic: ${l2}`);
        throw new Error(v);
      }
      const A3 = await this.sendRequest(l2, "wc_sessionPropose", E6), le6 = ot4(import_time6.FIVE_MINUTES);
      return await this.setProposal(A3, w3({ id: A3, expiry: le6 }, E6)), { uri: h3, approval: U5 };
    }, this.pair = async (e) => (this.isInitialized(), await this.client.core.pairing.pair(e)), this.approve = async (e) => {
      this.isInitialized(), await this.isValidApprove(e);
      const { id: s, relayProtocol: t, namespaces: i3, sessionProperties: r } = e, o2 = this.client.proposal.get(s);
      let { pairingTopic: a3, proposer: l2, requiredNamespaces: h3, optionalNamespaces: I4 } = o2;
      a3 = a3 || "", F3(h3) || (h3 = St4(i3, "approve()"));
      const g5 = await this.client.core.crypto.generateKeyPair(), E6 = l2.publicKey, m5 = await this.client.core.crypto.generateSharedKey(g5, E6);
      a3 && s && (await this.client.core.pairing.updateMetadata({ topic: a3, metadata: l2.metadata }), await this.sendResult(s, a3, { relay: { protocol: t != null ? t : "irn" }, responderPublicKey: g5 }), await this.client.proposal.delete(s, w("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: a3 }));
      const V3 = w3({ relay: { protocol: t != null ? t : "irn" }, namespaces: i3, requiredNamespaces: h3, optionalNamespaces: I4, pairingTopic: a3, controller: { publicKey: g5, metadata: this.client.metadata }, expiry: ot4(C5) }, r && { sessionProperties: r });
      await this.client.core.relayer.subscribe(m5), await this.sendRequest(m5, "wc_sessionSettle", V3);
      const U5 = H4(w3({}, V3), { topic: m5, pairingTopic: a3, acknowledged: false, self: V3.controller, peer: { publicKey: l2.publicKey, metadata: l2.metadata }, controller: g5 });
      return await this.client.session.set(m5, U5), await this.setExpiry(m5, ot4(C5)), { topic: m5, acknowledged: () => new Promise((A3) => setTimeout(() => A3(this.client.session.get(m5)), 500)) };
    }, this.reject = async (e) => {
      this.isInitialized(), await this.isValidReject(e);
      const { id: s, reason: t } = e, { pairingTopic: i3 } = this.client.proposal.get(s);
      i3 && (await this.sendError(s, i3, t), await this.client.proposal.delete(s, w("USER_DISCONNECTED")));
    }, this.update = async (e) => {
      this.isInitialized(), await this.isValidUpdate(e);
      const { topic: s, namespaces: t } = e, i3 = await this.sendRequest(s, "wc_sessionUpdate", { namespaces: t }), { done: r, resolve: o2, reject: a3 } = Xn2();
      return this.events.once(it4("session_update", i3), ({ error: l2 }) => {
        l2 ? a3(l2) : o2();
      }), await this.client.session.update(s, { namespaces: t }), { acknowledged: r };
    }, this.extend = async (e) => {
      this.isInitialized(), await this.isValidExtend(e);
      const { topic: s } = e, t = await this.sendRequest(s, "wc_sessionExtend", {}), { done: i3, resolve: r, reject: o2 } = Xn2();
      return this.events.once(it4("session_extend", t), ({ error: a3 }) => {
        a3 ? o2(a3) : r();
      }), await this.setExpiry(s, ot4(C5)), { acknowledged: i3 };
    }, this.request = async (e) => {
      this.isInitialized(), await this.isValidRequest(e);
      const { chainId: s, request: t, topic: i3, expiry: r } = e, o2 = await this.sendRequest(i3, "wc_sessionRequest", { request: t, chainId: s }, r), { done: a3, resolve: l2, reject: h3 } = Xn2(r);
      this.events.once(it4("session_request", o2), ({ error: g5, result: E6 }) => {
        g5 ? h3(g5) : l2(E6);
      }), this.client.events.emit("session_request_sent", { topic: i3, request: t, chainId: s, id: o2 });
      const I4 = await this.client.core.storage.getItem(ee4);
      return ct4({ id: o2, topic: i3, wcDeepLink: I4 }), await a3();
    }, this.respond = async (e) => {
      this.isInitialized(), await this.isValidRespond(e);
      const { topic: s, response: t } = e, { id: i3 } = t;
      isJsonRpcResult(t) ? await this.sendResult(i3, s, t.result) : isJsonRpcError(t) && await this.sendError(i3, s, t.error), this.deletePendingSessionRequest(e.response.id, { message: "fulfilled", code: 0 });
    }, this.ping = async (e) => {
      this.isInitialized(), await this.isValidPing(e);
      const { topic: s } = e;
      if (this.client.session.keys.includes(s)) {
        const t = await this.sendRequest(s, "wc_sessionPing", {}), { done: i3, resolve: r, reject: o2 } = Xn2();
        this.events.once(it4("session_ping", t), ({ error: a3 }) => {
          a3 ? o2(a3) : r();
        }), await i3();
      } else
        this.client.core.pairing.pairings.keys.includes(s) && await this.client.core.pairing.ping({ topic: s });
    }, this.emit = async (e) => {
      this.isInitialized(), await this.isValidEmit(e);
      const { topic: s, event: t, chainId: i3 } = e;
      await this.sendRequest(s, "wc_sessionEvent", { event: t, chainId: i3 });
    }, this.disconnect = async (e) => {
      this.isInitialized(), await this.isValidDisconnect(e);
      const { topic: s } = e;
      if (this.client.session.keys.includes(s)) {
        const t = getBigIntRpcId().toString();
        let i3;
        const r = (o2) => {
          (o2 == null ? void 0 : o2.id.toString()) === t && (this.client.core.relayer.events.removeListener(g3.message_ack, r), i3());
        };
        await Promise.all([new Promise((o2) => {
          i3 = o2, this.client.core.relayer.on(g3.message_ack, r);
        }), this.sendRequest(s, "wc_sessionDelete", w("USER_DISCONNECTED"), void 0, t)]), await this.deleteSession(s);
      } else
        await this.client.core.pairing.disconnect({ topic: s });
    }, this.find = (e) => (this.isInitialized(), this.client.session.getAll().filter((s) => Rt4(s, e))), this.getPendingSessionRequests = () => (this.isInitialized(), this.client.pendingRequest.getAll()), this.cleanupDuplicatePairings = async (e) => {
      try {
        const s = this.client.core.pairing.pairings.get(e.pairingTopic), t = this.client.core.pairing.pairings.getAll().filter((i3) => {
          var r, o2;
          return ((r = i3.peerMetadata) == null ? void 0 : r.url) && ((o2 = i3.peerMetadata) == null ? void 0 : o2.url) === e.peer.metadata.url && i3.topic && i3.topic !== s.topic;
        });
        if (t.length === 0)
          return;
        this.client.logger.info(`Cleaning up ${t.length} duplicate pairing(s)`), await Promise.all(t.map((i3) => this.client.core.pairing.disconnect({ topic: i3.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
      } catch (s) {
        this.client.logger.error(s);
      }
    }, this.deleteSession = async (e, s) => {
      const { self: t } = this.client.session.get(e);
      await this.client.core.relayer.unsubscribe(e), this.client.session.delete(e, w("USER_DISCONNECTED")), this.client.core.crypto.keychain.has(t.publicKey) && await this.client.core.crypto.deleteKeyPair(t.publicKey), this.client.core.crypto.keychain.has(e) && await this.client.core.crypto.deleteSymKey(e), s || this.client.core.expirer.del(e);
    }, this.deleteProposal = async (e, s) => {
      await Promise.all([this.client.proposal.delete(e, w("USER_DISCONNECTED")), s ? Promise.resolve() : this.client.core.expirer.del(e)]);
    }, this.deletePendingSessionRequest = async (e, s, t = false) => {
      await Promise.all([this.client.pendingRequest.delete(e, s), t ? Promise.resolve() : this.client.core.expirer.del(e)]);
    }, this.setExpiry = async (e, s) => {
      this.client.session.keys.includes(e) && await this.client.session.update(e, { expiry: s }), this.client.core.expirer.set(e, s);
    }, this.setProposal = async (e, s) => {
      await this.client.proposal.set(e, s), this.client.core.expirer.set(e, s.expiry);
    }, this.setPendingSessionRequest = async (e) => {
      const s = O4.wc_sessionRequest.req.ttl, { id: t, topic: i3, params: r } = e;
      await this.client.pendingRequest.set(t, { id: t, topic: i3, params: r }), s && this.client.core.expirer.set(t, ot4(s));
    }, this.sendRequest = async (e, s, t, i3, r) => {
      const o2 = formatJsonRpcRequest(s, t);
      if (je3() && oe5.includes(s)) {
        const h3 = $n2(JSON.stringify(o2));
        await this.client.core.verify.register({ attestationId: h3 });
      }
      const a3 = await this.client.core.crypto.encode(e, o2), l2 = O4[s].req;
      return i3 && (l2.ttl = i3), r && (l2.id = r), this.client.core.history.set(e, o2), this.client.core.relayer.publish(e, a3, l2), o2.id;
    }, this.sendResult = async (e, s, t) => {
      const i3 = formatJsonRpcResult(e, t), r = await this.client.core.crypto.encode(s, i3), o2 = await this.client.core.history.get(s, e), a3 = O4[o2.request.method].res;
      this.client.core.relayer.publish(s, r, a3), await this.client.core.history.resolve(i3);
    }, this.sendError = async (e, s, t) => {
      const i3 = formatJsonRpcError(e, t), r = await this.client.core.crypto.encode(s, i3), o2 = await this.client.core.history.get(s, e), a3 = O4[o2.request.method].res;
      this.client.core.relayer.publish(s, r, a3), await this.client.core.history.resolve(i3);
    }, this.cleanup = async () => {
      const e = [], s = [];
      this.client.session.getAll().forEach((t) => {
        st4(t.expiry) && e.push(t.topic);
      }), this.client.proposal.getAll().forEach((t) => {
        st4(t.expiry) && s.push(t.id);
      }), await Promise.all([...e.map((t) => this.deleteSession(t)), ...s.map((t) => this.deleteProposal(t))]);
    }, this.onRelayEventRequest = (e) => {
      const { topic: s, payload: t } = e, i3 = t.method;
      switch (i3) {
        case "wc_sessionPropose":
          return this.onSessionProposeRequest(s, t);
        case "wc_sessionSettle":
          return this.onSessionSettleRequest(s, t);
        case "wc_sessionUpdate":
          return this.onSessionUpdateRequest(s, t);
        case "wc_sessionExtend":
          return this.onSessionExtendRequest(s, t);
        case "wc_sessionPing":
          return this.onSessionPingRequest(s, t);
        case "wc_sessionDelete":
          return this.onSessionDeleteRequest(s, t);
        case "wc_sessionRequest":
          return this.onSessionRequest(s, t);
        case "wc_sessionEvent":
          return this.onSessionEventRequest(s, t);
        default:
          return this.client.logger.info(`Unsupported request method ${i3}`);
      }
    }, this.onRelayEventResponse = async (e) => {
      const { topic: s, payload: t } = e, i3 = (await this.client.core.history.get(s, t.id)).request.method;
      switch (i3) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(s, t);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(s, t);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(s, t);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(s, t);
        case "wc_sessionPing":
          return this.onSessionPingResponse(s, t);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(s, t);
        default:
          return this.client.logger.info(`Unsupported response method ${i3}`);
      }
    }, this.onRelayEventUnknownPayload = (e) => {
      const { topic: s } = e, { message: t } = N4("MISSING_OR_INVALID", `Decoded payload on topic ${s} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(t);
    }, this.onSessionProposeRequest = async (e, s) => {
      const { params: t, id: i3 } = s;
      try {
        this.isValidConnect(w3({}, s.params));
        const r = ot4(import_time6.FIVE_MINUTES), o2 = w3({ id: i3, pairingTopic: e, expiry: r }, t);
        await this.setProposal(i3, o2);
        const a3 = $n2(JSON.stringify(s)), l2 = await this.getVerifyContext(a3, o2.proposer.metadata);
        this.client.events.emit("session_proposal", { id: i3, params: o2, verifyContext: l2 });
      } catch (r) {
        await this.sendError(i3, e, r), this.client.logger.error(r);
      }
    }, this.onSessionProposeResponse = async (e, s) => {
      const { id: t } = s;
      if (isJsonRpcResult(s)) {
        const { result: i3 } = s;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: i3 });
        const r = this.client.proposal.get(t);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: r });
        const o2 = r.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: o2 });
        const a3 = i3.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: a3 });
        const l2 = await this.client.core.crypto.generateSharedKey(o2, a3);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", sessionTopic: l2 });
        const h3 = await this.client.core.relayer.subscribe(l2);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: h3 }), await this.client.core.pairing.activate({ topic: e });
      } else
        isJsonRpcError(s) && (await this.client.proposal.delete(t, w("USER_DISCONNECTED")), this.events.emit(it4("session_connect"), { error: s.error }));
    }, this.onSessionSettleRequest = async (e, s) => {
      const { id: t, params: i3 } = s;
      try {
        this.isValidSessionSettleRequest(i3);
        const { relay: r, controller: o2, expiry: a3, namespaces: l2, requiredNamespaces: h3, optionalNamespaces: I4, sessionProperties: g5, pairingTopic: E6 } = s.params, m5 = w3({ topic: e, relay: r, expiry: a3, namespaces: l2, acknowledged: true, pairingTopic: E6, requiredNamespaces: h3, optionalNamespaces: I4, controller: o2.publicKey, self: { publicKey: "", metadata: this.client.metadata }, peer: { publicKey: o2.publicKey, metadata: o2.metadata } }, g5 && { sessionProperties: g5 });
        await this.sendResult(s.id, e, true), this.events.emit(it4("session_connect"), { session: m5 }), this.cleanupDuplicatePairings(m5);
      } catch (r) {
        await this.sendError(t, e, r), this.client.logger.error(r);
      }
    }, this.onSessionSettleResponse = async (e, s) => {
      const { id: t } = s;
      isJsonRpcResult(s) ? (await this.client.session.update(e, { acknowledged: true }), this.events.emit(it4("session_approve", t), {})) : isJsonRpcError(s) && (await this.client.session.delete(e, w("USER_DISCONNECTED")), this.events.emit(it4("session_approve", t), { error: s.error }));
    }, this.onSessionUpdateRequest = async (e, s) => {
      const { params: t, id: i3 } = s;
      try {
        this.isValidUpdate(w3({ topic: e }, t)), await this.client.session.update(e, { namespaces: t.namespaces }), await this.sendResult(i3, e, true), this.client.events.emit("session_update", { id: i3, topic: e, params: t });
      } catch (r) {
        await this.sendError(i3, e, r), this.client.logger.error(r);
      }
    }, this.onSessionUpdateResponse = (e, s) => {
      const { id: t } = s;
      isJsonRpcResult(s) ? this.events.emit(it4("session_update", t), {}) : isJsonRpcError(s) && this.events.emit(it4("session_update", t), { error: s.error });
    }, this.onSessionExtendRequest = async (e, s) => {
      const { id: t } = s;
      try {
        this.isValidExtend({ topic: e }), await this.setExpiry(e, ot4(C5)), await this.sendResult(t, e, true), this.client.events.emit("session_extend", { id: t, topic: e });
      } catch (i3) {
        await this.sendError(t, e, i3), this.client.logger.error(i3);
      }
    }, this.onSessionExtendResponse = (e, s) => {
      const { id: t } = s;
      isJsonRpcResult(s) ? this.events.emit(it4("session_extend", t), {}) : isJsonRpcError(s) && this.events.emit(it4("session_extend", t), { error: s.error });
    }, this.onSessionPingRequest = async (e, s) => {
      const { id: t } = s;
      try {
        this.isValidPing({ topic: e }), await this.sendResult(t, e, true), this.client.events.emit("session_ping", { id: t, topic: e });
      } catch (i3) {
        await this.sendError(t, e, i3), this.client.logger.error(i3);
      }
    }, this.onSessionPingResponse = (e, s) => {
      const { id: t } = s;
      setTimeout(() => {
        isJsonRpcResult(s) ? this.events.emit(it4("session_ping", t), {}) : isJsonRpcError(s) && this.events.emit(it4("session_ping", t), { error: s.error });
      }, 500);
    }, this.onSessionDeleteRequest = async (e, s) => {
      const { id: t } = s;
      try {
        this.isValidDisconnect({ topic: e, reason: s.params }), await Promise.all([new Promise((i3) => {
          this.client.core.relayer.once(g3.publish, async () => {
            i3(await this.deleteSession(e));
          });
        }), this.sendResult(t, e, true)]), this.client.events.emit("session_delete", { id: t, topic: e });
      } catch (i3) {
        this.client.logger.error(i3);
      }
    }, this.onSessionRequest = async (e, s) => {
      const { id: t, params: i3 } = s;
      try {
        this.isValidRequest(w3({ topic: e }, i3)), await this.setPendingSessionRequest({ id: t, topic: e, params: i3 });
        const r = $n2(JSON.stringify(s)), o2 = this.client.session.get(e), a3 = await this.getVerifyContext(r, o2.peer.metadata);
        this.client.events.emit("session_request", { id: t, topic: e, params: i3, verifyContext: a3 });
      } catch (r) {
        await this.sendError(t, e, r), this.client.logger.error(r);
      }
    }, this.onSessionRequestResponse = (e, s) => {
      const { id: t } = s;
      isJsonRpcResult(s) ? this.events.emit(it4("session_request", t), { result: s.result }) : isJsonRpcError(s) && this.events.emit(it4("session_request", t), { error: s.error });
    }, this.onSessionEventRequest = async (e, s) => {
      const { id: t, params: i3 } = s;
      try {
        this.isValidEmit(w3({ topic: e }, i3)), this.client.events.emit("session_event", { id: t, topic: e, params: i3 });
      } catch (r) {
        await this.sendError(t, e, r), this.client.logger.error(r);
      }
    }, this.isValidConnect = async (e) => {
      if (!Dt3(e)) {
        const { message: a3 } = N4("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(e)}`);
        throw new Error(a3);
      }
      const { pairingTopic: s, requiredNamespaces: t, optionalNamespaces: i3, sessionProperties: r, relays: o2 } = e;
      if (I2(s) || await this.isValidPairingTopic(s), !jt2(o2, true)) {
        const { message: a3 } = N4("MISSING_OR_INVALID", `connect() relays: ${o2}`);
        throw new Error(a3);
      }
      !I2(t) && F3(t) !== 0 && this.validateNamespaces(t, "requiredNamespaces"), !I2(i3) && F3(i3) !== 0 && this.validateNamespaces(i3, "optionalNamespaces"), I2(r) || this.validateSessionProps(r, "sessionProperties");
    }, this.validateNamespaces = (e, s) => {
      const t = $t3(e, "connect()", s);
      if (t)
        throw new Error(t.message);
    }, this.isValidApprove = async (e) => {
      if (!Dt3(e))
        throw new Error(N4("MISSING_OR_INVALID", `approve() params: ${e}`).message);
      const { id: s, namespaces: t, relayProtocol: i3, sessionProperties: r } = e;
      await this.isValidProposalId(s);
      const o2 = this.client.proposal.get(s), a3 = sn(t, "approve()");
      if (a3)
        throw new Error(a3.message);
      const l2 = an(o2.requiredNamespaces, t, "approve()");
      if (l2)
        throw new Error(l2.message);
      if (!m3(i3, true)) {
        const { message: h3 } = N4("MISSING_OR_INVALID", `approve() relayProtocol: ${i3}`);
        throw new Error(h3);
      }
      I2(r) || this.validateSessionProps(r, "sessionProperties");
    }, this.isValidReject = async (e) => {
      if (!Dt3(e)) {
        const { message: i3 } = N4("MISSING_OR_INVALID", `reject() params: ${e}`);
        throw new Error(i3);
      }
      const { id: s, reason: t } = e;
      if (await this.isValidProposalId(s), !Vt2(t)) {
        const { message: i3 } = N4("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(t)}`);
        throw new Error(i3);
      }
    }, this.isValidSessionSettleRequest = (e) => {
      if (!Dt3(e)) {
        const { message: l2 } = N4("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${e}`);
        throw new Error(l2);
      }
      const { relay: s, controller: t, namespaces: i3, expiry: r } = e;
      if (!cn(s)) {
        const { message: l2 } = N4("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(l2);
      }
      const o2 = _t3(t, "onSessionSettleRequest()");
      if (o2)
        throw new Error(o2.message);
      const a3 = sn(i3, "onSessionSettleRequest()");
      if (a3)
        throw new Error(a3.message);
      if (st4(r)) {
        const { message: l2 } = N4("EXPIRED", "onSessionSettleRequest()");
        throw new Error(l2);
      }
    }, this.isValidUpdate = async (e) => {
      if (!Dt3(e)) {
        const { message: a3 } = N4("MISSING_OR_INVALID", `update() params: ${e}`);
        throw new Error(a3);
      }
      const { topic: s, namespaces: t } = e;
      await this.isValidSessionTopic(s);
      const i3 = this.client.session.get(s), r = sn(t, "update()");
      if (r)
        throw new Error(r.message);
      const o2 = an(i3.requiredNamespaces, t, "update()");
      if (o2)
        throw new Error(o2.message);
    }, this.isValidExtend = async (e) => {
      if (!Dt3(e)) {
        const { message: t } = N4("MISSING_OR_INVALID", `extend() params: ${e}`);
        throw new Error(t);
      }
      const { topic: s } = e;
      await this.isValidSessionTopic(s);
    }, this.isValidRequest = async (e) => {
      if (!Dt3(e)) {
        const { message: a3 } = N4("MISSING_OR_INVALID", `request() params: ${e}`);
        throw new Error(a3);
      }
      const { topic: s, request: t, chainId: i3, expiry: r } = e;
      await this.isValidSessionTopic(s);
      const { namespaces: o2 } = this.client.session.get(s);
      if (!Lt3(o2, i3)) {
        const { message: a3 } = N4("MISSING_OR_INVALID", `request() chainId: ${i3}`);
        throw new Error(a3);
      }
      if (!Mt3(t)) {
        const { message: a3 } = N4("MISSING_OR_INVALID", `request() ${JSON.stringify(t)}`);
        throw new Error(a3);
      }
      if (!xt3(o2, i3, t.method)) {
        const { message: a3 } = N4("MISSING_OR_INVALID", `request() method: ${t.method}`);
        throw new Error(a3);
      }
      if (r && !zt3(r, $6)) {
        const { message: a3 } = N4("MISSING_OR_INVALID", `request() expiry: ${r}. Expiry must be a number (in seconds) between ${$6.min} and ${$6.max}`);
        throw new Error(a3);
      }
    }, this.isValidRespond = async (e) => {
      if (!Dt3(e)) {
        const { message: i3 } = N4("MISSING_OR_INVALID", `respond() params: ${e}`);
        throw new Error(i3);
      }
      const { topic: s, response: t } = e;
      if (await this.isValidSessionTopic(s), !Kt3(t)) {
        const { message: i3 } = N4("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(t)}`);
        throw new Error(i3);
      }
    }, this.isValidPing = async (e) => {
      if (!Dt3(e)) {
        const { message: t } = N4("MISSING_OR_INVALID", `ping() params: ${e}`);
        throw new Error(t);
      }
      const { topic: s } = e;
      await this.isValidSessionOrPairingTopic(s);
    }, this.isValidEmit = async (e) => {
      if (!Dt3(e)) {
        const { message: o2 } = N4("MISSING_OR_INVALID", `emit() params: ${e}`);
        throw new Error(o2);
      }
      const { topic: s, event: t, chainId: i3 } = e;
      await this.isValidSessionTopic(s);
      const { namespaces: r } = this.client.session.get(s);
      if (!Lt3(r, i3)) {
        const { message: o2 } = N4("MISSING_OR_INVALID", `emit() chainId: ${i3}`);
        throw new Error(o2);
      }
      if (!kt2(t)) {
        const { message: o2 } = N4("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(t)}`);
        throw new Error(o2);
      }
      if (!Ft3(r, i3, t.name)) {
        const { message: o2 } = N4("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(t)}`);
        throw new Error(o2);
      }
    }, this.isValidDisconnect = async (e) => {
      if (!Dt3(e)) {
        const { message: t } = N4("MISSING_OR_INVALID", `disconnect() params: ${e}`);
        throw new Error(t);
      }
      const { topic: s } = e;
      await this.isValidSessionOrPairingTopic(s);
    }, this.getVerifyContext = async (e, s) => {
      const t = { verified: { verifyUrl: s.verifyUrl || "", validation: "UNKNOWN", origin: s.url || "" } };
      try {
        const i3 = await this.client.core.verify.resolve({ attestationId: e, verifyUrl: s.verifyUrl });
        i3 && (t.verified.origin = i3, t.verified.validation = i3 === s.url ? "VALID" : "INVALID");
      } catch (i3) {
        this.client.logger.error(i3);
      }
      return this.client.logger.info(`Verify context: ${JSON.stringify(t)}`), t;
    }, this.validateSessionProps = (e, s) => {
      Object.values(e).forEach((t) => {
        if (!m3(t, false)) {
          const { message: i3 } = N4("MISSING_OR_INVALID", `${s} must be in Record<string, string> format. Received: ${JSON.stringify(t)}`);
          throw new Error(i3);
        }
      });
    };
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: n3 } = N4("NOT_INITIALIZED", this.name);
      throw new Error(n3);
    }
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(g3.message, async (n3) => {
      const { topic: e, message: s } = n3;
      if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(s)))
        return;
      const t = await this.client.core.crypto.decode(e, s);
      isJsonRpcRequest(t) ? (this.client.core.history.set(e, t), this.onRelayEventRequest({ topic: e, payload: t })) : isJsonRpcResponse(t) ? (await this.client.core.history.resolve(t), this.onRelayEventResponse({ topic: e, payload: t })) : this.onRelayEventUnknownPayload({ topic: e, payload: t });
    });
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(w2.expired, async (n3) => {
      const { topic: e, id: s } = rt4(n3.target);
      if (s && this.client.pendingRequest.keys.includes(s))
        return await this.deletePendingSessionRequest(s, N4("EXPIRED"), true);
      e ? this.client.session.keys.includes(e) && (await this.deleteSession(e, true), this.client.events.emit("session_expire", { topic: e })) : s && (await this.deleteProposal(s, true), this.client.events.emit("proposal_expire", { id: s }));
    });
  }
  isValidPairingTopic(n3) {
    if (!m3(n3, false)) {
      const { message: e } = N4("MISSING_OR_INVALID", `pairing topic should be a string: ${n3}`);
      throw new Error(e);
    }
    if (!this.client.core.pairing.pairings.keys.includes(n3)) {
      const { message: e } = N4("NO_MATCHING_KEY", `pairing topic doesn't exist: ${n3}`);
      throw new Error(e);
    }
    if (st4(this.client.core.pairing.pairings.get(n3).expiry)) {
      const { message: e } = N4("EXPIRED", `pairing topic: ${n3}`);
      throw new Error(e);
    }
  }
  async isValidSessionTopic(n3) {
    if (!m3(n3, false)) {
      const { message: e } = N4("MISSING_OR_INVALID", `session topic should be a string: ${n3}`);
      throw new Error(e);
    }
    if (!this.client.session.keys.includes(n3)) {
      const { message: e } = N4("NO_MATCHING_KEY", `session topic doesn't exist: ${n3}`);
      throw new Error(e);
    }
    if (st4(this.client.session.get(n3).expiry)) {
      await this.deleteSession(n3);
      const { message: e } = N4("EXPIRED", `session topic: ${n3}`);
      throw new Error(e);
    }
  }
  async isValidSessionOrPairingTopic(n3) {
    if (this.client.session.keys.includes(n3))
      await this.isValidSessionTopic(n3);
    else if (this.client.core.pairing.pairings.keys.includes(n3))
      this.isValidPairingTopic(n3);
    else if (m3(n3, false)) {
      const { message: e } = N4("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${n3}`);
      throw new Error(e);
    } else {
      const { message: e } = N4("MISSING_OR_INVALID", `session or pairing topic should be a string: ${n3}`);
      throw new Error(e);
    }
  }
  async isValidProposalId(n3) {
    if (!Ct4(n3)) {
      const { message: e } = N4("MISSING_OR_INVALID", `proposal id should be a number: ${n3}`);
      throw new Error(e);
    }
    if (!this.client.proposal.keys.includes(n3)) {
      const { message: e } = N4("NO_MATCHING_KEY", `proposal id doesn't exist: ${n3}`);
      throw new Error(e);
    }
    if (st4(this.client.proposal.get(n3).expiry)) {
      await this.deleteProposal(n3);
      const { message: e } = N4("EXPIRED", `proposal id: ${n3}`);
      throw new Error(e);
    }
  }
};
var rs3 = class extends zt4 {
  constructor(n3, e) {
    super(n3, e, se3, b3), this.core = n3, this.logger = e;
  }
};
var os3 = class extends zt4 {
  constructor(n3, e) {
    super(n3, e, ie4, b3), this.core = n3, this.logger = e;
  }
};
var as3 = class extends zt4 {
  constructor(n3, e) {
    super(n3, e, re4, b3, (s) => s.id), this.core = n3, this.logger = e;
  }
};
var M4 = class extends b {
  constructor(n3) {
    super(n3), this.protocol = j4, this.version = J6, this.name = G5.name, this.events = new import_events9.EventEmitter(), this.on = (s, t) => this.events.on(s, t), this.once = (s, t) => this.events.once(s, t), this.off = (s, t) => this.events.off(s, t), this.removeListener = (s, t) => this.events.removeListener(s, t), this.removeAllListeners = (s) => this.events.removeAllListeners(s), this.connect = async (s) => {
      try {
        return await this.engine.connect(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.pair = async (s) => {
      try {
        return await this.engine.pair(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.approve = async (s) => {
      try {
        return await this.engine.approve(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.reject = async (s) => {
      try {
        return await this.engine.reject(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.update = async (s) => {
      try {
        return await this.engine.update(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.extend = async (s) => {
      try {
        return await this.engine.extend(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.request = async (s) => {
      try {
        return await this.engine.request(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.respond = async (s) => {
      try {
        return await this.engine.respond(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.ping = async (s) => {
      try {
        return await this.engine.ping(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.emit = async (s) => {
      try {
        return await this.engine.emit(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.disconnect = async (s) => {
      try {
        return await this.engine.disconnect(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.find = (s) => {
      try {
        return this.engine.find(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.name = (n3 == null ? void 0 : n3.name) || G5.name, this.metadata = (n3 == null ? void 0 : n3.metadata) || Fn();
    const e = typeof (n3 == null ? void 0 : n3.logger) < "u" && typeof (n3 == null ? void 0 : n3.logger) != "string" ? n3.logger : (0, import_logger4.pino)((0, import_logger4.getDefaultLoggerOptions)({ level: (n3 == null ? void 0 : n3.logger) || G5.logger }));
    this.core = (n3 == null ? void 0 : n3.core) || new Rr(n3), this.logger = (0, import_logger4.generateChildLogger)(e, this.name), this.session = new os3(this.core, this.logger), this.proposal = new rs3(this.core, this.logger), this.pendingRequest = new as3(this.core, this.logger), this.engine = new ns3(this);
  }
  static async init(n3) {
    const e = new M4(n3);
    return await e.initialize(), e;
  }
  get context() {
    return (0, import_logger4.getLoggerContext)(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.engine.init(), this.core.verify.init({ verifyUrl: this.metadata.verifyUrl }), this.logger.info("SignClient Initialization Success");
    } catch (n3) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(n3.message), n3;
    }
  }
};
var cs3 = M4;

// node_modules/@walletconnect/web3wallet/dist/index.es.js
var l = { exports: {} };
var u4 = typeof Reflect == "object" ? Reflect : null;
var m4 = u4 && typeof u4.apply == "function" ? u4.apply : function(t, e, n3) {
  return Function.prototype.apply.call(t, e, n3);
};
var f5;
u4 && typeof u4.ownKeys == "function" ? f5 = u4.ownKeys : Object.getOwnPropertySymbols ? f5 = function(t) {
  return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
} : f5 = function(t) {
  return Object.getOwnPropertyNames(t);
};
function T2(s) {
  console && console.warn && console.warn(s);
}
var y3 = Number.isNaN || function(t) {
  return t !== t;
};
function o() {
  o.init.call(this);
}
l.exports = o, l.exports.once = M5, o.EventEmitter = o, o.prototype._events = void 0, o.prototype._eventsCount = 0, o.prototype._maxListeners = void 0;
var w4 = 10;
function g4(s) {
  if (typeof s != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof s);
}
Object.defineProperty(o, "defaultMaxListeners", { enumerable: true, get: function() {
  return w4;
}, set: function(s) {
  if (typeof s != "number" || s < 0 || y3(s))
    throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + s + ".");
  w4 = s;
} }), o.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
}, o.prototype.setMaxListeners = function(t) {
  if (typeof t != "number" || t < 0 || y3(t))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
  return this._maxListeners = t, this;
};
function L3(s) {
  return s._maxListeners === void 0 ? o.defaultMaxListeners : s._maxListeners;
}
o.prototype.getMaxListeners = function() {
  return L3(this);
}, o.prototype.emit = function(t) {
  for (var e = [], n3 = 1; n3 < arguments.length; n3++)
    e.push(arguments[n3]);
  var i3 = t === "error", a3 = this._events;
  if (a3 !== void 0)
    i3 = i3 && a3.error === void 0;
  else if (!i3)
    return false;
  if (i3) {
    var r;
    if (e.length > 0 && (r = e[0]), r instanceof Error)
      throw r;
    var h3 = new Error("Unhandled error." + (r ? " (" + r.message + ")" : ""));
    throw h3.context = r, h3;
  }
  var c3 = a3[t];
  if (c3 === void 0)
    return false;
  if (typeof c3 == "function")
    m4(c3, this, e);
  else
    for (var v = c3.length, A3 = b4(c3, v), n3 = 0; n3 < v; ++n3)
      m4(A3[n3], this, e);
  return true;
};
function _3(s, t, e, n3) {
  var i3, a3, r;
  if (g4(e), a3 = s._events, a3 === void 0 ? (a3 = s._events = /* @__PURE__ */ Object.create(null), s._eventsCount = 0) : (a3.newListener !== void 0 && (s.emit("newListener", t, e.listener ? e.listener : e), a3 = s._events), r = a3[t]), r === void 0)
    r = a3[t] = e, ++s._eventsCount;
  else if (typeof r == "function" ? r = a3[t] = n3 ? [e, r] : [r, e] : n3 ? r.unshift(e) : r.push(e), i3 = L3(s), i3 > 0 && r.length > i3 && !r.warned) {
    r.warned = true;
    var h3 = new Error("Possible EventEmitter memory leak detected. " + r.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    h3.name = "MaxListenersExceededWarning", h3.emitter = s, h3.type = t, h3.count = r.length, T2(h3);
  }
  return s;
}
o.prototype.addListener = function(t, e) {
  return _3(this, t, e, false);
}, o.prototype.on = o.prototype.addListener, o.prototype.prependListener = function(t, e) {
  return _3(this, t, e, true);
};
function j5() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function S4(s, t, e) {
  var n3 = { fired: false, wrapFn: void 0, target: s, type: t, listener: e }, i3 = j5.bind(n3);
  return i3.listener = e, n3.wrapFn = i3, i3;
}
o.prototype.once = function(t, e) {
  return g4(e), this.on(t, S4(this, t, e)), this;
}, o.prototype.prependOnceListener = function(t, e) {
  return g4(e), this.prependListener(t, S4(this, t, e)), this;
}, o.prototype.removeListener = function(t, e) {
  var n3, i3, a3, r, h3;
  if (g4(e), i3 = this._events, i3 === void 0)
    return this;
  if (n3 = i3[t], n3 === void 0)
    return this;
  if (n3 === e || n3.listener === e)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i3[t], i3.removeListener && this.emit("removeListener", t, n3.listener || e));
  else if (typeof n3 != "function") {
    for (a3 = -1, r = n3.length - 1; r >= 0; r--)
      if (n3[r] === e || n3[r].listener === e) {
        h3 = n3[r].listener, a3 = r;
        break;
      }
    if (a3 < 0)
      return this;
    a3 === 0 ? n3.shift() : I3(n3, a3), n3.length === 1 && (i3[t] = n3[0]), i3.removeListener !== void 0 && this.emit("removeListener", t, h3 || e);
  }
  return this;
}, o.prototype.off = o.prototype.removeListener, o.prototype.removeAllListeners = function(t) {
  var e, n3, i3;
  if (n3 = this._events, n3 === void 0)
    return this;
  if (n3.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : n3[t] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete n3[t]), this;
  if (arguments.length === 0) {
    var a3 = Object.keys(n3), r;
    for (i3 = 0; i3 < a3.length; ++i3)
      r = a3[i3], r !== "removeListener" && this.removeAllListeners(r);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (e = n3[t], typeof e == "function")
    this.removeListener(t, e);
  else if (e !== void 0)
    for (i3 = e.length - 1; i3 >= 0; i3--)
      this.removeListener(t, e[i3]);
  return this;
};
function C6(s, t, e) {
  var n3 = s._events;
  if (n3 === void 0)
    return [];
  var i3 = n3[t];
  return i3 === void 0 ? [] : typeof i3 == "function" ? e ? [i3.listener || i3] : [i3] : e ? W6(i3) : b4(i3, i3.length);
}
o.prototype.listeners = function(t) {
  return C6(this, t, true);
}, o.prototype.rawListeners = function(t) {
  return C6(this, t, false);
}, o.listenerCount = function(s, t) {
  return typeof s.listenerCount == "function" ? s.listenerCount(t) : E5.call(s, t);
}, o.prototype.listenerCount = E5;
function E5(s) {
  var t = this._events;
  if (t !== void 0) {
    var e = t[s];
    if (typeof e == "function")
      return 1;
    if (e !== void 0)
      return e.length;
  }
  return 0;
}
o.prototype.eventNames = function() {
  return this._eventsCount > 0 ? f5(this._events) : [];
};
function b4(s, t) {
  for (var e = new Array(t), n3 = 0; n3 < t; ++n3)
    e[n3] = s[n3];
  return e;
}
function I3(s, t) {
  for (; t + 1 < s.length; t++)
    s[t] = s[t + 1];
  s.pop();
}
function W6(s) {
  for (var t = new Array(s.length), e = 0; e < t.length; ++e)
    t[e] = s[e].listener || s[e];
  return t;
}
function M5(s, t) {
  return new Promise(function(e, n3) {
    function i3(r) {
      s.removeListener(t, a3), n3(r);
    }
    function a3() {
      typeof s.removeListener == "function" && s.removeListener("error", i3), e([].slice.call(arguments));
    }
    R4(s, t, a3, { once: true }), t !== "error" && z5(s, i3, { once: true });
  });
}
function z5(s, t, e) {
  typeof s.on == "function" && R4(s, "error", t, e);
}
function R4(s, t, e, n3) {
  if (typeof s.on == "function")
    n3.once ? s.once(t, e) : s.on(t, e);
  else if (typeof s.addEventListener == "function")
    s.addEventListener(t, function i3(a3) {
      n3.once && s.removeEventListener(t, i3), e(a3);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof s);
}
var O5 = "wc";
var d4 = "Web3Wallet";
var K3 = `${O5}@2:${d4}:`;
var X4 = class extends l.exports {
  constructor() {
    super();
  }
};
var x3 = class {
  constructor(t) {
    this.opts = t;
  }
};
var P3 = class {
  constructor(t) {
    this.client = t;
  }
};
var D2 = class extends P3 {
  constructor(t) {
    super(t), this.init = async () => {
      this.signClient = await cs3.init({ core: this.client.core, metadata: this.client.metadata }), this.authClient = await Nr.init({ core: this.client.core, projectId: "", metadata: this.client.metadata }), this.initializeEventListeners();
    }, this.pair = async (e) => {
      await this.client.core.pairing.pair(e);
    }, this.approveSession = async (e) => {
      const { topic: n3, acknowledged: i3 } = await this.signClient.approve({ id: e.id, namespaces: e.namespaces });
      return await i3(), this.signClient.session.get(n3);
    }, this.rejectSession = async (e) => await this.signClient.reject(e), this.updateSession = async (e) => await (await this.signClient.update(e)).acknowledged(), this.extendSession = async (e) => await (await this.signClient.extend(e)).acknowledged(), this.respondSessionRequest = async (e) => await this.signClient.respond(e), this.disconnectSession = async (e) => await this.signClient.disconnect(e), this.emitSessionEvent = async (e) => await this.signClient.emit(e), this.getActiveSessions = () => this.signClient.session.getAll().reduce((e, n3) => (e[n3.topic] = n3, e), {}), this.getPendingSessionProposals = () => this.signClient.proposal.getAll(), this.getPendingSessionRequests = () => this.signClient.getPendingSessionRequests(), this.respondAuthRequest = async (e, n3) => await this.authClient.respond(e, n3), this.getPendingAuthRequests = () => this.authClient.requests.getAll().filter((e) => "requester" in e), this.formatMessage = (e, n3) => this.authClient.formatMessage(e, n3), this.onSessionRequest = (e) => {
      this.client.events.emit("session_request", e);
    }, this.onSessionProposal = (e) => {
      this.client.events.emit("session_proposal", e);
    }, this.onSessionDelete = (e) => {
      this.client.events.emit("session_delete", e);
    }, this.onAuthRequest = (e) => {
      this.client.events.emit("auth_request", e);
    }, this.initializeEventListeners = () => {
      this.signClient.events.on("session_proposal", this.onSessionProposal), this.signClient.events.on("session_request", this.onSessionRequest), this.signClient.events.on("session_delete", this.onSessionDelete), this.authClient.on("auth_request", this.onAuthRequest);
    }, this.signClient = {}, this.authClient = {};
  }
};
var p5 = class extends x3 {
  constructor(t) {
    super(t), this.events = new l.exports(), this.on = (e, n3) => this.events.on(e, n3), this.once = (e, n3) => this.events.once(e, n3), this.off = (e, n3) => this.events.off(e, n3), this.removeListener = (e, n3) => this.events.removeListener(e, n3), this.pair = async (e) => {
      try {
        return await this.engine.pair(e);
      } catch (n3) {
        throw this.logger.error(n3.message), n3;
      }
    }, this.approveSession = async (e) => {
      try {
        return await this.engine.approveSession(e);
      } catch (n3) {
        throw this.logger.error(n3.message), n3;
      }
    }, this.rejectSession = async (e) => {
      try {
        return await this.engine.rejectSession(e);
      } catch (n3) {
        throw this.logger.error(n3.message), n3;
      }
    }, this.updateSession = async (e) => {
      try {
        return await this.engine.updateSession(e);
      } catch (n3) {
        throw this.logger.error(n3.message), n3;
      }
    }, this.extendSession = async (e) => {
      try {
        return await this.engine.extendSession(e);
      } catch (n3) {
        throw this.logger.error(n3.message), n3;
      }
    }, this.respondSessionRequest = async (e) => {
      try {
        return await this.engine.respondSessionRequest(e);
      } catch (n3) {
        throw this.logger.error(n3.message), n3;
      }
    }, this.disconnectSession = async (e) => {
      try {
        return await this.engine.disconnectSession(e);
      } catch (n3) {
        throw this.logger.error(n3.message), n3;
      }
    }, this.emitSessionEvent = async (e) => {
      try {
        return await this.engine.emitSessionEvent(e);
      } catch (n3) {
        throw this.logger.error(n3.message), n3;
      }
    }, this.getActiveSessions = () => {
      try {
        return this.engine.getActiveSessions();
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.getPendingSessionProposals = () => {
      try {
        return this.engine.getPendingSessionProposals();
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.respondAuthRequest = async (e, n3) => {
      try {
        return await this.engine.respondAuthRequest(e, n3);
      } catch (i3) {
        throw this.logger.error(i3.message), i3;
      }
    }, this.getPendingAuthRequests = () => {
      try {
        return this.engine.getPendingAuthRequests();
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.formatMessage = (e, n3) => {
      try {
        return this.engine.formatMessage(e, n3);
      } catch (i3) {
        throw this.logger.error(i3.message), i3;
      }
    }, this.metadata = t.metadata, this.name = t.name || d4, this.core = t.core, this.logger = this.core.logger, this.engine = new D2(this);
  }
  static async init(t) {
    const e = new p5(t);
    return await e.initialize(), e;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.engine.init(), this.logger.info("Web3Wallet Initialization Success");
    } catch (t) {
      throw this.logger.info("Web3Wallet Initialization Failure"), this.logger.error(t.message), t;
    }
  }
};
var G6 = p5;

// node_modules/@thirdweb-dev/wallets/dist/smart-wallet-e0f242d2.browser.esm.js
init_lib3();

// node_modules/@thirdweb-dev/wallets/dist/wc-c6a6a61c.browser.esm.js
init_shim();
var TW_WC_PROJECT_ID = "145769e410f16970a79ff77b2d89a1e0";
var WC_RELAY_URL = "wss://relay.walletconnect.com";
var EIP155_SIGNING_METHODS = {
  PERSONAL_SIGN: "personal_sign",
  ETH_SIGN: "eth_sign",
  ETH_SIGN_TRANSACTION: "eth_signTransaction",
  ETH_SIGN_TYPED_DATA: "eth_signTypedData",
  ETH_SIGN_TYPED_DATA_V3: "eth_signTypedData_v3",
  ETH_SIGN_TYPED_DATA_V4: "eth_signTypedData_v4",
  ETH_SEND_TRANSACTION: "eth_sendTransaction",
  SWITCH_CHAIN: "wallet_switchEthereumChain"
};

// node_modules/@thirdweb-dev/wallets/dist/smart-wallet-e0f242d2.browser.esm.js
init_esm3();

// node_modules/@walletconnect/client/dist/esm/index.js
init_shim();

// node_modules/@walletconnect/client/node_modules/@walletconnect/core/dist/esm/index.js
init_shim();

// node_modules/@walletconnect/client/node_modules/@walletconnect/utils/dist/esm/index.js
init_shim();

// node_modules/@walletconnect/browser-utils/dist/esm/index.js
init_shim();

// node_modules/@walletconnect/browser-utils/dist/esm/browser.js
init_shim();
var windowMetadata = __toESM(require_cjs7());
var windowGetters = __toESM(require_cjs6());

// node_modules/@walletconnect/browser-utils/node_modules/detect-browser/es/index.js
init_shim();
var __spreadArrays = function() {
  for (var s = 0, i3 = 0, il = arguments.length; i3 < il; i3++)
    s += arguments[i3].length;
  for (var r = Array(s), k3 = 0, i3 = 0; i3 < il; i3++)
    for (var a3 = arguments[i3], j6 = 0, jl = a3.length; j6 < jl; j6++, k3++)
      r[k3] = a3[j6];
  return r;
};
var BrowserInfo = function() {
  function BrowserInfo2(name, version, os4) {
    this.name = name;
    this.version = version;
    this.os = os4;
    this.type = "browser";
  }
  return BrowserInfo2;
}();
var NodeInfo = function() {
  function NodeInfo2(version) {
    this.version = version;
    this.type = "node";
    this.name = "node";
    this.os = import_process.default.platform;
  }
  return NodeInfo2;
}();
var SearchBotDeviceInfo = function() {
  function SearchBotDeviceInfo2(name, version, os4, bot) {
    this.name = name;
    this.version = version;
    this.os = os4;
    this.bot = bot;
    this.type = "bot-device";
  }
  return SearchBotDeviceInfo2;
}();
var BotInfo = function() {
  function BotInfo2() {
    this.type = "bot";
    this.bot = true;
    this.name = "bot";
    this.version = null;
    this.os = null;
  }
  return BotInfo2;
}();
var ReactNativeInfo = function() {
  function ReactNativeInfo2() {
    this.type = "react-native";
    this.name = "react-native";
    this.version = null;
    this.os = null;
  }
  return ReactNativeInfo2;
}();
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FBAV\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["searchbot", SEARCHBOX_UA_REGEX]
];
var operatingSystemRules = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function detect2(userAgent) {
  if (!!userAgent) {
    return parseUserAgent(userAgent);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
function matchUserAgent(ua) {
  return ua !== "" && userAgentRules.reduce(function(matched, _a) {
    var browser = _a[0], regex = _a[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex.exec(ua);
    return !!uaMatch && [browser, uaMatch];
  }, false);
}
function parseUserAgent(ua) {
  var matchedRule = matchUserAgent(ua);
  if (!matchedRule) {
    return null;
  }
  var name = matchedRule[0], match = matchedRule[1];
  if (name === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match[1] && match[1].split(/[._]/).slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArrays(versionParts, createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length));
    }
  } else {
    versionParts = [];
  }
  var version = versionParts.join(".");
  var os4 = detectOS(ua);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name, version, os4, searchBotMatch[1]);
  }
  return new BrowserInfo(name, version, os4);
}
function detectOS(ua) {
  for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
    var _a = operatingSystemRules[ii], os4 = _a[0], regex = _a[1];
    var match = regex.exec(ua);
    if (match) {
      return os4;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode2 = typeof import_process.default !== "undefined" && import_process.default.version;
  return isNode2 ? new NodeInfo(import_process.default.version.slice(1)) : null;
}
function createVersionParts(count) {
  var output = [];
  for (var ii = 0; ii < count; ii++) {
    output.push("0");
  }
  return output;
}

// node_modules/@walletconnect/browser-utils/dist/esm/browser.js
function detectEnv(userAgent) {
  return detect2(userAgent);
}
function detectOS2() {
  const env = detectEnv();
  return env && env.os ? env.os : void 0;
}
function isAndroid() {
  const os4 = detectOS2();
  return os4 ? os4.toLowerCase().includes("android") : false;
}
function isIOS() {
  const os4 = detectOS2();
  return os4 ? os4.toLowerCase().includes("ios") || os4.toLowerCase().includes("mac") && navigator.maxTouchPoints > 1 : false;
}
function isMobile() {
  const os4 = detectOS2();
  return os4 ? isAndroid() || isIOS() : false;
}
function isNode() {
  const env = detectEnv();
  const result = env && env.name ? env.name.toLowerCase() === "node" : false;
  return result;
}
function isBrowser2() {
  const result = !isNode() && !!getNavigator2();
  return result;
}
var getNavigator2 = windowGetters.getNavigator;
var getLocation2 = windowGetters.getLocation;
var getLocalStorage2 = windowGetters.getLocalStorage;
function getClientMeta() {
  return windowMetadata.getWindowMetadata();
}

// node_modules/@walletconnect/browser-utils/dist/esm/json.js
init_shim();

// node_modules/@walletconnect/browser-utils/node_modules/@walletconnect/safe-json/dist/esm/index.js
init_shim();
function safeJsonParse2(value) {
  if (typeof value !== "string") {
    throw new Error(`Cannot safe json parse value of type ${typeof value}`);
  }
  try {
    return JSON.parse(value);
  } catch (_a) {
    return value;
  }
}
function safeJsonStringify2(value) {
  return typeof value === "string" ? value : JSON.stringify(value);
}

// node_modules/@walletconnect/browser-utils/dist/esm/json.js
var safeJsonParse3 = safeJsonParse2;
var safeJsonStringify3 = safeJsonStringify2;

// node_modules/@walletconnect/browser-utils/dist/esm/local.js
init_shim();
function setLocal(key, data) {
  const raw = safeJsonStringify3(data);
  const local = getLocalStorage2();
  if (local) {
    local.setItem(key, raw);
  }
}
function getLocal(key) {
  let data = null;
  let raw = null;
  const local = getLocalStorage2();
  if (local) {
    raw = local.getItem(key);
  }
  data = raw ? safeJsonParse3(raw) : raw;
  return data;
}
function removeLocal(key) {
  const local = getLocalStorage2();
  if (local) {
    local.removeItem(key);
  }
}

// node_modules/@walletconnect/browser-utils/dist/esm/mobile.js
init_shim();
var mobileLinkChoiceKey = "WALLETCONNECT_DEEPLINK_CHOICE";

// node_modules/@walletconnect/browser-utils/dist/esm/registry.js
init_shim();

// node_modules/@walletconnect/client/node_modules/@walletconnect/utils/dist/esm/constants.js
init_shim();
var reservedEvents = [
  "session_request",
  "session_update",
  "exchange_key",
  "connect",
  "disconnect",
  "display_uri",
  "modal_closed",
  "transport_open",
  "transport_close",
  "transport_error"
];
var signingMethods = [
  "eth_sendTransaction",
  "eth_signTransaction",
  "eth_sign",
  "eth_signTypedData",
  "eth_signTypedData_v1",
  "eth_signTypedData_v2",
  "eth_signTypedData_v3",
  "eth_signTypedData_v4",
  "personal_sign",
  "wallet_addEthereumChain",
  "wallet_switchEthereumChain",
  "wallet_getPermissions",
  "wallet_requestPermissions",
  "wallet_registerOnboarding",
  "wallet_watchAsset",
  "wallet_scanQRCode"
];

// node_modules/@walletconnect/client/node_modules/@walletconnect/utils/dist/esm/encoding.js
init_shim();
var import_bn = __toESM(require_bn());
init_esm4();
function convertArrayBufferToHex(arrBuf, noPrefix) {
  return arrayToHex(new Uint8Array(arrBuf), !noPrefix);
}
function convertUtf8ToBuffer(utf8) {
  return utf8ToBuffer(utf8);
}
function convertUtf8ToHex(utf8, noPrefix) {
  return utf8ToHex(utf8, !noPrefix);
}
function convertHexToArrayBuffer(hex) {
  return hexToArray(hex).buffer;
}
function convertNumberToHex(num, noPrefix) {
  const hex = removeHexPrefix(sanitizeHex(new import_bn.default(num).toString(16)));
  return noPrefix ? hex : addHexPrefix(hex);
}

// node_modules/@walletconnect/client/node_modules/@walletconnect/utils/dist/esm/ethereum.js
init_shim();
var import_js_sha3 = __toESM(require_sha3());
init_esm4();

// node_modules/@walletconnect/client/node_modules/@walletconnect/utils/dist/esm/misc.js
init_shim();
init_esm4();
init_esm3();
function sanitizeHex2(hex) {
  return sanitizeHex(hex);
}
function removeHexLeadingZeros2(hex) {
  return removeHexLeadingZeros(addHexPrefix(hex));
}
var payloadId2 = payloadId;
function uuid() {
  const result = ((a3, b5) => {
    for (b5 = a3 = ""; a3++ < 36; b5 += a3 * 51 & 52 ? (a3 ^ 15 ? 8 ^ Math.random() * (a3 ^ 20 ? 16 : 4) : 4).toString(16) : "-") {
    }
    return b5;
  })();
  return result;
}

// node_modules/@walletconnect/client/node_modules/@walletconnect/utils/dist/esm/validators.js
init_shim();
init_esm4();
function isEmptyString(value) {
  return value === "" || typeof value === "string" && value.trim() === "";
}
function isEmptyArray(array) {
  return !(array && array.length);
}
function isHexString2(value, length) {
  return isHexString(value, length);
}
function isJsonRpcRequest2(object) {
  return typeof object.method !== "undefined";
}
function isJsonRpcResponseSuccess(object) {
  return typeof object.result !== "undefined";
}
function isJsonRpcResponseError(object) {
  return typeof object.error !== "undefined";
}
function isInternalEvent(object) {
  return typeof object.event !== "undefined";
}
function isReservedEvent(event) {
  return reservedEvents.includes(event) || event.startsWith("wc_");
}
function isSilentPayload(request) {
  if (request.method.startsWith("wc_")) {
    return true;
  }
  if (signingMethods.includes(request.method)) {
    return false;
  }
  return true;
}

// node_modules/@walletconnect/client/node_modules/@walletconnect/utils/dist/esm/ethereum.js
function toChecksumAddress(address) {
  address = removeHexPrefix(address.toLowerCase());
  const hash = removeHexPrefix((0, import_js_sha3.keccak_256)(convertUtf8ToBuffer(address)));
  let checksum = "";
  for (let i3 = 0; i3 < address.length; i3++) {
    if (parseInt(hash[i3], 16) > 7) {
      checksum += address[i3].toUpperCase();
    } else {
      checksum += address[i3];
    }
  }
  return addHexPrefix(checksum);
}
var isValidAddress = (address) => {
  if (!address) {
    return false;
  } else if (address.toLowerCase().substring(0, 2) !== "0x") {
    return false;
  } else if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {
    return false;
  } else if (/^(0x)?[0-9a-f]{40}$/.test(address) || /^(0x)?[0-9A-F]{40}$/.test(address)) {
    return true;
  } else {
    return address === toChecksumAddress(address);
  }
};
function parsePersonalSign(params) {
  if (!isEmptyArray(params) && !isHexString2(params[0])) {
    params[0] = convertUtf8ToHex(params[0]);
  }
  return params;
}
function parseTransactionData(txData) {
  if (typeof txData.type !== "undefined" && txData.type !== "0")
    return txData;
  if (typeof txData.from === "undefined" || !isValidAddress(txData.from)) {
    throw new Error(`Transaction object must include a valid 'from' value.`);
  }
  function parseHexValues(value) {
    let result = value;
    if (typeof value === "number" || typeof value === "string" && !isEmptyString(value)) {
      if (!isHexString2(value)) {
        result = convertNumberToHex(value);
      } else if (typeof value === "string") {
        result = sanitizeHex2(value);
      }
    }
    if (typeof result === "string") {
      result = removeHexLeadingZeros2(result);
    }
    return result;
  }
  const txDataRPC = {
    from: sanitizeHex2(txData.from),
    to: typeof txData.to === "undefined" ? void 0 : sanitizeHex2(txData.to),
    gasPrice: typeof txData.gasPrice === "undefined" ? "" : parseHexValues(txData.gasPrice),
    gas: typeof txData.gas === "undefined" ? typeof txData.gasLimit === "undefined" ? "" : parseHexValues(txData.gasLimit) : parseHexValues(txData.gas),
    value: typeof txData.value === "undefined" ? "" : parseHexValues(txData.value),
    nonce: typeof txData.nonce === "undefined" ? "" : parseHexValues(txData.nonce),
    data: typeof txData.data === "undefined" ? "" : sanitizeHex2(txData.data) || "0x"
  };
  const prunable = ["gasPrice", "gas", "value", "nonce"];
  Object.keys(txDataRPC).forEach((key) => {
    if ((typeof txDataRPC[key] === "undefined" || typeof txDataRPC[key] === "string" && !txDataRPC[key].trim().length) && prunable.includes(key)) {
      delete txDataRPC[key];
    }
  });
  return txDataRPC;
}

// node_modules/@walletconnect/client/node_modules/@walletconnect/utils/dist/esm/payload.js
init_shim();
function formatRpcError(error) {
  const message = error.message || "Failed or Rejected Request";
  let code = -32e3;
  if (error && !error.code) {
    switch (message) {
      case "Parse error":
        code = -32700;
        break;
      case "Invalid request":
        code = -32600;
        break;
      case "Method not found":
        code = -32601;
        break;
      case "Invalid params":
        code = -32602;
        break;
      case "Internal error":
        code = -32603;
        break;
      default:
        code = -32e3;
        break;
    }
  }
  const result = {
    code,
    message
  };
  if (error.data) {
    result.data = error.data;
  }
  return result;
}

// node_modules/@walletconnect/client/node_modules/@walletconnect/utils/dist/esm/session.js
init_shim();

// node_modules/@walletconnect/client/node_modules/@walletconnect/utils/dist/esm/url.js
init_shim();
var queryStringUtils = __toESM(require_query_string3());
function parseQueryString(queryString) {
  return queryStringUtils.parse(queryString);
}

// node_modules/@walletconnect/client/node_modules/@walletconnect/utils/dist/esm/session.js
function isWalletConnectSession(object) {
  return typeof object.bridge !== "undefined";
}
function parseWalletConnectUri(str) {
  const pathStart = str.indexOf(":");
  const pathEnd = str.indexOf("?") !== -1 ? str.indexOf("?") : void 0;
  const protocol = str.substring(0, pathStart);
  const path = str.substring(pathStart + 1, pathEnd);
  function parseRequiredParams(path2) {
    const separator = "@";
    const values = path2.split(separator);
    const requiredParams2 = {
      handshakeTopic: values[0],
      version: parseInt(values[1], 10)
    };
    return requiredParams2;
  }
  const requiredParams = parseRequiredParams(path);
  const queryString = typeof pathEnd !== "undefined" ? str.substr(pathEnd) : "";
  function parseQueryParams(queryString2) {
    const result2 = parseQueryString(queryString2);
    const parameters = {
      key: result2.key || "",
      bridge: result2.bridge || ""
    };
    return parameters;
  }
  const queryParams = parseQueryParams(queryString);
  const result = Object.assign(Object.assign({ protocol }, requiredParams), queryParams);
  return result;
}

// node_modules/@walletconnect/socket-transport/dist/esm/index.js
init_shim();

// node_modules/@walletconnect/socket-transport/node_modules/@walletconnect/utils/dist/esm/index.js
init_shim();

// node_modules/@walletconnect/socket-transport/node_modules/@walletconnect/utils/dist/esm/constants.js
init_shim();

// node_modules/@walletconnect/socket-transport/node_modules/@walletconnect/utils/dist/esm/encoding.js
init_shim();
var import_bn2 = __toESM(require_bn2());
init_esm4();

// node_modules/@walletconnect/socket-transport/node_modules/@walletconnect/utils/dist/esm/ethereum.js
init_shim();
var import_js_sha32 = __toESM(require_sha3());
init_esm4();

// node_modules/@walletconnect/socket-transport/node_modules/@walletconnect/utils/dist/esm/misc.js
init_shim();
init_esm4();
init_esm3();

// node_modules/@walletconnect/socket-transport/node_modules/@walletconnect/utils/dist/esm/validators.js
init_shim();
init_esm4();

// node_modules/@walletconnect/socket-transport/node_modules/@walletconnect/utils/dist/esm/payload.js
init_shim();

// node_modules/@walletconnect/socket-transport/node_modules/@walletconnect/utils/dist/esm/session.js
init_shim();

// node_modules/@walletconnect/socket-transport/node_modules/@walletconnect/utils/dist/esm/url.js
init_shim();
var queryStringUtils2 = __toESM(require_query_string4());
function getQueryString(url) {
  const pathEnd = url.indexOf("?") !== -1 ? url.indexOf("?") : void 0;
  const queryString = typeof pathEnd !== "undefined" ? url.substr(pathEnd) : "";
  return queryString;
}
function appendToQueryString(queryString, newQueryParams) {
  let queryParams = parseQueryString2(queryString);
  queryParams = Object.assign(Object.assign({}, queryParams), newQueryParams);
  queryString = formatQueryString(queryParams);
  return queryString;
}
function parseQueryString2(queryString) {
  return queryStringUtils2.parse(queryString);
}
function formatQueryString(queryParams) {
  return queryStringUtils2.stringify(queryParams);
}

// node_modules/@walletconnect/socket-transport/dist/esm/network.js
init_shim();
var NetworkMonitor = class {
  constructor() {
    this._eventEmitters = [];
    if (typeof window !== "undefined" && typeof window.addEventListener !== "undefined") {
      window.addEventListener("online", () => this.trigger("online"));
      window.addEventListener("offline", () => this.trigger("offline"));
    }
  }
  on(event, callback) {
    this._eventEmitters.push({
      event,
      callback
    });
  }
  trigger(event) {
    let eventEmitters = [];
    if (event) {
      eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === event);
    }
    eventEmitters.forEach((eventEmitter) => {
      eventEmitter.callback();
    });
  }
};
var network_default = NetworkMonitor;

// node_modules/@walletconnect/socket-transport/dist/esm/index.js
var WS2 = typeof global.WebSocket !== "undefined" ? global.WebSocket : require_browser4();
var SocketTransport = class {
  constructor(opts) {
    this.opts = opts;
    this._queue = [];
    this._events = [];
    this._subscriptions = [];
    this._protocol = opts.protocol;
    this._version = opts.version;
    this._url = "";
    this._netMonitor = null;
    this._socket = null;
    this._nextSocket = null;
    this._subscriptions = opts.subscriptions || [];
    this._netMonitor = opts.netMonitor || new network_default();
    if (!opts.url || typeof opts.url !== "string") {
      throw new Error("Missing or invalid WebSocket url");
    }
    this._url = opts.url;
    this._netMonitor.on("online", () => this._socketCreate());
  }
  set readyState(value) {
  }
  get readyState() {
    return this._socket ? this._socket.readyState : -1;
  }
  set connecting(value) {
  }
  get connecting() {
    return this.readyState === 0;
  }
  set connected(value) {
  }
  get connected() {
    return this.readyState === 1;
  }
  set closing(value) {
  }
  get closing() {
    return this.readyState === 2;
  }
  set closed(value) {
  }
  get closed() {
    return this.readyState === 3;
  }
  open() {
    this._socketCreate();
  }
  close() {
    this._socketClose();
  }
  send(message, topic, silent) {
    if (!topic || typeof topic !== "string") {
      throw new Error("Missing or invalid topic field");
    }
    this._socketSend({
      topic,
      type: "pub",
      payload: message,
      silent: !!silent
    });
  }
  subscribe(topic) {
    this._socketSend({
      topic,
      type: "sub",
      payload: "",
      silent: true
    });
  }
  on(event, callback) {
    this._events.push({ event, callback });
  }
  _socketCreate() {
    if (this._nextSocket) {
      return;
    }
    const url = getWebSocketUrl(this._url, this._protocol, this._version);
    this._nextSocket = new WS2(url);
    if (!this._nextSocket) {
      throw new Error("Failed to create socket");
    }
    this._nextSocket.onmessage = (event) => this._socketReceive(event);
    this._nextSocket.onopen = () => this._socketOpen();
    this._nextSocket.onerror = (event) => this._socketError(event);
    this._nextSocket.onclose = () => {
      setTimeout(() => {
        this._nextSocket = null;
        this._socketCreate();
      }, 1e3);
    };
  }
  _socketOpen() {
    this._socketClose();
    this._socket = this._nextSocket;
    this._nextSocket = null;
    this._queueSubscriptions();
    this._pushQueue();
  }
  _socketClose() {
    if (this._socket) {
      this._socket.onclose = () => {
      };
      this._socket.close();
    }
  }
  _socketSend(socketMessage) {
    const message = JSON.stringify(socketMessage);
    if (this._socket && this._socket.readyState === 1) {
      this._socket.send(message);
    } else {
      this._setToQueue(socketMessage);
      this._socketCreate();
    }
  }
  async _socketReceive(event) {
    let socketMessage;
    try {
      socketMessage = JSON.parse(event.data);
    } catch (error) {
      return;
    }
    this._socketSend({
      topic: socketMessage.topic,
      type: "ack",
      payload: "",
      silent: true
    });
    if (this._socket && this._socket.readyState === 1) {
      const events = this._events.filter((event2) => event2.event === "message");
      if (events && events.length) {
        events.forEach((event2) => event2.callback(socketMessage));
      }
    }
  }
  _socketError(e) {
    const events = this._events.filter((event) => event.event === "error");
    if (events && events.length) {
      events.forEach((event) => event.callback(e));
    }
  }
  _queueSubscriptions() {
    const subscriptions = this._subscriptions;
    subscriptions.forEach((topic) => this._queue.push({
      topic,
      type: "sub",
      payload: "",
      silent: true
    }));
    this._subscriptions = this.opts.subscriptions || [];
  }
  _setToQueue(socketMessage) {
    this._queue.push(socketMessage);
  }
  _pushQueue() {
    const queue = this._queue;
    queue.forEach((socketMessage) => this._socketSend(socketMessage));
    this._queue = [];
  }
};
function getWebSocketUrl(_url, protocol, version) {
  var _a, _b;
  const url = _url.startsWith("https") ? _url.replace("https", "wss") : _url.startsWith("http") ? _url.replace("http", "ws") : _url;
  const splitUrl = url.split("?");
  const params = isBrowser2() ? {
    protocol,
    version,
    env: "browser",
    host: ((_a = getLocation2()) === null || _a === void 0 ? void 0 : _a.host) || ""
  } : {
    protocol,
    version,
    env: ((_b = detectEnv()) === null || _b === void 0 ? void 0 : _b.name) || ""
  };
  const queryString = appendToQueryString(getQueryString(splitUrl[1] || ""), params);
  return splitUrl[0] + "?" + queryString;
}
var esm_default2 = SocketTransport;

// node_modules/@walletconnect/client/node_modules/@walletconnect/core/dist/esm/errors.js
init_shim();
var ERROR_SESSION_CONNECTED = "Session currently connected";
var ERROR_SESSION_DISCONNECTED = "Session currently disconnected";
var ERROR_SESSION_REJECTED = "Session Rejected";
var ERROR_MISSING_JSON_RPC = "Missing JSON RPC response";
var ERROR_MISSING_RESULT = `JSON-RPC success response must include "result" field`;
var ERROR_MISSING_ERROR = `JSON-RPC error response must include "error" field`;
var ERROR_MISSING_METHOD = `JSON RPC request must have valid "method" value`;
var ERROR_MISSING_ID = `JSON RPC request must have valid "id" value`;
var ERROR_MISSING_REQUIRED = "Missing one of the required parameters: bridge / uri / session";
var ERROR_INVALID_RESPONSE = "JSON RPC response format is invalid";
var ERROR_INVALID_URI = "URI format is invalid";
var ERROR_QRCODE_MODAL_NOT_PROVIDED = "QRCode Modal not provided";
var ERROR_QRCODE_MODAL_USER_CLOSED = "User close QRCode Modal";

// node_modules/@walletconnect/client/node_modules/@walletconnect/core/dist/esm/events.js
init_shim();
var EventManager = class {
  constructor() {
    this._eventEmitters = [];
  }
  subscribe(eventEmitter) {
    this._eventEmitters.push(eventEmitter);
  }
  unsubscribe(event) {
    this._eventEmitters = this._eventEmitters.filter((x4) => x4.event !== event);
  }
  trigger(payload) {
    let eventEmitters = [];
    let event;
    if (isJsonRpcRequest2(payload)) {
      event = payload.method;
    } else if (isJsonRpcResponseSuccess(payload) || isJsonRpcResponseError(payload)) {
      event = `response:${payload.id}`;
    } else if (isInternalEvent(payload)) {
      event = payload.event;
    } else {
      event = "";
    }
    if (event) {
      eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === event);
    }
    if ((!eventEmitters || !eventEmitters.length) && !isReservedEvent(event) && !isInternalEvent(event)) {
      eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === "call_request");
    }
    eventEmitters.forEach((eventEmitter) => {
      if (isJsonRpcResponseError(payload)) {
        const error = new Error(payload.error.message);
        eventEmitter.callback(error, null);
      } else {
        eventEmitter.callback(null, payload);
      }
    });
  }
};
var events_default = EventManager;

// node_modules/@walletconnect/client/node_modules/@walletconnect/core/dist/esm/storage.js
init_shim();
var SessionStorage = class {
  constructor(storageId = "walletconnect") {
    this.storageId = storageId;
  }
  getSession() {
    let session = null;
    const json = getLocal(this.storageId);
    if (json && isWalletConnectSession(json)) {
      session = json;
    }
    return session;
  }
  setSession(session) {
    setLocal(this.storageId, session);
    return session;
  }
  removeSession() {
    removeLocal(this.storageId);
  }
};
var storage_default = SessionStorage;

// node_modules/@walletconnect/client/node_modules/@walletconnect/core/dist/esm/url.js
init_shim();
var domain = "walletconnect.org";
var alphanumerical = "abcdefghijklmnopqrstuvwxyz0123456789";
var bridges = alphanumerical.split("").map((char) => `https://${char}.bridge.walletconnect.org`);
function extractHostname(url) {
  let hostname = url.indexOf("//") > -1 ? url.split("/")[2] : url.split("/")[0];
  hostname = hostname.split(":")[0];
  hostname = hostname.split("?")[0];
  return hostname;
}
function extractRootDomain(url) {
  return extractHostname(url).split(".").slice(-2).join(".");
}
function randomBridgeIndex() {
  return Math.floor(Math.random() * bridges.length);
}
function selectRandomBridgeUrl() {
  return bridges[randomBridgeIndex()];
}
function shouldSelectRandomly(url) {
  return extractRootDomain(url) === domain;
}
function getBridgeUrl(url) {
  if (shouldSelectRandomly(url)) {
    return selectRandomBridgeUrl();
  }
  return url;
}

// node_modules/@walletconnect/client/node_modules/@walletconnect/core/dist/esm/index.js
var Connector = class {
  constructor(opts) {
    this.protocol = "wc";
    this.version = 1;
    this._bridge = "";
    this._key = null;
    this._clientId = "";
    this._clientMeta = null;
    this._peerId = "";
    this._peerMeta = null;
    this._handshakeId = 0;
    this._handshakeTopic = "";
    this._connected = false;
    this._accounts = [];
    this._chainId = 0;
    this._networkId = 0;
    this._rpcUrl = "";
    this._eventManager = new events_default();
    this._clientMeta = getClientMeta() || opts.connectorOpts.clientMeta || null;
    this._cryptoLib = opts.cryptoLib;
    this._sessionStorage = opts.sessionStorage || new storage_default(opts.connectorOpts.storageId);
    this._qrcodeModal = opts.connectorOpts.qrcodeModal;
    this._qrcodeModalOptions = opts.connectorOpts.qrcodeModalOptions;
    this._signingMethods = [...signingMethods, ...opts.connectorOpts.signingMethods || []];
    if (!opts.connectorOpts.bridge && !opts.connectorOpts.uri && !opts.connectorOpts.session) {
      throw new Error(ERROR_MISSING_REQUIRED);
    }
    if (opts.connectorOpts.bridge) {
      this.bridge = getBridgeUrl(opts.connectorOpts.bridge);
    }
    if (opts.connectorOpts.uri) {
      this.uri = opts.connectorOpts.uri;
    }
    const session = opts.connectorOpts.session || this._getStorageSession();
    if (session) {
      this.session = session;
    }
    if (this.handshakeId) {
      this._subscribeToSessionResponse(this.handshakeId, "Session request rejected");
    }
    this._transport = opts.transport || new esm_default2({
      protocol: this.protocol,
      version: this.version,
      url: this.bridge,
      subscriptions: [this.clientId]
    });
    this._subscribeToInternalEvents();
    this._initTransport();
    if (opts.connectorOpts.uri) {
      this._subscribeToSessionRequest();
    }
    if (opts.pushServerOpts) {
      this._registerPushServer(opts.pushServerOpts);
    }
  }
  set bridge(value) {
    if (!value) {
      return;
    }
    this._bridge = value;
  }
  get bridge() {
    return this._bridge;
  }
  set key(value) {
    if (!value) {
      return;
    }
    const key = convertHexToArrayBuffer(value);
    this._key = key;
  }
  get key() {
    if (this._key) {
      const key = convertArrayBufferToHex(this._key, true);
      return key;
    }
    return "";
  }
  set clientId(value) {
    if (!value) {
      return;
    }
    this._clientId = value;
  }
  get clientId() {
    let clientId = this._clientId;
    if (!clientId) {
      clientId = this._clientId = uuid();
    }
    return this._clientId;
  }
  set peerId(value) {
    if (!value) {
      return;
    }
    this._peerId = value;
  }
  get peerId() {
    return this._peerId;
  }
  set clientMeta(value) {
  }
  get clientMeta() {
    let clientMeta = this._clientMeta;
    if (!clientMeta) {
      clientMeta = this._clientMeta = getClientMeta();
    }
    return clientMeta;
  }
  set peerMeta(value) {
    this._peerMeta = value;
  }
  get peerMeta() {
    const peerMeta = this._peerMeta;
    return peerMeta;
  }
  set handshakeTopic(value) {
    if (!value) {
      return;
    }
    this._handshakeTopic = value;
  }
  get handshakeTopic() {
    return this._handshakeTopic;
  }
  set handshakeId(value) {
    if (!value) {
      return;
    }
    this._handshakeId = value;
  }
  get handshakeId() {
    return this._handshakeId;
  }
  get uri() {
    const _uri = this._formatUri();
    return _uri;
  }
  set uri(value) {
    if (!value) {
      return;
    }
    const { handshakeTopic, bridge, key } = this._parseUri(value);
    this.handshakeTopic = handshakeTopic;
    this.bridge = bridge;
    this.key = key;
  }
  set chainId(value) {
    this._chainId = value;
  }
  get chainId() {
    const chainId = this._chainId;
    return chainId;
  }
  set networkId(value) {
    this._networkId = value;
  }
  get networkId() {
    const networkId = this._networkId;
    return networkId;
  }
  set accounts(value) {
    this._accounts = value;
  }
  get accounts() {
    const accounts = this._accounts;
    return accounts;
  }
  set rpcUrl(value) {
    this._rpcUrl = value;
  }
  get rpcUrl() {
    const rpcUrl = this._rpcUrl;
    return rpcUrl;
  }
  set connected(value) {
  }
  get connected() {
    return this._connected;
  }
  set pending(value) {
  }
  get pending() {
    return !!this._handshakeTopic;
  }
  get session() {
    return {
      connected: this.connected,
      accounts: this.accounts,
      chainId: this.chainId,
      bridge: this.bridge,
      key: this.key,
      clientId: this.clientId,
      clientMeta: this.clientMeta,
      peerId: this.peerId,
      peerMeta: this.peerMeta,
      handshakeId: this.handshakeId,
      handshakeTopic: this.handshakeTopic
    };
  }
  set session(value) {
    if (!value) {
      return;
    }
    this._connected = value.connected;
    this.accounts = value.accounts;
    this.chainId = value.chainId;
    this.bridge = value.bridge;
    this.key = value.key;
    this.clientId = value.clientId;
    this.clientMeta = value.clientMeta;
    this.peerId = value.peerId;
    this.peerMeta = value.peerMeta;
    this.handshakeId = value.handshakeId;
    this.handshakeTopic = value.handshakeTopic;
  }
  on(event, callback) {
    const eventEmitter = {
      event,
      callback
    };
    this._eventManager.subscribe(eventEmitter);
  }
  off(event) {
    this._eventManager.unsubscribe(event);
  }
  async createInstantRequest(instantRequest) {
    this._key = await this._generateKey();
    const request = this._formatRequest({
      method: "wc_instantRequest",
      params: [
        {
          peerId: this.clientId,
          peerMeta: this.clientMeta,
          request: this._formatRequest(instantRequest)
        }
      ]
    });
    this.handshakeId = request.id;
    this.handshakeTopic = uuid();
    this._eventManager.trigger({
      event: "display_uri",
      params: [this.uri]
    });
    this.on("modal_closed", () => {
      throw new Error(ERROR_QRCODE_MODAL_USER_CLOSED);
    });
    const endInstantRequest = () => {
      this.killSession();
    };
    try {
      const result = await this._sendCallRequest(request);
      if (result) {
        endInstantRequest();
      }
      return result;
    } catch (error) {
      endInstantRequest();
      throw error;
    }
  }
  async connect(opts) {
    if (!this._qrcodeModal) {
      throw new Error(ERROR_QRCODE_MODAL_NOT_PROVIDED);
    }
    if (this.connected) {
      return {
        chainId: this.chainId,
        accounts: this.accounts
      };
    }
    await this.createSession(opts);
    return new Promise(async (resolve, reject) => {
      this.on("modal_closed", () => reject(new Error(ERROR_QRCODE_MODAL_USER_CLOSED)));
      this.on("connect", (error, payload) => {
        if (error) {
          return reject(error);
        }
        resolve(payload.params[0]);
      });
    });
  }
  async createSession(opts) {
    if (this._connected) {
      throw new Error(ERROR_SESSION_CONNECTED);
    }
    if (this.pending) {
      return;
    }
    this._key = await this._generateKey();
    const request = this._formatRequest({
      method: "wc_sessionRequest",
      params: [
        {
          peerId: this.clientId,
          peerMeta: this.clientMeta,
          chainId: opts && opts.chainId ? opts.chainId : null
        }
      ]
    });
    this.handshakeId = request.id;
    this.handshakeTopic = uuid();
    this._sendSessionRequest(request, "Session update rejected", {
      topic: this.handshakeTopic
    });
    this._eventManager.trigger({
      event: "display_uri",
      params: [this.uri]
    });
  }
  approveSession(sessionStatus) {
    if (this._connected) {
      throw new Error(ERROR_SESSION_CONNECTED);
    }
    this.chainId = sessionStatus.chainId;
    this.accounts = sessionStatus.accounts;
    this.networkId = sessionStatus.networkId || 0;
    this.rpcUrl = sessionStatus.rpcUrl || "";
    const sessionParams = {
      approved: true,
      chainId: this.chainId,
      networkId: this.networkId,
      accounts: this.accounts,
      rpcUrl: this.rpcUrl,
      peerId: this.clientId,
      peerMeta: this.clientMeta
    };
    const response = {
      id: this.handshakeId,
      jsonrpc: "2.0",
      result: sessionParams
    };
    this._sendResponse(response);
    this._connected = true;
    this._setStorageSession();
    this._eventManager.trigger({
      event: "connect",
      params: [
        {
          peerId: this.peerId,
          peerMeta: this.peerMeta,
          chainId: this.chainId,
          accounts: this.accounts
        }
      ]
    });
  }
  rejectSession(sessionError) {
    if (this._connected) {
      throw new Error(ERROR_SESSION_CONNECTED);
    }
    const message = sessionError && sessionError.message ? sessionError.message : ERROR_SESSION_REJECTED;
    const response = this._formatResponse({
      id: this.handshakeId,
      error: { message }
    });
    this._sendResponse(response);
    this._connected = false;
    this._eventManager.trigger({
      event: "disconnect",
      params: [{ message }]
    });
    this._removeStorageSession();
  }
  updateSession(sessionStatus) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    this.chainId = sessionStatus.chainId;
    this.accounts = sessionStatus.accounts;
    this.networkId = sessionStatus.networkId || 0;
    this.rpcUrl = sessionStatus.rpcUrl || "";
    const sessionParams = {
      approved: true,
      chainId: this.chainId,
      networkId: this.networkId,
      accounts: this.accounts,
      rpcUrl: this.rpcUrl
    };
    const request = this._formatRequest({
      method: "wc_sessionUpdate",
      params: [sessionParams]
    });
    this._sendSessionRequest(request, "Session update rejected");
    this._eventManager.trigger({
      event: "session_update",
      params: [
        {
          chainId: this.chainId,
          accounts: this.accounts
        }
      ]
    });
    this._manageStorageSession();
  }
  async killSession(sessionError) {
    const message = sessionError ? sessionError.message : "Session Disconnected";
    const sessionParams = {
      approved: false,
      chainId: null,
      networkId: null,
      accounts: null
    };
    const request = this._formatRequest({
      method: "wc_sessionUpdate",
      params: [sessionParams]
    });
    await this._sendRequest(request);
    this._handleSessionDisconnect(message);
  }
  async sendTransaction(tx) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const parsedTx = parseTransactionData(tx);
    const request = this._formatRequest({
      method: "eth_sendTransaction",
      params: [parsedTx]
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async signTransaction(tx) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const parsedTx = parseTransactionData(tx);
    const request = this._formatRequest({
      method: "eth_signTransaction",
      params: [parsedTx]
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async signMessage(params) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const request = this._formatRequest({
      method: "eth_sign",
      params
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async signPersonalMessage(params) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    params = parsePersonalSign(params);
    const request = this._formatRequest({
      method: "personal_sign",
      params
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async signTypedData(params) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const request = this._formatRequest({
      method: "eth_signTypedData",
      params
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async updateChain(chainParams) {
    if (!this._connected) {
      throw new Error("Session currently disconnected");
    }
    const request = this._formatRequest({
      method: "wallet_updateChain",
      params: [chainParams]
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  unsafeSend(request, options) {
    this._sendRequest(request, options);
    this._eventManager.trigger({
      event: "call_request_sent",
      params: [{ request, options }]
    });
    return new Promise((resolve, reject) => {
      this._subscribeToResponse(request.id, (error, payload) => {
        if (error) {
          reject(error);
          return;
        }
        if (!payload) {
          throw new Error(ERROR_MISSING_JSON_RPC);
        }
        resolve(payload);
      });
    });
  }
  async sendCustomRequest(request, options) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    switch (request.method) {
      case "eth_accounts":
        return this.accounts;
      case "eth_chainId":
        return convertNumberToHex(this.chainId);
      case "eth_sendTransaction":
      case "eth_signTransaction":
        if (request.params) {
          request.params[0] = parseTransactionData(request.params[0]);
        }
        break;
      case "personal_sign":
        if (request.params) {
          request.params = parsePersonalSign(request.params);
        }
        break;
      default:
        break;
    }
    const formattedRequest = this._formatRequest(request);
    const result = await this._sendCallRequest(formattedRequest, options);
    return result;
  }
  approveRequest(response) {
    if (isJsonRpcResponseSuccess(response)) {
      const formattedResponse = this._formatResponse(response);
      this._sendResponse(formattedResponse);
    } else {
      throw new Error(ERROR_MISSING_RESULT);
    }
  }
  rejectRequest(response) {
    if (isJsonRpcResponseError(response)) {
      const formattedResponse = this._formatResponse(response);
      this._sendResponse(formattedResponse);
    } else {
      throw new Error(ERROR_MISSING_ERROR);
    }
  }
  transportClose() {
    this._transport.close();
  }
  async _sendRequest(request, options) {
    const callRequest = this._formatRequest(request);
    const encryptionPayload = await this._encrypt(callRequest);
    const topic = typeof (options === null || options === void 0 ? void 0 : options.topic) !== "undefined" ? options.topic : this.peerId;
    const payload = JSON.stringify(encryptionPayload);
    const silent = typeof (options === null || options === void 0 ? void 0 : options.forcePushNotification) !== "undefined" ? !options.forcePushNotification : isSilentPayload(callRequest);
    this._transport.send(payload, topic, silent);
  }
  async _sendResponse(response) {
    const encryptionPayload = await this._encrypt(response);
    const topic = this.peerId;
    const payload = JSON.stringify(encryptionPayload);
    const silent = true;
    this._transport.send(payload, topic, silent);
  }
  async _sendSessionRequest(request, errorMsg, options) {
    this._sendRequest(request, options);
    this._subscribeToSessionResponse(request.id, errorMsg);
  }
  _sendCallRequest(request, options) {
    this._sendRequest(request, options);
    this._eventManager.trigger({
      event: "call_request_sent",
      params: [{ request, options }]
    });
    return this._subscribeToCallResponse(request.id);
  }
  _formatRequest(request) {
    if (typeof request.method === "undefined") {
      throw new Error(ERROR_MISSING_METHOD);
    }
    const formattedRequest = {
      id: typeof request.id === "undefined" ? payloadId2() : request.id,
      jsonrpc: "2.0",
      method: request.method,
      params: typeof request.params === "undefined" ? [] : request.params
    };
    return formattedRequest;
  }
  _formatResponse(response) {
    if (typeof response.id === "undefined") {
      throw new Error(ERROR_MISSING_ID);
    }
    const baseResponse = { id: response.id, jsonrpc: "2.0" };
    if (isJsonRpcResponseError(response)) {
      const error = formatRpcError(response.error);
      const errorResponse = Object.assign(Object.assign(Object.assign({}, baseResponse), response), { error });
      return errorResponse;
    } else if (isJsonRpcResponseSuccess(response)) {
      const successResponse = Object.assign(Object.assign({}, baseResponse), response);
      return successResponse;
    }
    throw new Error(ERROR_INVALID_RESPONSE);
  }
  _handleSessionDisconnect(errorMsg) {
    const message = errorMsg || "Session Disconnected";
    if (!this._connected) {
      if (this._qrcodeModal) {
        this._qrcodeModal.close();
      }
      removeLocal(mobileLinkChoiceKey);
    }
    if (this._connected) {
      this._connected = false;
    }
    if (this._handshakeId) {
      this._handshakeId = 0;
    }
    if (this._handshakeTopic) {
      this._handshakeTopic = "";
    }
    if (this._peerId) {
      this._peerId = "";
    }
    this._eventManager.trigger({
      event: "disconnect",
      params: [{ message }]
    });
    this._removeStorageSession();
    this.transportClose();
  }
  _handleSessionResponse(errorMsg, sessionParams) {
    if (sessionParams) {
      if (sessionParams.approved) {
        if (!this._connected) {
          this._connected = true;
          if (sessionParams.chainId) {
            this.chainId = sessionParams.chainId;
          }
          if (sessionParams.accounts) {
            this.accounts = sessionParams.accounts;
          }
          if (sessionParams.peerId && !this.peerId) {
            this.peerId = sessionParams.peerId;
          }
          if (sessionParams.peerMeta && !this.peerMeta) {
            this.peerMeta = sessionParams.peerMeta;
          }
          this._eventManager.trigger({
            event: "connect",
            params: [
              {
                peerId: this.peerId,
                peerMeta: this.peerMeta,
                chainId: this.chainId,
                accounts: this.accounts
              }
            ]
          });
        } else {
          if (sessionParams.chainId) {
            this.chainId = sessionParams.chainId;
          }
          if (sessionParams.accounts) {
            this.accounts = sessionParams.accounts;
          }
          this._eventManager.trigger({
            event: "session_update",
            params: [
              {
                chainId: this.chainId,
                accounts: this.accounts
              }
            ]
          });
        }
        this._manageStorageSession();
      } else {
        this._handleSessionDisconnect(errorMsg);
      }
    } else {
      this._handleSessionDisconnect(errorMsg);
    }
  }
  async _handleIncomingMessages(socketMessage) {
    const activeTopics = [this.clientId, this.handshakeTopic];
    if (!activeTopics.includes(socketMessage.topic)) {
      return;
    }
    let encryptionPayload;
    try {
      encryptionPayload = JSON.parse(socketMessage.payload);
    } catch (error) {
      return;
    }
    const payload = await this._decrypt(encryptionPayload);
    if (payload) {
      this._eventManager.trigger(payload);
    }
  }
  _subscribeToSessionRequest() {
    this._transport.subscribe(this.handshakeTopic);
  }
  _subscribeToResponse(id, callback) {
    this.on(`response:${id}`, callback);
  }
  _subscribeToSessionResponse(id, errorMsg) {
    this._subscribeToResponse(id, (error, payload) => {
      if (error) {
        this._handleSessionResponse(error.message);
        return;
      }
      if (isJsonRpcResponseSuccess(payload)) {
        this._handleSessionResponse(errorMsg, payload.result);
      } else if (payload.error && payload.error.message) {
        this._handleSessionResponse(payload.error.message);
      } else {
        this._handleSessionResponse(errorMsg);
      }
    });
  }
  _subscribeToCallResponse(id) {
    return new Promise((resolve, reject) => {
      this._subscribeToResponse(id, (error, payload) => {
        if (error) {
          reject(error);
          return;
        }
        if (isJsonRpcResponseSuccess(payload)) {
          resolve(payload.result);
        } else if (payload.error && payload.error.message) {
          reject(payload.error);
        } else {
          reject(new Error(ERROR_INVALID_RESPONSE));
        }
      });
    });
  }
  _subscribeToInternalEvents() {
    this.on("display_uri", () => {
      if (this._qrcodeModal) {
        this._qrcodeModal.open(this.uri, () => {
          this._eventManager.trigger({
            event: "modal_closed",
            params: []
          });
        }, this._qrcodeModalOptions);
      }
    });
    this.on("connect", () => {
      if (this._qrcodeModal) {
        this._qrcodeModal.close();
      }
    });
    this.on("call_request_sent", (error, payload) => {
      const { request } = payload.params[0];
      if (isMobile() && this._signingMethods.includes(request.method)) {
        const mobileLinkUrl = getLocal(mobileLinkChoiceKey);
        if (mobileLinkUrl) {
          window.location.href = mobileLinkUrl.href;
        }
      }
    });
    this.on("wc_sessionRequest", (error, payload) => {
      if (error) {
        this._eventManager.trigger({
          event: "error",
          params: [
            {
              code: "SESSION_REQUEST_ERROR",
              message: error.toString()
            }
          ]
        });
      }
      this.handshakeId = payload.id;
      this.peerId = payload.params[0].peerId;
      this.peerMeta = payload.params[0].peerMeta;
      const internalPayload = Object.assign(Object.assign({}, payload), { method: "session_request" });
      this._eventManager.trigger(internalPayload);
    });
    this.on("wc_sessionUpdate", (error, payload) => {
      if (error) {
        this._handleSessionResponse(error.message);
      }
      this._handleSessionResponse("Session disconnected", payload.params[0]);
    });
  }
  _initTransport() {
    this._transport.on("message", (socketMessage) => this._handleIncomingMessages(socketMessage));
    this._transport.on("open", () => this._eventManager.trigger({ event: "transport_open", params: [] }));
    this._transport.on("close", () => this._eventManager.trigger({ event: "transport_close", params: [] }));
    this._transport.on("error", () => this._eventManager.trigger({
      event: "transport_error",
      params: ["Websocket connection failed"]
    }));
    this._transport.open();
  }
  _formatUri() {
    const protocol = this.protocol;
    const handshakeTopic = this.handshakeTopic;
    const version = this.version;
    const bridge = encodeURIComponent(this.bridge);
    const key = this.key;
    const uri = `${protocol}:${handshakeTopic}@${version}?bridge=${bridge}&key=${key}`;
    return uri;
  }
  _parseUri(uri) {
    const result = parseWalletConnectUri(uri);
    if (result.protocol === this.protocol) {
      if (!result.handshakeTopic) {
        throw Error("Invalid or missing handshakeTopic parameter value");
      }
      const handshakeTopic = result.handshakeTopic;
      if (!result.bridge) {
        throw Error("Invalid or missing bridge url parameter value");
      }
      const bridge = decodeURIComponent(result.bridge);
      if (!result.key) {
        throw Error("Invalid or missing key parameter value");
      }
      const key = result.key;
      return { handshakeTopic, bridge, key };
    } else {
      throw new Error(ERROR_INVALID_URI);
    }
  }
  async _generateKey() {
    if (this._cryptoLib) {
      const result = await this._cryptoLib.generateKey();
      return result;
    }
    return null;
  }
  async _encrypt(data) {
    const key = this._key;
    if (this._cryptoLib && key) {
      const result = await this._cryptoLib.encrypt(data, key);
      return result;
    }
    return null;
  }
  async _decrypt(payload) {
    const key = this._key;
    if (this._cryptoLib && key) {
      const result = await this._cryptoLib.decrypt(payload, key);
      return result;
    }
    return null;
  }
  _getStorageSession() {
    let result = null;
    if (this._sessionStorage) {
      result = this._sessionStorage.getSession();
    }
    return result;
  }
  _setStorageSession() {
    if (this._sessionStorage) {
      this._sessionStorage.setSession(this.session);
    }
  }
  _removeStorageSession() {
    if (this._sessionStorage) {
      this._sessionStorage.removeSession();
    }
  }
  _manageStorageSession() {
    if (this._connected) {
      this._setStorageSession();
    } else {
      this._removeStorageSession();
    }
  }
  _registerPushServer(pushServerOpts) {
    if (!pushServerOpts.url || typeof pushServerOpts.url !== "string") {
      throw Error("Invalid or missing pushServerOpts.url parameter value");
    }
    if (!pushServerOpts.type || typeof pushServerOpts.type !== "string") {
      throw Error("Invalid or missing pushServerOpts.type parameter value");
    }
    if (!pushServerOpts.token || typeof pushServerOpts.token !== "string") {
      throw Error("Invalid or missing pushServerOpts.token parameter value");
    }
    const pushSubscription = {
      bridge: this.bridge,
      topic: this.clientId,
      type: pushServerOpts.type,
      token: pushServerOpts.token,
      peerName: "",
      language: pushServerOpts.language || ""
    };
    this.on("connect", async (error, payload) => {
      if (error) {
        throw error;
      }
      if (pushServerOpts.peerMeta) {
        const peerName = payload.params[0].peerMeta.name;
        pushSubscription.peerName = peerName;
      }
      try {
        const response = await fetch(`${pushServerOpts.url}/new`, {
          method: "POST",
          headers: {
            Accept: "application/json",
            "Content-Type": "application/json"
          },
          body: JSON.stringify(pushSubscription)
        });
        const json = await response.json();
        if (!json.success) {
          throw Error("Failed to register in Push Server");
        }
      } catch (error2) {
        throw Error("Failed to register in Push Server");
      }
    });
  }
};
var esm_default3 = Connector;

// node_modules/@walletconnect/iso-crypto/dist/esm/index.js
var esm_exports6 = {};
__export(esm_exports6, {
  decrypt: () => decrypt,
  encrypt: () => encrypt,
  generateKey: () => generateKey,
  verifyHmac: () => verifyHmac
});
init_shim();
init_esm4();

// node_modules/@walletconnect/iso-crypto/node_modules/@walletconnect/utils/dist/esm/index.js
init_shim();

// node_modules/@walletconnect/iso-crypto/node_modules/@walletconnect/utils/dist/esm/constants.js
init_shim();

// node_modules/@walletconnect/iso-crypto/node_modules/@walletconnect/utils/dist/esm/encoding.js
init_shim();
var import_bn3 = __toESM(require_bn3());
init_esm4();
function convertArrayBufferToBuffer(arrBuf) {
  return arrayToBuffer(new Uint8Array(arrBuf));
}
function convertBufferToArrayBuffer(buf) {
  return bufferToArray(buf).buffer;
}

// node_modules/@walletconnect/iso-crypto/node_modules/@walletconnect/utils/dist/esm/ethereum.js
init_shim();
var import_js_sha33 = __toESM(require_sha3());
init_esm4();

// node_modules/@walletconnect/iso-crypto/node_modules/@walletconnect/utils/dist/esm/misc.js
init_shim();
init_esm4();
init_esm3();

// node_modules/@walletconnect/iso-crypto/node_modules/@walletconnect/utils/dist/esm/validators.js
init_shim();
init_esm4();

// node_modules/@walletconnect/iso-crypto/node_modules/@walletconnect/utils/dist/esm/payload.js
init_shim();

// node_modules/@walletconnect/iso-crypto/node_modules/@walletconnect/utils/dist/esm/session.js
init_shim();

// node_modules/@walletconnect/iso-crypto/node_modules/@walletconnect/utils/dist/esm/url.js
init_shim();
var queryStringUtils3 = __toESM(require_query_string5());

// node_modules/@walletconnect/iso-crypto/dist/esm/index.js
async function generateKey(length) {
  const _length = (length || 256) / 8;
  const bytes = randomBytes(_length);
  const result = convertBufferToArrayBuffer(arrayToBuffer(bytes));
  return result;
}
async function verifyHmac(payload, key) {
  const cipherText = hexToArray(payload.data);
  const iv = hexToArray(payload.iv);
  const hmac = hexToArray(payload.hmac);
  const hmacHex = arrayToHex(hmac, false);
  const unsigned = concatArrays(cipherText, iv);
  const chmac = await hmacSha256Sign(key, unsigned);
  const chmacHex = arrayToHex(chmac, false);
  if (removeHexPrefix(hmacHex) === removeHexPrefix(chmacHex)) {
    return true;
  }
  return false;
}
async function encrypt(data, key, providedIv) {
  const _key = bufferToArray(convertArrayBufferToBuffer(key));
  const ivArrayBuffer = providedIv || await generateKey(128);
  const iv = bufferToArray(convertArrayBufferToBuffer(ivArrayBuffer));
  const ivHex = arrayToHex(iv, false);
  const contentString = JSON.stringify(data);
  const content = utf8ToArray(contentString);
  const cipherText = await aesCbcEncrypt(iv, _key, content);
  const cipherTextHex = arrayToHex(cipherText, false);
  const unsigned = concatArrays(cipherText, iv);
  const hmac = await hmacSha256Sign(_key, unsigned);
  const hmacHex = arrayToHex(hmac, false);
  return {
    data: cipherTextHex,
    hmac: hmacHex,
    iv: ivHex
  };
}
async function decrypt(payload, key) {
  const _key = bufferToArray(convertArrayBufferToBuffer(key));
  if (!_key) {
    throw new Error("Missing key: required for decryption");
  }
  const verified = await verifyHmac(payload, _key);
  if (!verified) {
    return null;
  }
  const cipherText = hexToArray(payload.data);
  const iv = hexToArray(payload.iv);
  const buffer = await aesCbcDecrypt(iv, _key, cipherText);
  const utf8 = arrayToUtf8(buffer);
  let data;
  try {
    data = JSON.parse(utf8);
  } catch (error) {
    return null;
  }
  return data;
}

// node_modules/@walletconnect/client/dist/esm/index.js
var WalletConnect = class extends esm_default3 {
  constructor(connectorOpts, pushServerOpts) {
    super({
      cryptoLib: esm_exports6,
      connectorOpts,
      pushServerOpts
    });
  }
};
var esm_default4 = WalletConnect;

// node_modules/@thirdweb-dev/wallets/dist/smart-wallet-e0f242d2.browser.esm.js
var PREFIX2 = "__TW__";
var LocalStorage = class {
  constructor(name) {
    _defineProperty(this, "name", void 0);
    this.name = name;
  }
  getItem(key) {
    return localStorage.getItem(`${PREFIX2}/${this.name}/${key}`);
  }
  setItem(key, value) {
    return localStorage.setItem(`${PREFIX2}/${this.name}/${key}`, value);
  }
  removeItem(key) {
    return localStorage.removeItem(`${PREFIX2}/${this.name}/${key}`);
  }
};
function createLocalStorage(name) {
  return new LocalStorage(name);
}
var WalletConnectHandler = class extends eventemitter3_default {
};
var STORAGE_URI_KEY = "storage_uri_key";
var _wcMetadata$1 = /* @__PURE__ */ new WeakMap();
var _wcWallet$2 = /* @__PURE__ */ new WeakMap();
var _activeSessionPayload = /* @__PURE__ */ new WeakMap();
var _activeCallRequest = /* @__PURE__ */ new WeakMap();
var _storage = /* @__PURE__ */ new WeakMap();
var _sessionStorage = /* @__PURE__ */ new WeakMap();
var _init = /* @__PURE__ */ new WeakSet();
var _parseTxParams = /* @__PURE__ */ new WeakSet();
var _setupWalletConnectEventsListeners$2 = /* @__PURE__ */ new WeakSet();
var WalletConnectV1Handler = class extends WalletConnectHandler {
  constructor(options) {
    super();
    _classPrivateMethodInitSpec(this, _setupWalletConnectEventsListeners$2);
    _classPrivateMethodInitSpec(this, _parseTxParams);
    _classPrivateMethodInitSpec(this, _init);
    _classPrivateFieldInitSpec(this, _wcMetadata$1, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _wcWallet$2, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _activeSessionPayload, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _activeCallRequest, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _storage, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _sessionStorage, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(this, _wcMetadata$1, (options == null ? void 0 : options.walletConnectWalletMetadata) || {
      name: "Thirdweb Smart Wallet",
      description: "Thirdweb Smart Wallet",
      url: "https://thirdweb.com",
      icons: ["https://thirdweb.com/favicon.ico"]
    });
    _classPrivateFieldSet(this, _storage, options.storage);
    _classPrivateFieldSet(this, _sessionStorage, new SessionStorage2(options.storage));
  }
  async init() {
    const uri = _classPrivateFieldGet(this, _storage).getItem(STORAGE_URI_KEY);
    if (uri) {
      _classPrivateMethodGet(this, _init, _init2).call(this, uri);
    }
    return Promise.resolve();
  }
  async connectApp(uri) {
    if (!_classPrivateFieldGet(this, _wcWallet$2)) {
      _classPrivateFieldGet(this, _storage).setItem(STORAGE_URI_KEY, uri);
      _classPrivateMethodGet(this, _init, _init2).call(this, uri);
    }
    return Promise.resolve();
  }
  async approveSession(wallet) {
    if (!_classPrivateFieldGet(this, _wcWallet$2)) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    const address = await wallet.getAddress();
    const chainId = await wallet.getChainId();
    await _classPrivateFieldGet(this, _wcWallet$2).approveSession({
      accounts: [address],
      chainId
    });
    this.emit("session_approved");
    return Promise.resolve();
  }
  rejectSession() {
    if (!_classPrivateFieldGet(this, _wcWallet$2)) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    _classPrivateFieldGet(this, _wcWallet$2).rejectSession();
    return Promise.resolve();
  }
  async approveEIP155Request(wallet) {
    var _a, _b, _c, _d;
    const {
      params,
      method
    } = _classPrivateFieldGet(this, _activeCallRequest);
    try {
      let result;
      switch (method) {
        case EIP155_SIGNING_METHODS.ETH_SIGN:
          const ethMsg = params[1];
          result = await wallet.signMessage(utils_exports.arrayify(ethMsg));
          break;
        case EIP155_SIGNING_METHODS.PERSONAL_SIGN:
          const message = params[0];
          result = await wallet.signMessage(utils_exports.arrayify(message));
          break;
        case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:
          const chainId = await wallet.getChainId();
          const signer = await wallet.getSigner();
          const tx = await signer.sendTransaction(_classPrivateMethodGet(this, _parseTxParams, _parseTxParams2).call(this, params, chainId));
          const {
            transactionHash
          } = await tx.wait();
          result = transactionHash;
          break;
        case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:
          const chainIdSign = await wallet.getChainId();
          const signerSign = await wallet.getSigner();
          const txParams = await signerSign.populateTransaction(_classPrivateMethodGet(this, _parseTxParams, _parseTxParams2).call(this, params, chainIdSign));
          result = await signerSign.signTransaction(txParams);
          break;
        case EIP155_SIGNING_METHODS.SWITCH_CHAIN: {
          await wallet.switchChain(params[0].chainId);
          result = params[0].chainId;
          break;
        }
      }
      (_b = _classPrivateFieldGet(this, _wcWallet$2)) == null ? void 0 : _b.approveRequest({
        id: (_a = _classPrivateFieldGet(this, _activeCallRequest)) == null ? void 0 : _a.id,
        result
      });
    } catch (error) {
      let message;
      if (error instanceof Error) {
        message = error.message;
      } else {
        message = `Error executing the method: ${method}`;
      }
      (_d = _classPrivateFieldGet(this, _wcWallet$2)) == null ? void 0 : _d.rejectRequest({
        id: (_c = _classPrivateFieldGet(this, _activeCallRequest)) == null ? void 0 : _c.id,
        error: {
          message
        }
      });
    }
    return Promise.resolve();
  }
  rejectEIP155Request() {
    var _a;
    (_a = _classPrivateFieldGet(this, _wcWallet$2)) == null ? void 0 : _a.rejectRequest({
      id: 1,
      error: {
        message: "Rejected by user"
      }
    });
    return Promise.resolve();
  }
  getActiveSessions() {
    var _a;
    const session = (_a = _classPrivateFieldGet(this, _wcWallet$2)) == null ? void 0 : _a.session;
    if (!session) {
      return [];
    }
    const result = [{
      topic: session == null ? void 0 : session.clientId,
      peer: {
        metadata: session.peerMeta ? session.peerMeta : {
          name: "Thirdweb Powered Wallet",
          description: "Thirdweb Powered Wallet",
          url: "https://thirdweb.com",
          icons: ["https://thirdweb.com/favicon.ico"]
        }
      }
    }];
    return result;
  }
  async disconnectSession() {
    var _a, _b, _c, _d;
    (_a = _classPrivateFieldGet(this, _wcWallet$2)) == null ? void 0 : _a.killSession();
    (_b = _classPrivateFieldGet(this, _wcWallet$2)) == null ? void 0 : _b.off("session_request");
    (_c = _classPrivateFieldGet(this, _wcWallet$2)) == null ? void 0 : _c.off("call_request");
    (_d = _classPrivateFieldGet(this, _wcWallet$2)) == null ? void 0 : _d.off("disconnect");
    _classPrivateFieldGet(this, _storage).removeItem(STORAGE_URI_KEY);
    _classPrivateFieldSet(this, _wcWallet$2, void 0);
    this.emit("session_delete");
    return Promise.resolve();
  }
};
function _init2(uri) {
  _classPrivateFieldSet(this, _wcWallet$2, new esm_default4({
    uri,
    clientMeta: _classPrivateFieldGet(this, _wcMetadata$1),
    storage: _classPrivateFieldGet(this, _sessionStorage)
  }));
  _classPrivateMethodGet(this, _setupWalletConnectEventsListeners$2, _setupWalletConnectEventsListeners2$2).call(this);
}
function _parseTxParams2(params, chainId) {
  let txParams = {
    from: params[0].from,
    data: params[0].data,
    chainId
  };
  if (params[0].gas) {
    txParams = {
      ...txParams,
      gasLimit: params[0].gas
    };
  }
  if (params[0].to) {
    txParams = {
      ...txParams,
      to: params[0].to
    };
  }
  return txParams;
}
function _setupWalletConnectEventsListeners2$2() {
  if (!_classPrivateFieldGet(this, _wcWallet$2)) {
    throw new Error("Please, init the wallet before making session requests.");
  }
  _classPrivateFieldGet(this, _wcWallet$2).on("session_request", (error, payload) => {
    if (error) {
      throw new Error(`WCV1H.session_request error: ${error.message}`);
    }
    _classPrivateFieldSet(this, _activeSessionPayload, payload);
    this.emit("session_proposal", {
      proposer: {
        metadata: payload.params[0].peerMeta
      }
    });
  });
  _classPrivateFieldGet(this, _wcWallet$2).on("call_request", (error, payload) => {
    if (error) {
      throw new Error(`WCV1H.call_request error: ${error.message}`);
    }
    const {
      params,
      method
    } = payload;
    _classPrivateFieldSet(this, _activeCallRequest, payload);
    switch (method) {
      case EIP155_SIGNING_METHODS.ETH_SIGN:
      case EIP155_SIGNING_METHODS.PERSONAL_SIGN:
        const message = params[0];
        const decodedMessage = new TextDecoder().decode(utils_exports.arrayify(message));
        const paramsCopy = [...params];
        paramsCopy[0] = decodedMessage;
        this.emit("session_request", {
          topic: params[1],
          params: paramsCopy,
          peer: {
            metadata: _classPrivateFieldGet(this, _activeSessionPayload).params[0].peerMeta
          },
          method
        });
        return;
      case EIP155_SIGNING_METHODS.SWITCH_CHAIN:
        const chain = params[0];
        const chainId = parseInt(chain.chainId, 16);
        chain.chainId = chainId;
        const paramsCopyWithChain = [...params];
        paramsCopyWithChain[0] = chain;
        this.emit("session_request", {
          topic: params[1],
          params: paramsCopyWithChain,
          peer: {
            metadata: _classPrivateFieldGet(this, _activeSessionPayload).params[0].peerMeta
          },
          method
        });
        return;
      case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:
      case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:
        this.emit("session_request", {
          topic: method,
          params,
          peer: {
            metadata: _classPrivateFieldGet(this, _activeSessionPayload).params[0].peerMeta
          },
          method
        });
        return;
      default:
        throw new Error(`WalletConnectV1Handler.call_request. Method not implemented: ${method}`);
    }
  });
  _classPrivateFieldGet(this, _wcWallet$2).on("disconnect", (error) => {
    if (error) {
      throw new Error(`WCV1H.disconnect error: ${error.message}`);
    }
    this.disconnectSession();
  });
}
var _storage2 = /* @__PURE__ */ new WeakMap();
var SessionStorage2 = class {
  constructor(storage) {
    _classPrivateFieldInitSpec(this, _storage2, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(this, _storage2, storage);
  }
  getSession() {
    const session = _classPrivateFieldGet(this, _storage2).getItem("session");
    if (!session) {
      return null;
    }
    const sessionObj = JSON.parse(session);
    return sessionObj;
  }
  setSession(session) {
    _classPrivateFieldGet(this, _storage2).setItem("session", JSON.stringify(session));
    return session;
  }
  removeSession() {
    _classPrivateFieldGet(this, _storage2).removeItem("session");
  }
};
var _core = /* @__PURE__ */ new WeakMap();
var _wcWallet$1 = /* @__PURE__ */ new WeakMap();
var _session = /* @__PURE__ */ new WeakMap();
var _wcMetadata = /* @__PURE__ */ new WeakMap();
var _activeProposal = /* @__PURE__ */ new WeakMap();
var _activeRequestEvent = /* @__PURE__ */ new WeakMap();
var _setupWalletConnectEventsListeners$1 = /* @__PURE__ */ new WeakSet();
var _getSignParamsMessage = /* @__PURE__ */ new WeakSet();
var WalletConnectV2Handler = class extends WalletConnectHandler {
  constructor(options) {
    super();
    _classPrivateMethodInitSpec(this, _getSignParamsMessage);
    _classPrivateMethodInitSpec(this, _setupWalletConnectEventsListeners$1);
    _classPrivateFieldInitSpec(this, _core, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _wcWallet$1, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _session, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _wcMetadata, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _activeProposal, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _activeRequestEvent, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(this, _wcMetadata, (options == null ? void 0 : options.walletConnectWalletMetadata) || {
      name: "Thirdweb Smart Wallet",
      description: "Thirdweb Smart Wallet",
      url: "https://thirdweb.com",
      icons: ["https://thirdweb.com/favicon.ico"]
    });
    _classPrivateFieldSet(this, _core, new Ir({
      projectId: (options == null ? void 0 : options.walletConenctV2ProjectId) || TW_WC_PROJECT_ID,
      relayUrl: (options == null ? void 0 : options.walletConnectV2RelayUrl) || WC_RELAY_URL
    }));
  }
  async init() {
    _classPrivateFieldSet(this, _wcWallet$1, await G6.init({
      core: _classPrivateFieldGet(this, _core),
      metadata: _classPrivateFieldGet(this, _wcMetadata)
    }));
    const sessions = _classPrivateFieldGet(this, _wcWallet$1).getActiveSessions();
    const keys = Object.keys(sessions);
    if (keys.length > 0) {
      _classPrivateFieldSet(this, _session, sessions[keys[0]]);
    }
    _classPrivateMethodGet(this, _setupWalletConnectEventsListeners$1, _setupWalletConnectEventsListeners2$1).call(this);
  }
  async connectApp(wcUri) {
    if (!_classPrivateFieldGet(this, _wcWallet$1)) {
      throw new Error("Please, init the wallet before connecting an app.");
    }
    await _classPrivateFieldGet(this, _wcWallet$1).core.pairing.pair({
      uri: wcUri
    });
  }
  async approveSession(wallet) {
    if (!_classPrivateFieldGet(this, _wcWallet$1)) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    if (!_classPrivateFieldGet(this, _activeProposal)) {
      throw new Error("Please, pass a valid proposal.");
    }
    const account = await wallet.getAddress();
    const {
      id,
      params
    } = _classPrivateFieldGet(this, _activeProposal);
    const {
      requiredNamespaces,
      relays
    } = params;
    const namespaces = {};
    Object.keys(requiredNamespaces).forEach((key) => {
      var _a;
      const accounts = [];
      (_a = requiredNamespaces[key].chains) == null ? void 0 : _a.map((chain) => {
        accounts.push(`${chain}:${account}`);
      });
      namespaces[key] = {
        accounts,
        methods: requiredNamespaces[key].methods,
        events: requiredNamespaces[key].events
      };
    });
    _classPrivateFieldSet(this, _session, await _classPrivateFieldGet(this, _wcWallet$1).approveSession({
      id,
      relayProtocol: relays[0].protocol,
      namespaces
    }));
    this.emit("session_approved");
  }
  async rejectSession() {
    if (!_classPrivateFieldGet(this, _wcWallet$1)) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    if (!_classPrivateFieldGet(this, _activeProposal)) {
      throw new Error("Please, pass a valid proposal.");
    }
    const {
      id
    } = _classPrivateFieldGet(this, _activeProposal);
    await _classPrivateFieldGet(this, _wcWallet$1).rejectSession({
      id,
      reason: {
        message: "User rejected methods.",
        code: 5002
      }
    });
  }
  async approveEIP155Request(wallet) {
    var _a, _b;
    if (!_classPrivateFieldGet(this, _activeRequestEvent)) {
      return;
    }
    const {
      topic,
      params,
      id
    } = _classPrivateFieldGet(this, _activeRequestEvent);
    const {
      request
    } = params;
    let response;
    switch (request.method) {
      case EIP155_SIGNING_METHODS.PERSONAL_SIGN:
      case EIP155_SIGNING_METHODS.ETH_SIGN:
        const message = _classPrivateMethodGet(this, _getSignParamsMessage, _getSignParamsMessage2).call(this, request.params);
        const signedMessage = await wallet.signMessage(message);
        response = formatJsonRpcResult(id, signedMessage);
        break;
      case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:
        const signer = await wallet.getSigner();
        const sendTransaction = request.params[0];
        const tx = await signer.sendTransaction(sendTransaction);
        const {
          transactionHash
        } = await tx.wait();
        response = formatJsonRpcResult(id, transactionHash);
        break;
      case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:
        const signerSign = await wallet.getSigner();
        const signTransaction = request.params[0];
        const signature = await signerSign.signTransaction(signTransaction);
        response = formatJsonRpcResult(id, signature);
      default:
        const error = {
          id,
          jsonrpc: "2.0",
          error: {
            message: "Invalid event.",
            code: 1002
          }
        };
        return (_a = _classPrivateFieldGet(this, _wcWallet$1)) == null ? void 0 : _a.respondSessionRequest({
          topic,
          response: error
        });
    }
    return (_b = _classPrivateFieldGet(this, _wcWallet$1)) == null ? void 0 : _b.respondSessionRequest({
      topic,
      response
    });
  }
  async rejectEIP155Request() {
    var _a;
    if (!_classPrivateFieldGet(this, _activeRequestEvent)) {
      return;
    }
    const {
      topic,
      id
    } = _classPrivateFieldGet(this, _activeRequestEvent);
    const response = {
      id,
      jsonrpc: "2.0",
      error: {
        message: "User rejected methods.",
        code: 5002
      }
    };
    return (_a = _classPrivateFieldGet(this, _wcWallet$1)) == null ? void 0 : _a.respondSessionRequest({
      topic,
      response
    });
  }
  getActiveSessions() {
    if (!_classPrivateFieldGet(this, _wcWallet$1)) {
      throw new Error("Please, init the wallet before getting sessions.");
    }
    const sessions = _classPrivateFieldGet(this, _wcWallet$1).getActiveSessions();
    const sessionKeys = Object.keys(sessions);
    if (!sessions || sessionKeys.length === 0) {
      return [];
    }
    const thisSessions = [];
    for (const sessionKey of sessionKeys) {
      const topic = sessions[sessionKey].topic;
      const peerMeta = sessions[sessionKey].peer.metadata;
      thisSessions.push({
        topic,
        peer: {
          metadata: peerMeta
        }
      });
    }
    return thisSessions;
  }
  disconnectSession() {
    var _a;
    if (!_classPrivateFieldGet(this, _wcWallet$1)) {
      throw new Error("Please, init the wallet before disconnecting sessions.");
    }
    if (!_classPrivateFieldGet(this, _session)) {
      return Promise.resolve();
    }
    const params = {
      topic: _classPrivateFieldGet(this, _session).topic,
      reason: {
        message: "User disconnected.",
        code: 6e3
      }
    };
    return (_a = _classPrivateFieldGet(this, _wcWallet$1)) == null ? void 0 : _a.disconnectSession(params);
  }
};
function _setupWalletConnectEventsListeners2$1() {
  if (!_classPrivateFieldGet(this, _wcWallet$1)) {
    throw new Error("Please, init the wallet before making session requests.");
  }
  _classPrivateFieldGet(this, _wcWallet$1).on("session_proposal", (proposal) => {
    _classPrivateFieldSet(this, _activeProposal, proposal);
    this.emit("session_proposal", {
      proposer: {
        metadata: proposal.params.proposer.metadata
      }
    });
  });
  _classPrivateFieldGet(this, _wcWallet$1).on("session_delete", (session) => {
    _classPrivateFieldSet(this, _session, void 0);
    _classPrivateFieldSet(this, _activeProposal, void 0);
    this.emit("session_delete", {
      topic: session.topic
    });
  });
  _classPrivateFieldGet(this, _wcWallet$1).on("session_request", async (requestEvent) => {
    if (!_classPrivateFieldGet(this, _session)) {
      return;
    }
    const {
      params: requestParams
    } = requestEvent;
    const {
      request
    } = requestParams;
    const {
      params
    } = request;
    switch (request.method) {
      case EIP155_SIGNING_METHODS.ETH_SIGN:
      case EIP155_SIGNING_METHODS.PERSONAL_SIGN:
        _classPrivateFieldSet(this, _activeRequestEvent, requestEvent);
        const message = params[0];
        const decodedMessage = new TextDecoder().decode(utils_exports.arrayify(message));
        const paramsCopy = [...params];
        paramsCopy[0] = decodedMessage;
        this.emit("session_request", {
          topic: _classPrivateFieldGet(this, _session).topic,
          params: paramsCopy,
          peer: {
            metadata: _classPrivateFieldGet(this, _session).peer.metadata
          },
          method: request.method
        });
        return;
      case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:
      case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:
        _classPrivateFieldSet(this, _activeRequestEvent, requestEvent);
        this.emit("session_request", {
          topic: _classPrivateFieldGet(this, _session).topic,
          params: requestEvent.params.request.params,
          peer: {
            metadata: _classPrivateFieldGet(this, _session).peer.metadata
          },
          method: request.method
        });
        return;
      default:
        throw new Error(`WCV2.Method not supported: ${request.method}`);
    }
  });
}
function _getSignParamsMessage2(params) {
  const message = params.filter((p6) => !utils_exports.isAddress(p6))[0];
  if (utils_exports.isHexString(message)) {
    return utils_exports.toUtf8String(message);
  }
  return message;
}
var NoOpWalletConnectHandler = class extends WalletConnectHandler {
  init() {
    return Promise.resolve();
  }
  connectApp(uri) {
    return Promise.resolve();
  }
  approveSession(wallet) {
    return Promise.resolve();
  }
  rejectSession() {
    return Promise.resolve();
  }
  approveEIP155Request(wallet) {
    return Promise.resolve();
  }
  rejectEIP155Request() {
    return Promise.resolve();
  }
  getActiveSessions() {
    return [];
  }
  disconnectSession() {
    return Promise.resolve();
  }
};
var _wcWallet = /* @__PURE__ */ new WeakMap();
var _setupWalletConnectEventsListeners = /* @__PURE__ */ new WeakSet();
var SmartWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Smart Wallet";
  }
  constructor(options) {
    super(SmartWallet.id, {
      ...options
    });
    _classPrivateMethodInitSpec(this, _setupWalletConnectEventsListeners);
    _defineProperty(this, "connector", void 0);
    _defineProperty(this, "enableConnectApp", false);
    _classPrivateFieldInitSpec(this, _wcWallet, {
      writable: true,
      value: void 0
    });
    this.enableConnectApp = (options == null ? void 0 : options.enableConnectApp) || false;
    _classPrivateFieldSet(this, _wcWallet, this.enableConnectApp ? (options == null ? void 0 : options.wcVersion) === "v1" ? new WalletConnectV1Handler({
      walletConnectWalletMetadata: options == null ? void 0 : options.walletConnectWalletMetadata,
      walletConenctV2ProjectId: options == null ? void 0 : options.walletConenctV2ProjectId,
      walletConnectV2RelayUrl: options == null ? void 0 : options.walletConnectV2RelayUrl,
      storage: (options == null ? void 0 : options.wcStorage) || createLocalStorage("smart-wallet")
    }) : new WalletConnectV2Handler({
      walletConnectWalletMetadata: options == null ? void 0 : options.walletConnectWalletMetadata,
      walletConenctV2ProjectId: options == null ? void 0 : options.walletConenctV2ProjectId,
      walletConnectV2RelayUrl: options == null ? void 0 : options.walletConnectV2RelayUrl
    }) : new NoOpWalletConnectHandler());
  }
  async getConnector() {
    if (!this.connector) {
      if (this.enableConnectApp) {
        await _classPrivateFieldGet(this, _wcWallet).init();
        _classPrivateMethodGet(this, _setupWalletConnectEventsListeners, _setupWalletConnectEventsListeners2).call(this);
      }
      const {
        SmartWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-smart-wallet.browser.esm-MASRWGUI.js");
      this.connector = new SmartWalletConnector(this.options);
    }
    return this.connector;
  }
  getPersonalWallet() {
    var _a;
    return (_a = this.connector) == null ? void 0 : _a.personalWallet;
  }
  async execute(transaction) {
    const connector = await this.getConnector();
    return connector.execute(transaction);
  }
  async executeBatch(transactions) {
    const connector = await this.getConnector();
    return connector.executeBatch(transactions);
  }
  async deploy() {
    const connector = await this.getConnector();
    return connector.deploy();
  }
  async isDeployed() {
    const connector = await this.getConnector();
    return connector.isDeployed();
  }
  autoConnect(params) {
    return this.connect(params);
  }
  async connectApp(uri) {
    var _a;
    if (!this.enableConnectApp) {
      throw new Error("enableConnectApp is set to false in this wallet config");
    }
    (_a = _classPrivateFieldGet(this, _wcWallet)) == null ? void 0 : _a.connectApp(uri);
  }
  async approveSession() {
    await _classPrivateFieldGet(this, _wcWallet).approveSession(this);
    this.emit("message", {
      type: "session_approved"
    });
  }
  rejectSession() {
    return _classPrivateFieldGet(this, _wcWallet).rejectSession();
  }
  approveRequest() {
    return _classPrivateFieldGet(this, _wcWallet).approveEIP155Request(this);
  }
  rejectRequest() {
    return _classPrivateFieldGet(this, _wcWallet).rejectEIP155Request();
  }
  getActiveSessions() {
    if (!_classPrivateFieldGet(this, _wcWallet)) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    return _classPrivateFieldGet(this, _wcWallet).getActiveSessions();
  }
  disconnectSession() {
    var _a;
    return (_a = _classPrivateFieldGet(this, _wcWallet)) == null ? void 0 : _a.disconnectSession();
  }
  isWCReceiverEnabled() {
    return this.enableConnectApp;
  }
};
function _setupWalletConnectEventsListeners2() {
  if (!_classPrivateFieldGet(this, _wcWallet)) {
    throw new Error("Please, init the wallet before making session requests.");
  }
  _classPrivateFieldGet(this, _wcWallet).on("session_proposal", (proposal) => {
    this.emit("message", {
      type: "session_proposal",
      data: proposal
    });
  });
  _classPrivateFieldGet(this, _wcWallet).on("session_delete", () => {
    this.emit("message", {
      type: "session_delete"
    });
  });
  _classPrivateFieldGet(this, _wcWallet).on("switch_chain", (request) => {
    const chainId = request.params[0].chainId;
    this.emit("message", {
      type: "switch_chain",
      data: {
        chainId
      }
    });
    _classPrivateFieldGet(this, _wcWallet).disconnectSession();
  });
  _classPrivateFieldGet(this, _wcWallet).on("session_request", (request) => {
    this.emit("message", {
      type: "session_request",
      data: request
    });
  });
}
_defineProperty(SmartWallet, "meta", {
  name: "Smart Wallet",
  iconURL: "ipfs://QmeAJVqn17aDNQhjEU3kcWVZCFBrfta8LzaDGkS8Egdiyk/smart-wallet.svg"
});
_defineProperty(SmartWallet, "id", walletIds.smartWallet);

// node_modules/@thirdweb-dev/wallets/evm/wallets/paper-wallet/dist/thirdweb-dev-wallets-evm-wallets-paper-wallet.browser.esm.js
init_shim();
init_lib3();
var PaperWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Paper Wallet";
  }
  constructor(options) {
    super(PaperWallet.id, {
      ...options
    });
    _defineProperty(this, "connector", void 0);
    _defineProperty(this, "clientId", void 0);
    _defineProperty(this, "chain", void 0);
    this.clientId = options.clientId;
    this.chain = options.chain;
  }
  async getConnector() {
    if (!this.connector) {
      const {
        PaperWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-paper.browser.esm-GFCWPSME.js");
      this.connector = new PaperWalletConnector({
        clientId: this.clientId,
        chain: this.chain,
        chains: this.chains
      });
    }
    return this.connector;
  }
  async updateChains(chains) {
    this.chains = chains;
  }
  async getEmail() {
    const connector = await this.getConnector();
    return connector.getEmail();
  }
};
_defineProperty(PaperWallet, "id", walletIds.paper);
_defineProperty(PaperWallet, "meta", {
  name: "Paper Wallet",
  iconURL: "ipfs://QmNrLXtPoFrh4yjZbXui39zUMozS1oetpgU8dvZhFAxfRa/paper-logo-icon.svg"
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/coinbase-wallet/dist/thirdweb-dev-wallets-evm-wallets-coinbase-wallet.browser.esm.js
init_shim();
var import_buffer = __toESM(require_buffer());
init_lib3();
{
  window.Buffer = import_buffer.Buffer;
}
var CoinbaseWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Coinbase Wallet";
  }
  constructor(options) {
    super(CoinbaseWallet.id, options);
    _defineProperty(this, "connector", void 0);
    _defineProperty(this, "coinbaseConnector", void 0);
    _defineProperty(this, "headlessMode", void 0);
    this.headlessMode = (options == null ? void 0 : options.headlessMode) || false;
  }
  async getConnector() {
    if (!this.connector) {
      const {
        CoinbaseWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-coinbase-wallet.browser.esm-DPQ3WYKJ.js");
      const cbConnector = new CoinbaseWalletConnector({
        chains: this.chains,
        options: {
          appName: this.dappMetadata.name,
          reloadOnDisconnect: false,
          darkMode: this.dappMetadata.isDarkMode,
          headlessMode: this.headlessMode
        }
      });
      cbConnector.on("connect", () => {
      });
      this.coinbaseConnector = cbConnector;
      this.connector = new WagmiAdapter(cbConnector);
    }
    return this.connector;
  }
  async getQrUrl() {
    await this.getConnector();
    if (!this.coinbaseConnector) {
      throw new Error("Coinbase connector not initialized");
    }
    return this.coinbaseConnector.getQrUrl();
  }
};
_defineProperty(CoinbaseWallet, "meta", {
  iconURL: "ipfs://QmcJBHopbwfJcLqJpX2xEufSS84aLbF7bHavYhaXUcrLaH/coinbase.svg",
  name: "Coinbase Wallet",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/coinbase-wallet-extension/hnfanknocfeofbddgcijnmhnfnkdnaad",
    android: "https://play.google.com/store/apps/details?id=org.toshi",
    ios: "https://apps.apple.com/us/app/coinbase-wallet-nfts-crypto/id1278383455"
  }
});
_defineProperty(CoinbaseWallet, "id", walletIds.coinbase);

// node_modules/@thirdweb-dev/wallets/evm/wallets/local-wallet/dist/thirdweb-dev-wallets-evm-wallets-local-wallet.browser.esm.js
init_shim();
init_lib3();
var STORAGE_KEY_WALLET_DATA = "localWalletData";
var _storage22 = /* @__PURE__ */ new WeakMap();
var _saveData = /* @__PURE__ */ new WeakSet();
var LocalWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Local Wallet";
  }
  constructor(options) {
    super(LocalWallet.id, options);
    _classPrivateMethodInitSpec(this, _saveData);
    _defineProperty(this, "connector", void 0);
    _defineProperty(this, "options", void 0);
    _defineProperty(this, "ethersWallet", void 0);
    _classPrivateFieldInitSpec(this, _storage22, {
      writable: true,
      value: void 0
    });
    this.options = options || {};
    _classPrivateFieldSet(this, _storage22, (options == null ? void 0 : options.storage) || createAsyncLocalStorage(walletIds.localWallet));
  }
  async getConnector() {
    if (!this.connector) {
      const {
        LocalWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-local-wallet.browser.esm-JRCX2S7D.js");
      if (!this.ethersWallet) {
        throw new Error("wallet is not initialized");
      }
      const defaults = this.options.chain ? [...defaultChains, this.options.chain] : defaultChains;
      this.connector = new LocalWalletConnector({
        chain: this.options.chain || c1,
        ethersWallet: this.ethersWallet,
        chains: this.options.chains || defaults,
        thirdwebApiKey: this.options.thirdwebApiKey
      });
    }
    return this.connector;
  }
  async loadOrCreate(options) {
    if (await this.getSavedData()) {
      await this.load(options);
    } else {
      await this.generate();
      await this.save(options);
    }
  }
  async generate() {
    if (this.ethersWallet) {
      throw new Error("wallet is already initialized");
    }
    this.ethersWallet = Wallet.createRandom();
    return this.ethersWallet.address;
  }
  async import(options) {
    if (this.ethersWallet) {
      throw new Error("wallet is already initialized");
    }
    if ("encryptedJson" in options) {
      this.ethersWallet = await Wallet.fromEncryptedJson(options.encryptedJson, options.password);
      return this.ethersWallet.address;
    }
    if ("privateKey" in options) {
      if (!options.encryption && !isValidPrivateKey(options.privateKey)) {
        throw new Error("invalid private key");
      }
      const privateKey = await getDecryptor(options.encryption)(options.privateKey);
      if (options.encryption && (privateKey === "" || !isValidPrivateKey(privateKey))) {
        throw new Error("invalid password");
      }
      this.ethersWallet = new Wallet(privateKey);
      return this.ethersWallet.address;
    }
    if ("mnemonic" in options) {
      if (!options.encryption && !utils_exports.isValidMnemonic(options.mnemonic)) {
        throw new Error("invalid mnemonic");
      }
      const mnemonic = await getDecryptor(options.encryption)(options.mnemonic);
      if (options.encryption && (mnemonic === "" || !utils_exports.isValidMnemonic(mnemonic))) {
        throw new Error("invalid password");
      }
      this.ethersWallet = Wallet.fromMnemonic(mnemonic);
      return this.ethersWallet.address;
    }
    throw new Error("invalid import strategy");
  }
  async load(options) {
    if (this.ethersWallet) {
      throw new Error("wallet is already initialized");
    }
    const walletData = await this.getSavedData(options.storage);
    if (!walletData) {
      throw new Error("No Saved wallet found in storage");
    }
    if (walletData.strategy !== options.strategy) {
      throw new Error(`Saved wallet data is not ${options.strategy}, it is ${walletData.strategy}`);
    }
    if (options.strategy === "encryptedJson") {
      return this.import({
        encryptedJson: walletData.data,
        password: options.password
      });
    }
    if (walletData.isEncrypted && !options.encryption) {
      throw new Error("Saved wallet data is encrypted, but no password is provided");
    }
    if (!walletData.isEncrypted && options.encryption) {
      throw new Error("Saved wallet data is not encrypted, but encryption config is provided");
    }
    if (options.strategy === "privateKey") {
      return this.import({
        privateKey: walletData.data,
        encryption: options.encryption
      });
    }
    if (options.strategy === "mnemonic") {
      return this.import({
        mnemonic: walletData.data,
        encryption: options.encryption
      });
    }
    throw new Error("invalid load strategy");
  }
  async save(options) {
    const wallet = this.ethersWallet;
    if (!wallet) {
      throw new Error("Wallet is not initialized");
    }
    if (options.strategy === "encryptedJson") {
      const encryptedData = await wallet.encrypt(options.password, {
        scrypt: {
          N: 1 << 32
        }
      });
      await _classPrivateMethodGet(this, _saveData, _saveData2).call(this, {
        address: wallet.address,
        data: encryptedData,
        strategy: "encryptedJson",
        isEncrypted: true
      }, options.storage);
    }
    if (options.strategy === "privateKey") {
      const privateKey = await getEncryptor(options.encryption)(wallet.privateKey);
      await _classPrivateMethodGet(this, _saveData, _saveData2).call(this, {
        address: wallet.address,
        data: privateKey,
        strategy: "privateKey",
        isEncrypted: !!options.encryption
      }, options.storage);
    }
    if (options.strategy === "mnemonic") {
      const mnemonic = await getEncryptor(options.encryption)(wallet.mnemonic.phrase);
      await _classPrivateMethodGet(this, _saveData, _saveData2).call(this, {
        address: wallet.address,
        data: mnemonic,
        strategy: "mnemonic",
        isEncrypted: !!options.encryption
      }, options.storage);
    }
  }
  async isSaved() {
    try {
      const data = await this.getSavedData();
      const address = await this.getAddress();
      if ((data == null ? void 0 : data.address) === address) {
        return true;
      }
      return false;
    } catch (e) {
      return false;
    }
  }
  async deleteSaved() {
    await _classPrivateFieldGet(this, _storage22).removeItem(STORAGE_KEY_WALLET_DATA);
  }
  async export(options) {
    const wallet = this.ethersWallet;
    if (!wallet) {
      throw new Error("Wallet is not initialized");
    }
    if (options.strategy === "encryptedJson") {
      return wallet.encrypt(options.password, {
        scrypt: {
          N: 1 << 32
        }
      });
    }
    if (options.strategy === "privateKey") {
      return getEncryptor(options.encryption)(wallet.privateKey);
    }
    if (options.strategy === "mnemonic") {
      if (!wallet.mnemonic) {
        throw new Error("mnemonic can not be computed if wallet is created from a private key");
      }
      return getEncryptor(options.encryption)(wallet.mnemonic.phrase);
    }
    throw new Error("Invalid export strategy");
  }
  async getSavedData(storage) {
    const _storage3 = storage || _classPrivateFieldGet(this, _storage22);
    try {
      const savedDataStr = await _storage3.getItem(STORAGE_KEY_WALLET_DATA);
      if (!savedDataStr) {
        return null;
      }
      const savedData = JSON.parse(savedDataStr);
      if (!savedData) {
        return null;
      }
      return savedData;
    } catch (e) {
      return null;
    }
  }
  async disconnect() {
    await super.disconnect();
    this.ethersWallet = void 0;
  }
};
async function _saveData2(data, storage) {
  const _storage3 = storage || _classPrivateFieldGet(this, _storage22);
  await _storage3.setItem(STORAGE_KEY_WALLET_DATA, JSON.stringify(data));
}
_defineProperty(LocalWallet, "id", walletIds.localWallet);
_defineProperty(LocalWallet, "meta", {
  name: "Local Wallet",
  iconURL: "ipfs://QmbQzSNGvmNYZzem9jZRuYeLe9K2W4pqbdnVUp7Y6edQ8Y/local-wallet.svg"
});
async function defaultEncrypt(message, password) {
  const cryptoJS = (await import("./crypto-js-4YM55WG5.js")).default;
  return cryptoJS.AES.encrypt(message, password).toString();
}
async function defaultDecrypt(message, password) {
  const cryptoJS = (await import("./crypto-js-4YM55WG5.js")).default;
  return cryptoJS.AES.decrypt(message, password).toString(cryptoJS.enc.Utf8);
}
function getDecryptor(encryption) {
  const noop = async (msg) => msg;
  return encryption ? (msg) => (encryption.decrypt || defaultDecrypt)(msg, encryption.password) : noop;
}
function getEncryptor(encryption) {
  const noop = async (msg) => msg;
  return encryption ? (msg) => (encryption.encrypt || defaultEncrypt)(msg, encryption.password) : noop;
}
function isValidPrivateKey(value) {
  return !!value.match(/^(0x)?[0-9a-f]{64}$/i);
}

// node_modules/@thirdweb-dev/wallets/evm/wallets/frame/dist/thirdweb-dev-wallets-evm-wallets-frame.browser.esm.js
init_shim();
init_lib3();
var FrameWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Frame Wallet";
  }
  constructor(options) {
    super(FrameWallet.id, options);
    _defineProperty(this, "connector", void 0);
  }
  async getConnector() {
    if (!this.connector) {
      const {
        FrameConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-frame.browser.esm-C7YYMPFD.js");
      this.connector = new WagmiAdapter(new FrameConnector({
        chains: this.chains,
        connectorStorage: this.walletStorage,
        options: {
          shimDisconnect: true
        }
      }));
    }
    return this.connector;
  }
};
_defineProperty(FrameWallet, "id", walletIds.frame);

// node_modules/@thirdweb-dev/wallets/evm/wallets/metamask/dist/thirdweb-dev-wallets-evm-wallets-metamask.browser.esm.js
init_shim();
init_lib3();
var MetaMaskWallet = class extends AbstractClientWallet {
  get walletName() {
    return "MetaMask";
  }
  constructor(options) {
    var _a;
    super(MetaMaskWallet.id, options);
    _defineProperty(this, "connector", void 0);
    _defineProperty(this, "walletConnectConnector", void 0);
    _defineProperty(this, "metamaskConnector", void 0);
    _defineProperty(this, "isInjected", void 0);
    if (assertWindowEthereum(globalThis.window)) {
      this.isInjected = !!((_a = globalThis.window.ethereum) == null ? void 0 : _a.isMetaMask);
    } else {
      this.isInjected = false;
    }
  }
  async getConnector() {
    var _a;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          MetaMaskConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-metamask.browser.esm-6PIH4E75.js");
        const metamaskConnector = new MetaMaskConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.metamaskConnector = metamaskConnector;
        this.connector = new WagmiAdapter(metamaskConnector);
      } else {
        const {
          WalletConnectV1Connector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect-v1.browser.esm-NXFAKDKC.js");
        const walletConnectConnector = new WalletConnectV1Connector({
          chains: this.chains,
          storage: this.walletStorage,
          options: {
            clientMeta: {
              name: this.dappMetadata.name,
              description: this.dappMetadata.description || "",
              url: this.dappMetadata.url,
              icons: [this.dappMetadata.logoUrl || ""]
            },
            qrcode: (_a = this.options) == null ? void 0 : _a.qrcode
          }
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.connector.on("display_uri", (error, payload) => {
      options.onQrCodeUri(payload.params[0]);
    });
    await wcProvider.enable();
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
  async switchAccount() {
    if (!this.metamaskConnector) {
      throw new Error("Can not switch Account");
    }
    await this.metamaskConnector.switchAccount();
  }
};
_defineProperty(MetaMaskWallet, "meta", {
  name: "MetaMask",
  iconURL: "ipfs://QmZZHcw7zcXursywnLDAyY6Hfxzqop5GKgwoq8NB9jjrkN/metamask.svg",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn",
    android: "https://play.google.com/store/apps/details?id=io.metamask",
    ios: "https://apps.apple.com/us/app/metamask-blockchain-wallet/id1438144202"
  }
});
_defineProperty(MetaMaskWallet, "id", walletIds.metamask);

// node_modules/@thirdweb-dev/wallets/evm/wallets/wallet-connect/dist/thirdweb-dev-wallets-evm-wallets-wallet-connect.browser.esm.js
init_shim();
init_lib3();
var _walletConnectConnector = /* @__PURE__ */ new WeakMap();
var _provider = /* @__PURE__ */ new WeakMap();
var _maybeThrowError = /* @__PURE__ */ new WeakMap();
var _onConnect = /* @__PURE__ */ new WeakMap();
var _onDisconnect = /* @__PURE__ */ new WeakMap();
var _onChange = /* @__PURE__ */ new WeakMap();
var _onMessage = /* @__PURE__ */ new WeakMap();
var _onSessionRequestSent = /* @__PURE__ */ new WeakMap();
var _setupListeners = /* @__PURE__ */ new WeakSet();
var _removeListeners = /* @__PURE__ */ new WeakSet();
var WalletConnect2 = class extends AbstractClientWallet {
  get walletName() {
    return "WalletConnect";
  }
  constructor(options) {
    super((options == null ? void 0 : options.walletId) || WalletConnect2.id, options);
    _classPrivateMethodInitSpec(this, _removeListeners);
    _classPrivateMethodInitSpec(this, _setupListeners);
    _classPrivateFieldInitSpec(this, _walletConnectConnector, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _provider, {
      writable: true,
      value: void 0
    });
    _defineProperty(this, "connector", void 0);
    _defineProperty(this, "projectId", void 0);
    _defineProperty(this, "qrcode", void 0);
    _classPrivateFieldInitSpec(this, _maybeThrowError, {
      writable: true,
      value: (error) => {
        if (error) {
          throw error;
        }
      }
    });
    _classPrivateFieldInitSpec(this, _onConnect, {
      writable: true,
      value: (data) => {
        _classPrivateFieldSet(this, _provider, data.provider);
        if (!_classPrivateFieldGet(this, _provider)) {
          throw new Error("WalletConnect provider not found after connecting.");
        }
      }
    });
    _classPrivateFieldInitSpec(this, _onDisconnect, {
      writable: true,
      value: () => {
        _classPrivateMethodGet(this, _removeListeners, _removeListeners2).call(this);
      }
    });
    _classPrivateFieldInitSpec(this, _onChange, {
      writable: true,
      value: async (payload) => {
        if (payload.chain)
          ;
        else if (payload.account)
          ;
      }
    });
    _classPrivateFieldInitSpec(this, _onMessage, {
      writable: true,
      value: (payload) => {
        switch (payload.type) {
          case "display_uri":
            this.emit("open_wallet", payload.data);
            break;
        }
      }
    });
    _classPrivateFieldInitSpec(this, _onSessionRequestSent, {
      writable: true,
      value: () => {
        this.emit("open_wallet");
      }
    });
    this.projectId = (options == null ? void 0 : options.projectId) || TW_WC_PROJECT_ID;
    this.qrcode = (options == null ? void 0 : options.qrcode) === false ? false : true;
  }
  async getConnector() {
    var _a;
    if (!this.connector) {
      const {
        WalletConnectConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-NBQBHOII.js");
      _classPrivateFieldSet(this, _walletConnectConnector, new WalletConnectConnector({
        chains: this.chains,
        options: {
          qrcode: this.qrcode,
          projectId: this.projectId,
          dappMetadata: this.dappMetadata,
          storage: this.walletStorage,
          qrModalOptions: (_a = this.options) == null ? void 0 : _a.qrModalOptions
        }
      }));
      this.connector = new WagmiAdapter(_classPrivateFieldGet(this, _walletConnectConnector));
      _classPrivateFieldSet(this, _provider, await _classPrivateFieldGet(this, _walletConnectConnector).getProvider());
      _classPrivateMethodGet(this, _setupListeners, _setupListeners2).call(this);
    }
    return this.connector;
  }
};
function _setupListeners2() {
  var _a;
  if (!_classPrivateFieldGet(this, _walletConnectConnector)) {
    return;
  }
  _classPrivateMethodGet(this, _removeListeners, _removeListeners2).call(this);
  _classPrivateFieldGet(this, _walletConnectConnector).on("connect", _classPrivateFieldGet(this, _onConnect));
  _classPrivateFieldGet(this, _walletConnectConnector).on("disconnect", _classPrivateFieldGet(this, _onDisconnect));
  _classPrivateFieldGet(this, _walletConnectConnector).on("change", _classPrivateFieldGet(this, _onChange));
  _classPrivateFieldGet(this, _walletConnectConnector).on("message", _classPrivateFieldGet(this, _onMessage));
  (_a = _classPrivateFieldGet(this, _provider)) == null ? void 0 : _a.signer.client.on("session_request_sent", _classPrivateFieldGet(this, _onSessionRequestSent));
}
function _removeListeners2() {
  var _a;
  if (!_classPrivateFieldGet(this, _walletConnectConnector)) {
    return;
  }
  _classPrivateFieldGet(this, _walletConnectConnector).removeListener("connect", _classPrivateFieldGet(this, _onConnect));
  _classPrivateFieldGet(this, _walletConnectConnector).removeListener("disconnect", _classPrivateFieldGet(this, _onDisconnect));
  _classPrivateFieldGet(this, _walletConnectConnector).removeListener("change", _classPrivateFieldGet(this, _onChange));
  _classPrivateFieldGet(this, _walletConnectConnector).removeListener("message", _classPrivateFieldGet(this, _onMessage));
  (_a = _classPrivateFieldGet(this, _provider)) == null ? void 0 : _a.signer.client.removeListener("session_request_sent", _classPrivateFieldGet(this, _onSessionRequestSent));
}
_defineProperty(WalletConnect2, "id", walletIds.walletConnect);
_defineProperty(WalletConnect2, "meta", {
  name: "WalletConnect",
  iconURL: "ipfs://QmX58KPRaTC9JYZ7KriuBzeoEaV2P9eZcA3qbFnTHZazKw/wallet-connect.svg"
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/wallet-connect-v1/dist/thirdweb-dev-wallets-evm-wallets-wallet-connect-v1.browser.esm.js
init_shim();
init_lib3();
var _walletConnectConnector2 = /* @__PURE__ */ new WeakMap();
var _provider2 = /* @__PURE__ */ new WeakMap();
var _onConnect2 = /* @__PURE__ */ new WeakMap();
var _onDisconnect2 = /* @__PURE__ */ new WeakMap();
var _onChange2 = /* @__PURE__ */ new WeakMap();
var _onMessage2 = /* @__PURE__ */ new WeakMap();
var _setupListeners3 = /* @__PURE__ */ new WeakSet();
var _removeListeners3 = /* @__PURE__ */ new WeakSet();
var WalletConnectV1 = class extends AbstractClientWallet {
  get walletName() {
    var _a;
    return ((_a = _classPrivateFieldGet(this, _walletConnectConnector2)) == null ? void 0 : _a.walletName) || "WalletConnect";
  }
  constructor(options) {
    super((options == null ? void 0 : options.walletId) || WalletConnectV1.id, options);
    _classPrivateMethodInitSpec(this, _removeListeners3);
    _classPrivateMethodInitSpec(this, _setupListeners3);
    _classPrivateFieldInitSpec(this, _walletConnectConnector2, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _provider2, {
      writable: true,
      value: void 0
    });
    _defineProperty(this, "connector", void 0);
    _defineProperty(this, "qrcode", void 0);
    _classPrivateFieldInitSpec(this, _onConnect2, {
      writable: true,
      value: (data) => {
        _classPrivateFieldSet(this, _provider2, data.provider);
        if (!_classPrivateFieldGet(this, _provider2)) {
          throw new Error("WalletConnect provider not found after connecting.");
        }
      }
    });
    _classPrivateFieldInitSpec(this, _onDisconnect2, {
      writable: true,
      value: () => {
        _classPrivateMethodGet(this, _removeListeners3, _removeListeners22).call(this);
      }
    });
    _classPrivateFieldInitSpec(this, _onChange2, {
      writable: true,
      value: async (payload) => {
        if (payload.chain)
          ;
        else if (payload.account)
          ;
      }
    });
    _classPrivateFieldInitSpec(this, _onMessage2, {
      writable: true,
      value: (payload) => {
        switch (payload.type) {
          case "request":
          case "add_chain":
          case "switch_chain":
            this.emit("open_wallet");
            break;
          case "display_uri":
            this.emit("open_wallet", payload.data);
            break;
        }
      }
    });
    this.qrcode = (options == null ? void 0 : options.qrcode) === false ? false : true;
  }
  async getConnector() {
    if (!this.connector) {
      const {
        WalletConnectV1Connector
      } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect-v1.browser.esm-NXFAKDKC.js");
      _classPrivateFieldSet(this, _walletConnectConnector2, new WalletConnectV1Connector({
        chains: this.chains,
        storage: this.walletStorage,
        options: {
          qrcode: this.qrcode,
          clientMeta: {
            description: this.dappMetadata.description || "",
            url: this.dappMetadata.url,
            icons: [this.dappMetadata.logoUrl || ""],
            name: this.dappMetadata.name
          }
        }
      }));
      this.connector = new WagmiAdapter(_classPrivateFieldGet(this, _walletConnectConnector2));
      _classPrivateFieldSet(this, _provider2, await _classPrivateFieldGet(this, _walletConnectConnector2).getProvider());
      _classPrivateMethodGet(this, _setupListeners3, _setupListeners22).call(this);
    }
    return this.connector;
  }
};
function _setupListeners22() {
  if (!_classPrivateFieldGet(this, _walletConnectConnector2)) {
    return;
  }
  _classPrivateFieldGet(this, _walletConnectConnector2).on("connect", _classPrivateFieldGet(this, _onConnect2));
  _classPrivateFieldGet(this, _walletConnectConnector2).on("disconnect", _classPrivateFieldGet(this, _onDisconnect2));
  _classPrivateFieldGet(this, _walletConnectConnector2).on("change", _classPrivateFieldGet(this, _onChange2));
  _classPrivateFieldGet(this, _walletConnectConnector2).on("message", _classPrivateFieldGet(this, _onMessage2));
}
function _removeListeners22() {
  if (!_classPrivateFieldGet(this, _walletConnectConnector2)) {
    return;
  }
  _classPrivateFieldGet(this, _walletConnectConnector2).removeListener("connect", _classPrivateFieldGet(this, _onConnect2));
  _classPrivateFieldGet(this, _walletConnectConnector2).removeListener("disconnect", _classPrivateFieldGet(this, _onDisconnect2));
  _classPrivateFieldGet(this, _walletConnectConnector2).removeListener("change", _classPrivateFieldGet(this, _onChange2));
  _classPrivateFieldGet(this, _walletConnectConnector2).removeListener("message", _classPrivateFieldGet(this, _onMessage2));
}
_defineProperty(WalletConnectV1, "id", walletIds.walletConnectV1);
_defineProperty(WalletConnectV1, "meta", {
  name: "WalletConnect",
  iconURL: "ipfs://QmX58KPRaTC9JYZ7KriuBzeoEaV2P9eZcA3qbFnTHZazKw/wallet-connect.svg"
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/safe/dist/thirdweb-dev-wallets-evm-wallets-safe.browser.esm.js
init_shim();
init_lib3();
var import_safe_ethers_adapters = __toESM(require_src());
var import_safe_core_sdk = __toESM(require_src2());
var import_safe_ethers_lib = __toESM(require_src3());
var SafeWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Safe Wallet";
  }
  constructor(options) {
    super(SafeWallet.id, {
      ...options
    });
    _defineProperty(this, "connector", void 0);
  }
  async getConnector() {
    if (!this.connector) {
      const {
        SafeConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-safe.browser.esm-GCSFN3RP.js");
      this.connector = new SafeConnector();
    }
    return this.connector;
  }
  async updateChains(chains) {
  }
  getPersonalWallet() {
    var _a;
    return (_a = this.connector) == null ? void 0 : _a.personalWallet;
  }
  autoConnect(params) {
    return this.connect(params);
  }
};
_defineProperty(SafeWallet, "meta", {
  name: "Safe",
  iconURL: "ipfs://QmbbyxDDmmLQh8DzzeUR6X6B75bESsNUFmbdvS3ZsQ2pN1/SafeToken.svg"
});
_defineProperty(SafeWallet, "id", walletIds.safe);

// node_modules/@thirdweb-dev/wallets/evm/wallets/magic/dist/thirdweb-dev-wallets-evm-wallets-magic.browser.esm.js
init_shim();
init_lib3();
var MagicLink = class extends AbstractClientWallet {
  get walletName() {
    return "Magic Link";
  }
  constructor(options) {
    super(MagicLink.id, options);
    _defineProperty(this, "connector", void 0);
    _defineProperty(this, "magicConnector", void 0);
    _defineProperty(this, "options", void 0);
    this.options = options;
  }
  async initializeConnector() {
    const {
      MagicAuthConnector
    } = await import("./thirdweb-dev-wallets-evm-connectors-magic.browser.esm-YCME44J4.js");
    const magicConnector = new MagicAuthConnector({
      chains: this.chains,
      options: this.options
    });
    this.magicConnector = magicConnector;
    this.connector = new WagmiAdapter(magicConnector);
    return this.connector;
  }
  async getConnector() {
    if (!this.connector) {
      return await this.initializeConnector();
    }
    return this.connector;
  }
  getMagic() {
    if (!this.magicConnector) {
      throw new Error("Magic connector is not initialized");
    }
    return this.magicConnector.getMagicSDK();
  }
  async autoConnect(options) {
    var _a;
    await this.initializeConnector();
    await ((_a = this.magicConnector) == null ? void 0 : _a.initializeMagicSDK(options));
    const magic = this.getMagic();
    if (await magic.user.isLoggedIn()) {
      return super.autoConnect(options);
    } else {
      throw new Error("Magic user is not logged in");
    }
  }
  async disconnect() {
    const magic = this.getMagic();
    await magic.user.logout();
    return super.disconnect();
  }
  async connect(options) {
    if ("email" in options && this.options.emailLogin === false) {
      throw new Error("Email login is disabled");
    }
    if ("phoneNumber" in options && this.options.smsLogin === false) {
      throw new Error("SMS login is disabled");
    }
    return super.connect(options);
  }
};
_defineProperty(MagicLink, "meta", {
  iconURL: "ipfs://QmUMBFZGXxBpgDmZzZAHhbcCL5nYvZnVaYLTajsNjLcxMU/1-Icon_Magic_Color.svg",
  name: "Magic Link"
});
_defineProperty(MagicLink, "id", walletIds.magicLink);

// node_modules/@thirdweb-dev/wallets/evm/wallets/zerion/dist/thirdweb-dev-wallets-evm-wallets-zerion.browser.esm.js
init_shim();
init_lib3();
var ZerionWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Zerion Wallet";
  }
  constructor(options) {
    var _a;
    super(ZerionWallet.id, options);
    _defineProperty(this, "connector", void 0);
    _defineProperty(this, "zerionConnector", void 0);
    _defineProperty(this, "walletConnectConnector", void 0);
    _defineProperty(this, "isInjected", void 0);
    if (assertWindowEthereum(globalThis.window)) {
      this.isInjected = !!((_a = globalThis.window.ethereum) == null ? void 0 : _a.isZerion);
    } else {
      this.isInjected = false;
    }
  }
  async getConnector() {
    if (!this.connector) {
      if (this.isInjected) {
        const {
          ZerionConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-zerion.browser.esm-6SDTFEST.js");
        const zerionConnector = new ZerionConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.zerionConnector = zerionConnector;
        this.connector = new WagmiAdapter(zerionConnector);
      } else {
        const {
          WalletConnectV1Connector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect-v1.browser.esm-NXFAKDKC.js");
        const walletConnectConnector = new WalletConnectV1Connector({
          chains: this.chains,
          storage: this.walletStorage,
          options: {
            clientMeta: {
              name: this.dappMetadata.name,
              description: this.dappMetadata.description || "",
              url: this.dappMetadata.url,
              icons: [this.dappMetadata.logoUrl || ""]
            },
            qrcode: false
          }
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.connector.on("display_uri", (error, payload) => {
      options.onQrCodeUri(payload.params[0]);
    });
    await wcProvider.enable();
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(ZerionWallet, "id", "zerion");
_defineProperty(ZerionWallet, "meta", {
  name: "Zerion Wallet",
  iconURL: "https://tokenlists-icons.s3.amazonaws.com/zerion.png",
  urls: {
    chrome: "https://zerion.io/extension",
    android: "https://link.zerion.io/901o6IN0jqb",
    ios: "https://link.zerion.io/a11o6IN0jqb"
  }
});

// node_modules/@thirdweb-dev/wallets/dist/thirdweb-dev-wallets.browser.esm.js
init_shim();

// node_modules/@thirdweb-dev/wallets/evm/wallets/injected/dist/thirdweb-dev-wallets-evm-wallets-injected.browser.esm.js
init_shim();
init_lib3();
var InjectedWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Injected Wallet";
  }
  constructor(options) {
    super(InjectedWallet.id, options);
    _defineProperty(this, "connector", void 0);
  }
  async getConnector() {
    if (!this.connector) {
      const {
        InjectedConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-injected.browser.esm-GXOBTCLJ.js");
      this.connector = new WagmiAdapter(new InjectedConnector({
        chains: this.chains,
        connectorStorage: this.walletStorage,
        options: {
          shimDisconnect: true
        }
      }));
    }
    return this.connector;
  }
};
_defineProperty(InjectedWallet, "id", "injected");

// node_modules/@thirdweb-dev/wallets/evm/wallets/ethers/dist/thirdweb-dev-wallets-evm-wallets-ethers.browser.esm.js
init_shim();
init_lib3();

// node_modules/@thirdweb-dev/wallets/evm/wallets/private-key/dist/thirdweb-dev-wallets-evm-wallets-private-key.browser.esm.js
init_shim();
init_lib3();

// node_modules/@thirdweb-dev/wallets/dist/thirdweb-dev-wallets.browser.esm.js
init_lib3();
init_esm3();
var import_buffer2 = __toESM(require_buffer());
var import_safe_ethers_adapters2 = __toESM(require_src());
var import_safe_core_sdk2 = __toESM(require_src2());
var import_safe_ethers_lib2 = __toESM(require_src3());

export {
  createAsyncLocalStorage,
  SmartWallet,
  PaperWallet,
  CoinbaseWallet,
  LocalWallet,
  FrameWallet,
  MetaMaskWallet,
  WalletConnect2 as WalletConnect,
  WalletConnectV1,
  SafeWallet,
  MagicLink,
  ZerionWallet
};
//# sourceMappingURL=chunk-RDOPESVP.js.map
