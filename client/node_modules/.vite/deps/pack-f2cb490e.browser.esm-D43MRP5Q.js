import {
  hasERC20Allowance
} from "./chunk-5UEGDNJK.js";
import {
  StandardErc1155
} from "./chunk-JHRKZYUE.js";
import {
  AbiSchema,
  AddressOrEnsSchema,
  AmountSchema,
  BigNumberishSchema,
  ContractAppURI,
  ContractEncoder,
  ContractEvents,
  ContractInterceptor,
  ContractMetadata,
  ContractOwner,
  ContractRoles,
  ContractRoyalty,
  ContractWrapper,
  Erc20,
  FEATURE_PACK_VRF,
  GasCostEstimator,
  IPackVRFDirect_default,
  LINK_TOKEN_ADDRESS,
  NFTInputOrUriSchema,
  PackContractSchema,
  RawDateSchema,
  Transaction,
  _defineProperty,
  assertEnabled,
  buildTransactionFunction,
  detectContractFeature,
  fetchCurrencyMetadata,
  getRoleHash,
  isTokenApprovedForTransfer,
  normalizePriceValue,
  require_bs58,
  require_dist,
  require_fast_deep_equal,
  resolveAddress,
  uploadOrExtractURI,
  z
} from "./chunk-6GQJFAXU.js";
import "./chunk-XUXNDKXO.js";
import {
  require_browser_ponyfill
} from "./chunk-KSBPR6CT.js";
import {
  require_utils
} from "./chunk-XQLXTUOU.js";
import "./chunk-MF32MPNC.js";
import "./chunk-24M2PVBU.js";
import {
  ethers_exports,
  init_lib7 as init_lib
} from "./chunk-T4GQYX7O.js";
import {
  BigNumber
} from "./chunk-RGAYGF33.js";
import "./chunk-XLOOGUEN.js";
import {
  require_bn
} from "./chunk-2O4376VB.js";
import "./chunk-MLWVUS32.js";
import {
  init_shim
} from "./chunk-ZGMFR26H.js";
import {
  __toESM
} from "./chunk-IKJM6GHQ.js";

// node_modules/@thirdweb-dev/sdk/dist/pack-f2cb490e.browser.esm.js
init_shim();

// node_modules/@thirdweb-dev/contracts-js/dist/abis/ERC20.json
var ERC20_default = [
  {
    inputs: [
      {
        internalType: "string",
        name: "name_",
        type: "string"
      },
      {
        internalType: "string",
        name: "symbol_",
        type: "string"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "spender",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "subtractedValue",
        type: "uint256"
      }
    ],
    name: "decreaseAllowance",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "addedValue",
        type: "uint256"
      }
    ],
    name: "increaseAllowance",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "transfer",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/sdk/dist/pack-f2cb490e.browser.esm.js
init_lib();
var import_bn = __toESM(require_bn());
var import_merkletreejs = __toESM(require_dist());
var import_fast_deep_equal = __toESM(require_fast_deep_equal());
var import_utils = __toESM(require_utils());
var import_bs58 = __toESM(require_bs58());
var import_cross_fetch = __toESM(require_browser_ponyfill());
var import_utils2 = __toESM(require_utils());
var PackVRF = class {
  constructor(network, address, storage, options, chainId) {
    var _this = this;
    let contractWrapper = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : new ContractWrapper(network, address, IPackVRFDirect_default, options);
    _defineProperty(this, "featureName", FEATURE_PACK_VRF.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "chainId", void 0);
    _defineProperty(this, "events", void 0);
    _defineProperty(this, "open", buildTransactionFunction(async function(tokenId) {
      let amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      let gasLimit = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 5e5;
      return Transaction.fromContractWrapper({
        contractWrapper: _this.contractWrapper,
        method: "openPack",
        args: [tokenId, amount],
        overrides: {
          gasLimit
        },
        parse: (receipt) => {
          let id = BigNumber.from(0);
          try {
            const event = _this.contractWrapper.parseLogs("PackOpenRequested", receipt == null ? void 0 : receipt.logs);
            id = event[0].args.requestId;
          } catch (e) {
          }
          return {
            receipt,
            id
          };
        }
      });
    }));
    _defineProperty(this, "claimRewards", buildTransactionFunction(async function() {
      let gasLimit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 5e5;
      return Transaction.fromContractWrapper({
        contractWrapper: _this.contractWrapper,
        method: "claimRewards",
        args: [],
        overrides: {
          gasLimit
        },
        parse: async (receipt) => {
          const event = _this.contractWrapper.parseLogs("PackOpened", receipt == null ? void 0 : receipt.logs);
          if (event.length === 0) {
            throw new Error("PackOpened event not found");
          }
          const rewards = event[0].args.rewardUnitsDistributed;
          return await _this.parseRewards(rewards);
        }
      });
    }));
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.chainId = chainId;
    this.events = new ContractEvents(this.contractWrapper);
  }
  onNetworkUpdated(network) {
    this.contractWrapper.updateSignerOrProvider(network);
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  async parseRewards(rewards) {
    const erc20Rewards = [];
    const erc721Rewards = [];
    const erc1155Rewards = [];
    for (const reward of rewards) {
      switch (reward.tokenType) {
        case 0: {
          const tokenMetadata = await fetchCurrencyMetadata(this.contractWrapper.getProvider(), reward.assetContract);
          erc20Rewards.push({
            contractAddress: reward.assetContract,
            quantityPerReward: ethers_exports.utils.formatUnits(reward.totalAmount, tokenMetadata.decimals).toString()
          });
          break;
        }
        case 1: {
          erc721Rewards.push({
            contractAddress: reward.assetContract,
            tokenId: reward.tokenId.toString()
          });
          break;
        }
        case 2: {
          erc1155Rewards.push({
            contractAddress: reward.assetContract,
            tokenId: reward.tokenId.toString(),
            quantityPerReward: reward.totalAmount.toString()
          });
          break;
        }
      }
    }
    return {
      erc20Rewards,
      erc721Rewards,
      erc1155Rewards
    };
  }
  async addPackOpenEventListener(callback) {
    return this.events.addEventListener("PackOpened", async (event) => {
      callback(event.data.packId.toString(), event.data.opener, await this.parseRewards(event.data.rewardUnitsDistributed));
    });
  }
  async canClaimRewards(claimerAddress) {
    const address = await resolveAddress(claimerAddress || await this.contractWrapper.getSignerAddress());
    return await this.contractWrapper.readContract.canClaimRewards(address);
  }
  async openAndClaim(packId) {
    let amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    let gasLimit = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 5e5;
    const receipt = await this.contractWrapper.sendTransaction("openPackAndClaimRewards", [packId, amount, gasLimit], {
      gasLimit: BigNumber.from(5e5)
    });
    let id = BigNumber.from(0);
    try {
      const event = this.contractWrapper.parseLogs("PackOpenRequested", receipt == null ? void 0 : receipt.logs);
      id = event[0].args.requestId;
    } catch (e) {
    }
    return {
      receipt,
      id
    };
  }
  async getLinkBalance() {
    return this.getLinkContract().balanceOf(this.contractWrapper.readContract.address);
  }
  async transferLink(amount) {
    await this.getLinkContract().transfer(this.contractWrapper.readContract.address, amount);
  }
  getLinkContract() {
    const linkAddress = LINK_TOKEN_ADDRESS[this.chainId];
    if (!linkAddress) {
      throw new Error(`No LINK token address found for chainId ${this.chainId}`);
    }
    const contract = new ContractWrapper(this.contractWrapper.getSignerOrProvider(), linkAddress, ERC20_default, this.contractWrapper.options);
    return new Erc20(contract, this.storage, this.chainId);
  }
};
var CommonWrappableSchema = z.object({
  contractAddress: AddressOrEnsSchema
});
var ERC20WrappableSchema = CommonWrappableSchema.extend({
  quantity: AmountSchema
});
var ERC721WrappableSchema = CommonWrappableSchema.extend({
  tokenId: BigNumberishSchema
});
var ERC1155WrappableSchema = CommonWrappableSchema.extend({
  tokenId: BigNumberishSchema,
  quantity: BigNumberishSchema
});
var ERC20RewardSchema = ERC20WrappableSchema.omit({
  quantity: true
}).extend({
  quantityPerReward: AmountSchema
});
var ERC721RewardSchema = ERC721WrappableSchema;
var ERC1155RewardSchema = ERC1155WrappableSchema.omit({
  quantity: true
}).extend({
  quantityPerReward: BigNumberishSchema
});
var ERC20RewardContentsSchema = ERC20RewardSchema.extend({
  totalRewards: BigNumberishSchema.default("1")
});
var ERC721RewardContentsSchema = ERC721RewardSchema;
var ERC1155RewardContentsSchema = ERC1155RewardSchema.extend({
  totalRewards: BigNumberishSchema.default("1")
});
z.object({
  erc20Rewards: z.array(ERC20RewardSchema).default([]),
  erc721Rewards: z.array(ERC721RewardSchema).default([]),
  erc1155Rewards: z.array(ERC1155RewardSchema).default([])
});
var PackRewardsOutputSchema = z.object({
  erc20Rewards: z.array(ERC20RewardContentsSchema).default([]),
  erc721Rewards: z.array(ERC721RewardContentsSchema).default([]),
  erc1155Rewards: z.array(ERC1155RewardContentsSchema).default([])
});
var PackMetadataInputSchema = PackRewardsOutputSchema.extend({
  packMetadata: NFTInputOrUriSchema,
  rewardsPerPack: BigNumberishSchema.default("1"),
  openStartTime: RawDateSchema.default(new Date())
});
var Pack = class extends StandardErc1155 {
  get vrf() {
    return assertEnabled(this._vrf, FEATURE_PACK_VRF);
  }
  constructor(network, address, storage) {
    var _this;
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    let abi = arguments.length > 4 ? arguments[4] : void 0;
    let chainId = arguments.length > 5 ? arguments[5] : void 0;
    let contractWrapper = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : new ContractWrapper(network, address, abi, options.gasless && "openzeppelin" in options.gasless ? {
      ...options,
      gasless: {
        ...options.gasless,
        openzeppelin: {
          ...options.gasless.openzeppelin,
          useEOAForwarder: true
        }
      }
    } : options);
    super(contractWrapper, storage, chainId);
    _this = this;
    _defineProperty(this, "abi", void 0);
    _defineProperty(this, "metadata", void 0);
    _defineProperty(this, "app", void 0);
    _defineProperty(this, "roles", void 0);
    _defineProperty(this, "encoder", void 0);
    _defineProperty(this, "events", void 0);
    _defineProperty(this, "estimator", void 0);
    _defineProperty(this, "royalties", void 0);
    _defineProperty(this, "interceptor", void 0);
    _defineProperty(this, "owner", void 0);
    _defineProperty(this, "_vrf", void 0);
    _defineProperty(this, "create", buildTransactionFunction(async (metadataWithRewards) => {
      const signerAddress = await this.contractWrapper.getSignerAddress();
      return this.createTo.prepare(signerAddress, metadataWithRewards);
    }));
    _defineProperty(this, "addPackContents", buildTransactionFunction(async (packId, packContents) => {
      const signerAddress = await this.contractWrapper.getSignerAddress();
      const parsedContents = await PackRewardsOutputSchema.parseAsync(packContents);
      const {
        contents,
        numOfRewardUnits
      } = await this.toPackContentArgs(parsedContents);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "addPackContents",
        args: [packId, contents, numOfRewardUnits, signerAddress],
        parse: (receipt) => {
          const event = this.contractWrapper.parseLogs("PackUpdated", receipt == null ? void 0 : receipt.logs);
          if (event.length === 0) {
            throw new Error("PackUpdated event not found");
          }
          const id = event[0].args.packId;
          return {
            id,
            receipt,
            data: () => this.erc1155.get(id)
          };
        }
      });
    }));
    _defineProperty(this, "createTo", buildTransactionFunction(async (to, metadataWithRewards) => {
      const uri = await uploadOrExtractURI(metadataWithRewards.packMetadata, this.storage);
      const parsedMetadata = await PackMetadataInputSchema.parseAsync(metadataWithRewards);
      const {
        erc20Rewards,
        erc721Rewards,
        erc1155Rewards
      } = parsedMetadata;
      const rewardsData = {
        erc20Rewards,
        erc721Rewards,
        erc1155Rewards
      };
      const {
        contents,
        numOfRewardUnits
      } = await this.toPackContentArgs(rewardsData);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "createPack",
        args: [contents, numOfRewardUnits, uri, parsedMetadata.openStartTime, parsedMetadata.rewardsPerPack, await resolveAddress(to)],
        parse: (receipt) => {
          const event = this.contractWrapper.parseLogs("PackCreated", receipt == null ? void 0 : receipt.logs);
          if (event.length === 0) {
            throw new Error("PackCreated event not found");
          }
          const packId = event[0].args.packId;
          return {
            id: packId,
            receipt,
            data: () => this.erc1155.get(packId)
          };
        }
      });
    }));
    _defineProperty(this, "open", buildTransactionFunction(async function(tokenId) {
      let amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      let gasLimit = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 5e5;
      if (_this._vrf) {
        throw new Error("This contract is using Chainlink VRF, use `contract.vrf.open()` or `contract.vrf.openAndClaim()` instead");
      }
      return Transaction.fromContractWrapper({
        contractWrapper: _this.contractWrapper,
        method: "openPack",
        args: [tokenId, amount],
        overrides: {
          gasLimit
        },
        parse: async (receipt) => {
          const event = _this.contractWrapper.parseLogs("PackOpened", receipt == null ? void 0 : receipt.logs);
          if (event.length === 0) {
            throw new Error("PackOpened event not found");
          }
          const rewards = event[0].args.rewardUnitsDistributed;
          const erc20Rewards = [];
          const erc721Rewards = [];
          const erc1155Rewards = [];
          for (const reward of rewards) {
            switch (reward.tokenType) {
              case 0: {
                const tokenMetadata = await fetchCurrencyMetadata(_this.contractWrapper.getProvider(), reward.assetContract);
                erc20Rewards.push({
                  contractAddress: reward.assetContract,
                  quantityPerReward: ethers_exports.utils.formatUnits(reward.totalAmount, tokenMetadata.decimals).toString()
                });
                break;
              }
              case 1: {
                erc721Rewards.push({
                  contractAddress: reward.assetContract,
                  tokenId: reward.tokenId.toString()
                });
                break;
              }
              case 2: {
                erc1155Rewards.push({
                  contractAddress: reward.assetContract,
                  tokenId: reward.tokenId.toString(),
                  quantityPerReward: reward.totalAmount.toString()
                });
                break;
              }
            }
          }
          return {
            erc20Rewards,
            erc721Rewards,
            erc1155Rewards
          };
        }
      });
    }));
    this.abi = AbiSchema.parse(abi || []);
    this.metadata = new ContractMetadata(this.contractWrapper, PackContractSchema, this.storage);
    this.app = new ContractAppURI(this.contractWrapper, this.metadata, this.storage);
    this.roles = new ContractRoles(this.contractWrapper, Pack.contractRoles);
    this.royalties = new ContractRoyalty(this.contractWrapper, this.metadata);
    this.encoder = new ContractEncoder(this.contractWrapper);
    this.estimator = new GasCostEstimator(this.contractWrapper);
    this.events = new ContractEvents(this.contractWrapper);
    this.interceptor = new ContractInterceptor(this.contractWrapper);
    this.owner = new ContractOwner(this.contractWrapper);
    this._vrf = this.detectVrf();
  }
  onNetworkUpdated(network) {
    var _a;
    this.contractWrapper.updateSignerOrProvider(network);
    (_a = this._vrf) == null ? void 0 : _a.onNetworkUpdated(network);
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  async get(tokenId) {
    return this.erc1155.get(tokenId);
  }
  async getAll(queryParams) {
    return this.erc1155.getAll(queryParams);
  }
  async getOwned(walletAddress) {
    return this.erc1155.getOwned(walletAddress);
  }
  async getTotalCount() {
    return this.erc1155.totalCount();
  }
  async isTransferRestricted() {
    const anyoneCanTransfer = await this.contractWrapper.readContract.hasRole(getRoleHash("transfer"), ethers_exports.constants.AddressZero);
    return !anyoneCanTransfer;
  }
  async getPackContents(packId) {
    const {
      contents,
      perUnitAmounts
    } = await this.contractWrapper.readContract.getPackContents(packId);
    const erc20Rewards = [];
    const erc721Rewards = [];
    const erc1155Rewards = [];
    for (let i = 0; i < contents.length; i++) {
      const reward = contents[i];
      const amount = perUnitAmounts[i];
      switch (reward.tokenType) {
        case 0: {
          const tokenMetadata = await fetchCurrencyMetadata(this.contractWrapper.getProvider(), reward.assetContract);
          const quantityPerReward = ethers_exports.utils.formatUnits(amount, tokenMetadata.decimals);
          const totalRewards = ethers_exports.utils.formatUnits(BigNumber.from(reward.totalAmount).div(amount), tokenMetadata.decimals);
          erc20Rewards.push({
            contractAddress: reward.assetContract,
            quantityPerReward,
            totalRewards
          });
          break;
        }
        case 1: {
          erc721Rewards.push({
            contractAddress: reward.assetContract,
            tokenId: reward.tokenId.toString()
          });
          break;
        }
        case 2: {
          erc1155Rewards.push({
            contractAddress: reward.assetContract,
            tokenId: reward.tokenId.toString(),
            quantityPerReward: amount.toString(),
            totalRewards: BigNumber.from(reward.totalAmount).div(amount).toString()
          });
          break;
        }
      }
    }
    return {
      erc20Rewards,
      erc721Rewards,
      erc1155Rewards
    };
  }
  async toPackContentArgs(metadataWithRewards) {
    const contents = [];
    const numOfRewardUnits = [];
    const {
      erc20Rewards,
      erc721Rewards,
      erc1155Rewards
    } = metadataWithRewards;
    const provider = this.contractWrapper.getProvider();
    const owner = await this.contractWrapper.getSignerAddress();
    for (const erc20 of erc20Rewards) {
      const normalizedQuantity = await normalizePriceValue(provider, erc20.quantityPerReward, erc20.contractAddress);
      const totalQuantity = normalizedQuantity.mul(erc20.totalRewards);
      const hasAllowance = await hasERC20Allowance(this.contractWrapper, erc20.contractAddress, totalQuantity);
      if (!hasAllowance) {
        throw new Error(`ERC20 token with contract address "${erc20.contractAddress}" does not have enough allowance to transfer.

You can set allowance to the multiwrap contract to transfer these tokens by running:

await sdk.getToken("${erc20.contractAddress}").setAllowance("${this.getAddress()}", ${totalQuantity});

`);
      }
      numOfRewardUnits.push(erc20.totalRewards);
      contents.push({
        assetContract: erc20.contractAddress,
        tokenType: 0,
        totalAmount: totalQuantity,
        tokenId: 0
      });
    }
    for (const erc721 of erc721Rewards) {
      const isApproved = await isTokenApprovedForTransfer(this.contractWrapper.getProvider(), this.getAddress(), erc721.contractAddress, erc721.tokenId, owner);
      if (!isApproved) {
        throw new Error(`ERC721 token "${erc721.tokenId}" with contract address "${erc721.contractAddress}" is not approved for transfer.

You can give approval the multiwrap contract to transfer this token by running:

await sdk.getNFTCollection("${erc721.contractAddress}").setApprovalForToken("${this.getAddress()}", ${erc721.tokenId});

`);
      }
      numOfRewardUnits.push("1");
      contents.push({
        assetContract: erc721.contractAddress,
        tokenType: 1,
        totalAmount: 1,
        tokenId: erc721.tokenId
      });
    }
    for (const erc1155 of erc1155Rewards) {
      const isApproved = await isTokenApprovedForTransfer(this.contractWrapper.getProvider(), this.getAddress(), erc1155.contractAddress, erc1155.tokenId, owner);
      if (!isApproved) {
        throw new Error(`ERC1155 token "${erc1155.tokenId}" with contract address "${erc1155.contractAddress}" is not approved for transfer.

You can give approval the multiwrap contract to transfer this token by running:

await sdk.getEdition("${erc1155.contractAddress}").setApprovalForAll("${this.getAddress()}", true);

`);
      }
      numOfRewardUnits.push(erc1155.totalRewards);
      contents.push({
        assetContract: erc1155.contractAddress,
        tokenType: 2,
        totalAmount: BigNumber.from(erc1155.quantityPerReward).mul(BigNumber.from(erc1155.totalRewards)),
        tokenId: erc1155.tokenId
      });
    }
    return {
      contents,
      numOfRewardUnits
    };
  }
  async prepare(method, args, overrides) {
    return Transaction.fromContractWrapper({
      contractWrapper: this.contractWrapper,
      method,
      args,
      overrides
    });
  }
  async call(functionName, args, overrides) {
    return this.contractWrapper.call(functionName, args, overrides);
  }
  detectVrf() {
    if (detectContractFeature(this.contractWrapper, "PackVRF")) {
      return new PackVRF(this.contractWrapper.getSignerOrProvider(), this.contractWrapper.readContract.address, this.storage, this.contractWrapper.options, this.chainId);
    }
    return void 0;
  }
};
_defineProperty(Pack, "contractRoles", ["admin", "minter", "asset", "transfer"]);
export {
  Pack
};
//# sourceMappingURL=pack-f2cb490e.browser.esm-D43MRP5Q.js.map
