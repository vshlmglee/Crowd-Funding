{
  "version": 3,
  "sources": ["../../@thirdweb-dev/wallets/evm/connectors/metamask/dist/thirdweb-dev-wallets-evm-connectors-metamask.browser.esm.js"],
  "sourcesContent": ["import { _ as _classPrivateFieldInitSpec, a as _classPrivateFieldSet, b as _classPrivateFieldGet } from '../../../../dist/classPrivateFieldSet-a5db7c83.browser.esm.js';\nimport { _ as _defineProperty } from '../../../../dist/defineProperty-c8ecdc07.browser.esm.js';\nimport { a as ConnectorNotFoundError, U as UserRejectedRequestError, R as ResourceUnavailableError } from '../../../../dist/errors-105ad187.browser.esm.js';\nimport { a as assertWindowEthereum } from '../../../../dist/assertWindowEthereum-66ccef46.browser.esm.js';\nimport { w as walletIds } from '../../../../dist/walletIds-99b78e4a.browser.esm.js';\nimport { InjectedConnector } from '../../injected/dist/thirdweb-dev-wallets-evm-connectors-injected.browser.esm.js';\nimport { utils } from 'ethers';\nimport '../../../../dist/WagmiConnector-60b19604.browser.esm.js';\nimport '@thirdweb-dev/chains';\nimport 'eventemitter3';\nimport '../../../../dist/normalizeChainId-e4cc0175.browser.esm.js';\n\nvar _UNSTABLE_shimOnConnectSelectAccount = /*#__PURE__*/new WeakMap();\nclass MetaMaskConnector extends InjectedConnector {\n  constructor(arg) {\n    const defaultOptions = {\n      name: \"MetaMask\",\n      shimDisconnect: true,\n      shimChainChangedDisconnect: true,\n      getProvider() {\n        function getReady(ethereum) {\n          const isMetaMask = !!ethereum?.isMetaMask;\n          if (!isMetaMask) {\n            return;\n          }\n          // Brave tries to make itself look like MetaMask\n          // Could also try RPC `web3_clientVersion` if following is unreliable\n          if (ethereum.isBraveWallet && !ethereum._events && !ethereum._state) {\n            return;\n          }\n          if (ethereum.isAvalanche) {\n            return;\n          }\n          if (ethereum.isKuCoinWallet) {\n            return;\n          }\n          if (ethereum.isPortal) {\n            return;\n          }\n          if (ethereum.isTokenPocket) {\n            return;\n          }\n          if (ethereum.isTokenary) {\n            return;\n          }\n          return ethereum;\n        }\n        if (assertWindowEthereum(globalThis.window)) {\n          if (globalThis.window.ethereum?.providers) {\n            return globalThis.window.ethereum.providers.find(getReady);\n          }\n          return getReady(globalThis.window.ethereum);\n        }\n      }\n    };\n    const options = {\n      ...defaultOptions,\n      ...arg.options\n    };\n    super({\n      chains: arg.chains,\n      options,\n      connectorStorage: arg.connectorStorage\n    });\n    _defineProperty(this, \"id\", walletIds.metamask);\n    _classPrivateFieldInitSpec(this, _UNSTABLE_shimOnConnectSelectAccount, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _UNSTABLE_shimOnConnectSelectAccount, options.UNSTABLE_shimOnConnectSelectAccount);\n  }\n\n  /**\n   * Connect to injected MetaMask provider\n   */\n  async connect() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    try {\n      const provider = await this.getProvider();\n      if (!provider) {\n        throw new ConnectorNotFoundError();\n      }\n      this.setupListeners();\n\n      // emit \"connecting\" event\n      this.emit(\"message\", {\n        type: \"connecting\"\n      });\n\n      // Attempt to show wallet select prompt with `wallet_requestPermissions` when\n      // `shimDisconnect` is active and account is in disconnected state (flag in storage)\n      let account = null;\n      if (_classPrivateFieldGet(this, _UNSTABLE_shimOnConnectSelectAccount) && this.options?.shimDisconnect && !Boolean(this.connectorStorage.getItem(this.shimDisconnectKey))) {\n        account = await this.getAccount().catch(() => null);\n        const isConnected = !!account;\n        if (isConnected) {\n          // Attempt to show another prompt for selecting wallet if already connected\n          try {\n            await provider.request({\n              method: \"wallet_requestPermissions\",\n              params: [{\n                eth_accounts: {}\n              }]\n            });\n          } catch (error) {\n            // Not all MetaMask injected providers support `wallet_requestPermissions` (e.g. MetaMask iOS).\n            // Only bubble up error if user rejects request\n            if (this.isUserRejectedRequestError(error)) {\n              throw new UserRejectedRequestError(error);\n            }\n          }\n        }\n      }\n\n      // if account is not already set, request accounts and use the first account\n      if (!account) {\n        const accounts = await provider.request({\n          method: \"eth_requestAccounts\"\n        });\n        account = utils.getAddress(accounts[0]);\n      }\n\n      // get currently connected chainId\n      let connectedChainId = await this.getChainId();\n      // check if connected chain is unsupported\n      let isUnsupported = this.isChainUnsupported(connectedChainId);\n\n      // if chainId is given, but does not match the currently connected chainId, switch to the given chainId\n      if (options.chainId && connectedChainId !== options.chainId) {\n        try {\n          await this.switchChain(options.chainId);\n          // recalculate the chainId and isUnsupported\n          connectedChainId = options.chainId;\n          isUnsupported = this.isChainUnsupported(options.chainId);\n        } catch (e) {\n          console.error(`Could not switch to chain id : ${options.chainId}`, e);\n        }\n      }\n\n      // if shimDisconnect is enabled\n      if (this.options?.shimDisconnect) {\n        // add shimDisconnectKey in storage - this signals that connector is \"connected\"\n        await this.connectorStorage.setItem(this.shimDisconnectKey, \"true\");\n      }\n      const connectionInfo = {\n        chain: {\n          id: connectedChainId,\n          unsupported: isUnsupported\n        },\n        provider: provider,\n        account\n      };\n      this.emit(\"connect\", connectionInfo);\n      return connectionInfo;\n    } catch (error) {\n      if (this.isUserRejectedRequestError(error)) {\n        throw new UserRejectedRequestError(error);\n      }\n      if (error.code === -32002) {\n        throw new ResourceUnavailableError(error);\n      }\n      throw error;\n    }\n  }\n  async switchAccount() {\n    const provider = await this.getProvider();\n    await provider.request({\n      method: \"wallet_requestPermissions\",\n      params: [{\n        eth_accounts: {}\n      }]\n    });\n  }\n}\n\nexport { MetaMaskConnector };\n"],
  "mappings": "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",
  "names": []
}
