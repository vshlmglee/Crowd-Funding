import {
  AbiSchema,
  AddressOrEnsSchema,
  AddressZero,
  AmountSchema,
  BigNumberSchema,
  BigNumberTransformSchema,
  BigNumberishSchema,
  COMMON_FACTORY,
  CONTRACT_ADDRESSES,
  CUSTOM_GAS_FOR_CHAIN,
  ChainId,
  CommonNFTInput,
  CommonNFTOutput,
  ContractPublisher,
  ContractPublisher_default,
  ContractWrapper,
  DEFAULT_API_KEY,
  DEPLOYER_ABI,
  DEPLOYER_BYTECODE,
  DeployTransaction,
  EditionDropInitializer,
  EditionInitializer,
  EventType,
  GAS_LIMIT_FOR_DEPLOYER,
  IERC20_default,
  IThirdwebContract_default,
  MarketplaceInitializer,
  MarketplaceV3Initializer,
  MultiwrapInitializer,
  NATIVE_TOKEN_ADDRESS,
  NFTCollectionInitializer,
  NFTDropInitializer,
  NFTInputOrUriSchema,
  PREBUILT_CONTRACTS_APPURI_MAP,
  PREBUILT_CONTRACTS_MAP,
  PackInitializer,
  RPCConnectionHandler,
  SignatureDropInitializer,
  SmartContract,
  SplitInitializer,
  TWMultichainRegistryLogic_default,
  ThirdwebStorage,
  TokenDropInitializer,
  TokenInitializer,
  Transaction,
  VoteInitializer,
  _defineProperty,
  buildDeployTransactionFunction,
  buildTransactionFunction,
  caches,
  computeDeploymentAddress,
  computeDeploymentInfo,
  computeForwarderAddress,
  detectFeatures,
  encodeConstructorParamsForImplementation,
  extractConstructorParamsFromAbi,
  fetchAndCacheDeployMetadata,
  fetchAndCachePublishedContractURI,
  fetchContractMetadataFromAddress,
  fetchCurrencyValue,
  fetchExtendedReleaseMetadata,
  fetchSourceFilesFromMetadata,
  getAllPluginsAbi,
  getChainProvider,
  getCompositePluginABI,
  getContractAddressByChainId,
  getContractName,
  getContractPublisherAddress,
  getContractTypeForRemoteName,
  getCreate2FactoryAddress,
  getCreate2FactoryDeploymentInfo,
  getInitBytecodeWithSalt,
  getMultichainRegistryAddress,
  getSignerAndProvider,
  hasMatchingAbi,
  invariant,
  isChainConfig,
  isContractDeployed,
  isEIP155Enforced,
  isFeatureEnabled,
  isNativeToken,
  normalizePriceValue,
  require_bs58,
  require_dist,
  require_fast_deep_equal,
  resolveAddress,
  resolveContractUriFromAddress,
  setSupportedChains,
  signTypedDataInternal,
  z
} from "./chunk-6GQJFAXU.js";
import {
  require_browser_ponyfill
} from "./chunk-KSBPR6CT.js";
import {
  require_utils
} from "./chunk-XQLXTUOU.js";
import {
  defaultChains
} from "./chunk-MF32MPNC.js";
import {
  eventemitter3_default,
  import_index
} from "./chunk-24M2PVBU.js";
import {
  Contract,
  Wallet,
  ethers_exports,
  init_lib7 as init_lib,
  utils_exports
} from "./chunk-T4GQYX7O.js";
import {
  BigNumber,
  lib_exports8 as lib_exports
} from "./chunk-RGAYGF33.js";
import {
  require_bn
} from "./chunk-2O4376VB.js";
import {
  import_process,
  init_shim
} from "./chunk-ZGMFR26H.js";
import {
  __toESM
} from "./chunk-IKJM6GHQ.js";

// node_modules/@thirdweb-dev/sdk/dist/thirdweb-dev-sdk.browser.esm.js
init_shim();

// node_modules/@thirdweb-dev/sdk/dist/abi-197c81ef.browser.esm.js
init_shim();

// node_modules/@thirdweb-dev/sdk/dist/sdk-1fbd7918.browser.esm.js
init_shim();

// node_modules/@thirdweb-dev/contracts-js/dist/abis/TWMultichainRegistryRouter.json
var TWMultichainRegistryRouter_default = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_pluginMap",
        type: "address"
      },
      {
        internalType: "address[]",
        name: "_trustedForwarders",
        type: "address[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes4",
        name: "functionSelector",
        type: "bytes4"
      },
      {
        indexed: true,
        internalType: "address",
        name: "pluginAddress",
        type: "address"
      }
    ],
    name: "PluginAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes4",
        name: "functionSelector",
        type: "bytes4"
      },
      {
        indexed: true,
        internalType: "address",
        name: "pluginAddress",
        type: "address"
      }
    ],
    name: "PluginRemoved",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes4",
        name: "functionSelector",
        type: "bytes4"
      },
      {
        indexed: true,
        internalType: "string",
        name: "functionSignature",
        type: "string"
      },
      {
        indexed: true,
        internalType: "address",
        name: "pluginAddress",
        type: "address"
      }
    ],
    name: "PluginSet",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes4",
        name: "functionSelector",
        type: "bytes4"
      },
      {
        indexed: true,
        internalType: "address",
        name: "oldPluginAddress",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newPluginAddress",
        type: "address"
      }
    ],
    name: "PluginUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "previousAdminRole",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "newAdminRole",
        type: "bytes32"
      }
    ],
    name: "RoleAdminChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleGranted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleRevoked",
    type: "event"
  },
  {
    stateMutability: "payable",
    type: "fallback"
  },
  {
    inputs: [],
    name: "DEFAULT_ADMIN_ROLE",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "_selector",
        type: "bytes4"
      }
    ],
    name: "_getPluginForFunction",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "bytes4",
            name: "functionSelector",
            type: "bytes4"
          },
          {
            internalType: "string",
            name: "functionSignature",
            type: "string"
          },
          {
            internalType: "address",
            name: "pluginAddress",
            type: "address"
          }
        ],
        internalType: "struct IPluginMap.Plugin",
        name: "_plugin",
        type: "tuple"
      }
    ],
    name: "addPlugin",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_pluginAddress",
        type: "address"
      }
    ],
    name: "getAllFunctionsOfPlugin",
    outputs: [
      {
        internalType: "bytes4[]",
        name: "registered",
        type: "bytes4[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getAllPlugins",
    outputs: [
      {
        components: [
          {
            internalType: "bytes4",
            name: "functionSelector",
            type: "bytes4"
          },
          {
            internalType: "string",
            name: "functionSignature",
            type: "string"
          },
          {
            internalType: "address",
            name: "pluginAddress",
            type: "address"
          }
        ],
        internalType: "struct IPluginMap.Plugin[]",
        name: "registered",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "_selector",
        type: "bytes4"
      }
    ],
    name: "getPluginForFunction",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleAdmin",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "index",
        type: "uint256"
      }
    ],
    name: "getRoleMember",
    outputs: [
      {
        internalType: "address",
        name: "member",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleMemberCount",
    outputs: [
      {
        internalType: "uint256",
        name: "count",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "grantRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "hasRole",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "hasRoleWithSwitch",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "forwarder",
        type: "address"
      }
    ],
    name: "isTrustedForwarder",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes[]",
        name: "data",
        type: "bytes[]"
      }
    ],
    name: "multicall",
    outputs: [
      {
        internalType: "bytes[]",
        name: "results",
        type: "bytes[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "pluginMap",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "_selector",
        type: "bytes4"
      }
    ],
    name: "removePlugin",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "renounceRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "revokeRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "bytes4",
            name: "functionSelector",
            type: "bytes4"
          },
          {
            internalType: "string",
            name: "functionSignature",
            type: "string"
          },
          {
            internalType: "address",
            name: "pluginAddress",
            type: "address"
          }
        ],
        internalType: "struct IPluginMap.Plugin",
        name: "_plugin",
        type: "tuple"
      }
    ],
    name: "updatePlugin",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    stateMutability: "payable",
    type: "receive"
  }
];

// node_modules/@thirdweb-dev/sdk/dist/sdk-1fbd7918.browser.esm.js
init_lib();

// node_modules/@thirdweb-dev/generated-abis/dist/thirdweb-dev-generated-abis.esm.js
init_shim();
var GENERATED_ABI = {};

// node_modules/@thirdweb-dev/sdk/dist/sdk-1fbd7918.browser.esm.js
var import_cross_fetch = __toESM(require_browser_ponyfill());

// node_modules/@thirdweb-dev/contracts-js/dist/abis/TWFactory.json
var TWFactory_default = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_trustedForwarder",
        type: "address"
      },
      {
        internalType: "address",
        name: "_registry",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "implementation",
        type: "address"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "contractType",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "version",
        type: "uint256"
      }
    ],
    name: "ImplementationAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "implementation",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "isApproved",
        type: "bool"
      }
    ],
    name: "ImplementationApproved",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "implementation",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "proxy",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "deployer",
        type: "address"
      }
    ],
    name: "ProxyDeployed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "previousAdminRole",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "newAdminRole",
        type: "bytes32"
      }
    ],
    name: "RoleAdminChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleGranted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleRevoked",
    type: "event"
  },
  {
    inputs: [],
    name: "DEFAULT_ADMIN_ROLE",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "FACTORY_ROLE",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_implementation",
        type: "address"
      }
    ],
    name: "addImplementation",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "approval",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_implementation",
        type: "address"
      },
      {
        internalType: "bool",
        name: "_toApprove",
        type: "bool"
      }
    ],
    name: "approveImplementation",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    name: "currentVersion",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "_type",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "_data",
        type: "bytes"
      }
    ],
    name: "deployProxy",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_implementation",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "_data",
        type: "bytes"
      },
      {
        internalType: "bytes32",
        name: "_salt",
        type: "bytes32"
      }
    ],
    name: "deployProxyByImplementation",
    outputs: [
      {
        internalType: "address",
        name: "deployedProxy",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "_type",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "_data",
        type: "bytes"
      },
      {
        internalType: "bytes32",
        name: "_salt",
        type: "bytes32"
      }
    ],
    name: "deployProxyDeterministic",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "deployer",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "_type",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "_version",
        type: "uint256"
      }
    ],
    name: "getImplementation",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "_type",
        type: "bytes32"
      }
    ],
    name: "getLatestImplementation",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleAdmin",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "index",
        type: "uint256"
      }
    ],
    name: "getRoleMember",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleMemberCount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "grantRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "hasRole",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "implementation",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "forwarder",
        type: "address"
      }
    ],
    name: "isTrustedForwarder",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes[]",
        name: "data",
        type: "bytes[]"
      }
    ],
    name: "multicall",
    outputs: [
      {
        internalType: "bytes[]",
        name: "results",
        type: "bytes[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "registry",
    outputs: [
      {
        internalType: "contract TWRegistry",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "renounceRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "revokeRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/TWRegistry.json
var TWRegistry_default = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_trustedForwarder",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "deployer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "deployment",
        type: "address"
      }
    ],
    name: "Added",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "deployer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "deployment",
        type: "address"
      }
    ],
    name: "Deleted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "previousAdminRole",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "newAdminRole",
        type: "bytes32"
      }
    ],
    name: "RoleAdminChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleGranted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleRevoked",
    type: "event"
  },
  {
    inputs: [],
    name: "DEFAULT_ADMIN_ROLE",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "OPERATOR_ROLE",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_deployer",
        type: "address"
      },
      {
        internalType: "address",
        name: "_deployment",
        type: "address"
      }
    ],
    name: "add",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_deployer",
        type: "address"
      }
    ],
    name: "count",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_deployer",
        type: "address"
      }
    ],
    name: "getAll",
    outputs: [
      {
        internalType: "address[]",
        name: "",
        type: "address[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleAdmin",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "index",
        type: "uint256"
      }
    ],
    name: "getRoleMember",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleMemberCount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "grantRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "hasRole",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "forwarder",
        type: "address"
      }
    ],
    name: "isTrustedForwarder",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes[]",
        name: "data",
        type: "bytes[]"
      }
    ],
    name: "multicall",
    outputs: [
      {
        internalType: "bytes[]",
        name: "results",
        type: "bytes[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_deployer",
        type: "address"
      },
      {
        internalType: "address",
        name: "_deployment",
        type: "address"
      }
    ],
    name: "remove",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "renounceRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "revokeRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/sdk/dist/sdk-1fbd7918.browser.esm.js
var LOCAL_NODE_PKEY = "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80";
var UserWallet = class {
  constructor(network, options) {
    _defineProperty(this, "connection", void 0);
    _defineProperty(this, "options", void 0);
    _defineProperty(this, "events", new eventemitter3_default());
    this.connection = new RPCConnectionHandler(network, options);
    this.options = options;
    this.events = new eventemitter3_default();
  }
  connect(network) {
    this.connection.updateSignerOrProvider(network);
    this.events.emit("signerChanged", this.connection.getSigner());
  }
  async transfer(to, amount) {
    let currencyAddress = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NATIVE_TOKEN_ADDRESS;
    const resolvedTo = await resolveAddress(to);
    const resolvedCurrency = await resolveAddress(currencyAddress);
    const signer = this.requireWallet();
    const amountInWei = await normalizePriceValue(this.connection.getProvider(), amount, currencyAddress);
    if (isNativeToken(resolvedCurrency)) {
      const from = await signer.getAddress();
      const tx = await signer.sendTransaction({
        from,
        to: resolvedTo,
        value: amountInWei
      });
      return {
        receipt: await tx.wait()
      };
    } else {
      return {
        receipt: await this.createErc20(resolvedCurrency).sendTransaction("transfer", [resolvedTo, amountInWei])
      };
    }
  }
  async balance() {
    let currencyAddress = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : NATIVE_TOKEN_ADDRESS;
    this.requireWallet();
    const resolvedCurrency = await resolveAddress(currencyAddress);
    const provider = this.connection.getProvider();
    let balance;
    if (isNativeToken(resolvedCurrency)) {
      balance = await provider.getBalance(await this.getAddress());
    } else {
      balance = await this.createErc20(resolvedCurrency).readContract.balanceOf(await this.getAddress());
    }
    return await fetchCurrencyValue(provider, resolvedCurrency, balance);
  }
  async getAddress() {
    return await this.requireWallet().getAddress();
  }
  async getChainId() {
    return await this.requireWallet().getChainId();
  }
  async getNonce(blockTag) {
    const txCount = await this.connection.getProvider().getTransactionCount(await this.getAddress(), blockTag);
    return txCount;
  }
  isConnected() {
    try {
      this.requireWallet();
      return true;
    } catch (e) {
      return false;
    }
  }
  async sign(message) {
    const signer = this.requireWallet();
    return await signer.signMessage(message);
  }
  async signTypedData(domain, types, message) {
    return await signTypedDataInternal(this.requireWallet(), domain, types, message);
  }
  recoverAddress(message, signature) {
    const messageHash = ethers_exports.utils.hashMessage(message);
    const messageHashBytes = ethers_exports.utils.arrayify(messageHash);
    return ethers_exports.utils.recoverAddress(messageHashBytes, signature);
  }
  async sendRawTransaction(transactionRequest) {
    const signer = this.requireWallet();
    const tx = await signer.sendTransaction(transactionRequest);
    return {
      receipt: await tx.wait()
    };
  }
  async requestFunds(amount) {
    const chainId = await this.getChainId();
    if (chainId === ChainId.Localhost || chainId === ChainId.Hardhat) {
      const localWallet = new UserWallet(new ethers_exports.Wallet(LOCAL_NODE_PKEY, getChainProvider(chainId, this.options)), this.options);
      return localWallet.transfer(await this.getAddress(), amount);
    } else {
      throw new Error(`Requesting funds is not supported on chain: '${chainId}'.`);
    }
  }
  requireWallet() {
    const signer = this.connection.getSigner();
    invariant(signer, "This action requires a connected wallet. Please pass a valid signer to the SDK.");
    return signer;
  }
  createErc20(currencyAddress) {
    return new ContractWrapper(this.connection.getSignerOrProvider(), currencyAddress, IERC20_default, this.options);
  }
};
function extractFeatures(input, enabledExtensions) {
  if (!input) {
    return;
  }
  for (const extensionKey in input) {
    const extension = input[extensionKey];
    if (extension.enabled) {
      enabledExtensions.push(extension);
    }
    extractFeatures(extension.features, enabledExtensions);
  }
}
function getAllDetectedFeatureNames(abi) {
  const features = [];
  extractFeatures(detectFeatures(abi), features);
  return features.map((f) => f.name);
}
function getAllDetectedExtensionNames(abi) {
  return getAllDetectedFeatureNames(abi);
}
function createStorage(storage, options) {
  if (storage) {
    return storage;
  } else if (options == null ? void 0 : options.gatewayUrls) {
    return new ThirdwebStorage({
      gatewayUrls: options.gatewayUrls
    });
  } else {
    return new ThirdwebStorage();
  }
}
var MultichainRegistry = class {
  constructor(network, storage) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    _defineProperty(this, "registryLogic", void 0);
    _defineProperty(this, "registryRouter", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "addContract", buildTransactionFunction(async (contract) => {
      return await this.addContracts.prepare([contract]);
    }));
    _defineProperty(this, "addContracts", buildTransactionFunction(async (contracts) => {
      const deployerAddress = await this.registryRouter.getSignerAddress();
      const encoded = [];
      contracts.forEach((contact) => {
        encoded.push(this.registryLogic.readContract.interface.encodeFunctionData("add", [deployerAddress, contact.address, contact.chainId, contact.metadataURI || ""]));
      });
      return Transaction.fromContractWrapper({
        contractWrapper: this.registryRouter,
        method: "multicall",
        args: [encoded]
      });
    }));
    _defineProperty(this, "removeContract", buildTransactionFunction(async (contract) => {
      return await this.removeContracts.prepare([contract]);
    }));
    _defineProperty(this, "removeContracts", buildTransactionFunction(async (contracts) => {
      const deployerAddress = await this.registryRouter.getSignerAddress();
      const encoded = await Promise.all(contracts.map(async (contract) => this.registryLogic.readContract.interface.encodeFunctionData("remove", [deployerAddress, await resolveAddress(contract.address), contract.chainId])));
      return Transaction.fromContractWrapper({
        contractWrapper: this.registryRouter,
        method: "multicall",
        args: [encoded]
      });
    }));
    this.storage = storage;
    this.registryLogic = new ContractWrapper(network, getMultichainRegistryAddress(), TWMultichainRegistryLogic_default, options);
    this.registryRouter = new ContractWrapper(network, getMultichainRegistryAddress(), TWMultichainRegistryRouter_default, options);
  }
  async updateSigner(signer) {
    this.registryLogic.updateSignerOrProvider(signer);
    this.registryRouter.updateSignerOrProvider(signer);
  }
  async getContractMetadataURI(chainId, address) {
    return await this.registryLogic.readContract.getMetadataUri(chainId, await resolveAddress(address));
  }
  async getContractMetadata(chainId, address) {
    const uri = await this.getContractMetadataURI(chainId, address);
    if (!uri) {
      throw new Error(`No metadata URI found for contract ${address} on chain ${chainId}`);
    }
    return await this.storage.downloadJSON(uri);
  }
  async getContractAddresses(walletAddress) {
    return (await this.registryLogic.readContract.getAll(await resolveAddress(walletAddress))).filter((result) => utils_exports.isAddress(result.deploymentAddress) && result.deploymentAddress.toLowerCase() !== lib_exports.AddressZero).map((result) => ({
      address: result.deploymentAddress,
      chainId: result.chainId.toNumber()
    }));
  }
};
async function getMetadataForPlugins(publishedMetadataUri, storage) {
  var _a;
  let pluginMetadata = [];
  const {
    compilerMetadata,
    extendedMetadata
  } = await fetchAndCacheDeployMetadata(publishedMetadataUri, storage);
  const isPluginRouter = isFeatureEnabled(AbiSchema.parse(compilerMetadata.abi), "PluginRouter");
  if (isPluginRouter) {
    if (extendedMetadata && ((_a = extendedMetadata.factoryDeploymentData) == null ? void 0 : _a.implementationAddresses)) {
      const implementationsAddresses = Object.entries(extendedMetadata.factoryDeploymentData.implementationAddresses);
      try {
        const entry = implementationsAddresses.find((_ref) => {
          let [, implementation2] = _ref;
          return implementation2 !== "";
        });
        const [network, implementation] = entry ? entry : [];
        if (network && implementation) {
          const provider = getChainProvider(parseInt(network), {});
          const contract = new ContractWrapper(provider, implementation, getAllPluginsAbi, {});
          const pluginMap = await contract.call("getAllPlugins");
          const allPlugins = pluginMap.map((item) => item.pluginAddress);
          const pluginAddresses = Array.from(new Set(allPlugins));
          const pluginNames = (await Promise.all(pluginAddresses.map(async (address) => {
            const metadata = fetchContractMetadataFromAddress(address, provider, storage);
            return metadata;
          }))).map((metadata) => metadata.name);
          const pluginUris = await Promise.all(pluginNames.map((name) => {
            return fetchAndCachePublishedContractURI(name);
          }));
          pluginMetadata = (await Promise.all(pluginUris.map(async (uri) => {
            return fetchAndCacheDeployMetadata(uri, storage);
          }))).map((fetchedMetadata) => fetchedMetadata.compilerMetadata);
        }
      } catch {
      }
    }
  }
  return pluginMetadata;
}
function getFunctionSignature(fnInputs) {
  return "(" + fnInputs.map((i) => {
    return i.type === "tuple" ? getFunctionSignature(i.components) : i.type;
  }).join(",") + ")";
}
function generatePluginFunctions(pluginAddress, pluginAbi) {
  const pluginInterface = new ethers_exports.utils.Interface(pluginAbi);
  const pluginFunctions = [];
  for (const fnFragment of Object.values(pluginInterface.functions)) {
    const fn = pluginInterface.getFunction(fnFragment.name);
    if (fn.name.includes("_")) {
      continue;
    }
    pluginFunctions.push({
      functionSelector: pluginInterface.getSighash(fn),
      functionSignature: fn.name + getFunctionSignature(fn.inputs),
      pluginAddress
    });
  }
  return pluginFunctions;
}
async function getDeploymentInfo(metadataUri, storage, provider, create2Factory) {
  caches.deploymentPresets = {};
  const create2FactoryAddress = create2Factory ? create2Factory : await getCreate2FactoryAddress(provider);
  const customParams = {};
  const finalDeploymentInfo = [];
  const {
    compilerMetadata
  } = await fetchAndCacheDeployMetadata(metadataUri, storage);
  const pluginMetadata = await getMetadataForPlugins(metadataUri, storage);
  if (pluginMetadata.length > 0) {
    const pluginDeploymentInfo = await Promise.all(pluginMetadata.map(async (metadata) => {
      const info = await computeDeploymentInfo("plugin", provider, storage, create2FactoryAddress, {
        metadata
      });
      return info;
    }));
    const mapInput = [];
    pluginMetadata.forEach((metadata, index) => {
      const input = generatePluginFunctions(pluginDeploymentInfo[index].transaction.predictedAddress, metadata.abi);
      mapInput.push(...input);
    });
    const pluginMapTransaction = await computeDeploymentInfo("plugin", provider, storage, create2FactoryAddress, {
      contractName: "PluginMap",
      constructorParams: {
        _pluginsToAdd: {
          value: mapInput
        }
      }
    });
    customParams["_pluginMap"] = {
      value: pluginMapTransaction.transaction.predictedAddress
    };
    finalDeploymentInfo.push(...pluginDeploymentInfo, pluginMapTransaction);
  }
  const implementationDeployInfo = await computeDeploymentInfo("implementation", provider, storage, create2FactoryAddress, {
    metadata: compilerMetadata,
    constructorParams: customParams
  });
  const factoryInfo = await computeDeploymentInfo("infra", provider, storage, create2FactoryAddress, {
    contractName: "TWCloneFactory"
  });
  finalDeploymentInfo.push(factoryInfo);
  finalDeploymentInfo.push(...Object.values(caches.deploymentPresets));
  finalDeploymentInfo.push(implementationDeployInfo);
  return finalDeploymentInfo;
}
async function getEncodedConstructorParamsForThirdwebContract(contractName, chainId, storage, constructorParamMap) {
  var _a;
  const provider = getChainProvider(chainId, {
    thirdwebApiKey: DEFAULT_API_KEY
  });
  const publishUri = await fetchAndCachePublishedContractURI(contractName);
  const metadata = await fetchAndCacheDeployMetadata(publishUri, storage);
  const create2Factory = await getCreate2FactoryAddress(provider);
  invariant(create2Factory, "Thirdweb stack not found");
  const pluginMetadata = await getMetadataForPlugins(publishUri, storage);
  let encodedArgs;
  if (pluginMetadata.length > 0) {
    const deploymentInfo = await getDeploymentInfo(publishUri, storage, provider, create2Factory);
    encodedArgs = (_a = deploymentInfo.find((contract) => contract.type === "implementation")) == null ? void 0 : _a.encodedArgs;
  } else {
    encodedArgs = await encodeConstructorParamsForImplementation(metadata.compilerMetadata, provider, storage, create2Factory, constructorParamMap);
  }
  return encodedArgs;
}
async function predictThirdwebContractAddress(contractName, chainId, storage) {
  var _a;
  const provider = getChainProvider(chainId, {
    thirdwebApiKey: DEFAULT_API_KEY
  });
  const publishUri = await fetchAndCachePublishedContractURI(contractName);
  const create2Factory = await getCreate2FactoryAddress(provider);
  invariant(create2Factory, "Thirdweb stack not found");
  const pluginMetadata = await getMetadataForPlugins(publishUri, storage);
  if (pluginMetadata.length > 0) {
    const deploymentInfo = await getDeploymentInfo(publishUri, storage, provider, create2Factory);
    const implementation2 = (_a = deploymentInfo.find((contract) => contract.type === "implementation")) == null ? void 0 : _a.transaction.predictedAddress;
    invariant(implementation2, "Error computing address for plugin router");
    return implementation2;
  }
  const implementation = await computeDeploymentInfo("implementation", provider, storage, create2Factory, {
    contractName
  });
  return implementation.transaction.predictedAddress;
}
async function getThirdwebContractAddress(contractName, chainId, storage) {
  const provider = getChainProvider(chainId, {
    thirdwebApiKey: DEFAULT_API_KEY
  });
  const contractAddress = await predictThirdwebContractAddress(contractName, chainId, storage);
  const isDeployed = await isContractDeployed(contractAddress, provider);
  invariant(isDeployed, "Contract not deployed yet");
  return contractAddress;
}
var VerificationStatus = {
  FAILED: "Fail - Unable to verify",
  SUCCESS: "Pass - Verified",
  PENDING: "Pending in queue",
  ALREADY_VERIFIED: "Contract source code already verified",
  AUTOMATICALLY_VERIFIED: "Already Verified"
};
var RequestStatus = {
  OK: "1",
  NOTOK: "0"
};
async function verifyThirdwebPrebuiltImplementation(contractName, chainId, explorerAPIUrl, explorerAPIKey, storage, constructorArgs) {
  const contractAddress = await getThirdwebContractAddress(contractName, chainId, storage);
  const encodedArgs = await getEncodedConstructorParamsForThirdwebContract(contractName, chainId, storage, constructorArgs);
  console.info(`Verifying ${contractName} at address ${contractAddress}`);
  const guid = await verify(contractAddress, chainId, explorerAPIUrl, explorerAPIKey, storage, encodedArgs == null ? void 0 : encodedArgs.toString().replace("0x", ""));
  return guid;
}
async function verify(contractAddress, chainId, explorerAPIUrl, explorerAPIKey, storage, encodedConstructorArgs) {
  try {
    const provider = getChainProvider(chainId, {});
    const compilerMetadata = await fetchContractMetadataFromAddress(contractAddress, provider, storage);
    const compilerVersion = compilerMetadata.metadata.compiler.version;
    const sources = await fetchSourceFilesFromMetadata(compilerMetadata, storage);
    const sourcesWithUrl = compilerMetadata.metadata.sources;
    const sourcesWithContents = {};
    for (const path of Object.keys(sourcesWithUrl)) {
      const sourceCode = sources.find((source) => path === source.filename);
      if (!sourceCode) {
        throw new Error(`Could not find source file for ${path}`);
      }
      sourcesWithContents[path] = {
        content: sourceCode.source
      };
    }
    const compilerInput = {
      language: "Solidity",
      sources: sourcesWithContents,
      settings: {
        optimizer: compilerMetadata.metadata.settings.optimizer,
        evmVersion: compilerMetadata.metadata.settings.evmVersion,
        remappings: compilerMetadata.metadata.settings.remappings,
        outputSelection: {
          "*": {
            "*": ["abi", "evm.bytecode", "evm.deployedBytecode", "evm.methodIdentifiers", "metadata"],
            "": ["ast"]
          }
        }
      }
    };
    const compilationTarget = compilerMetadata.metadata.settings.compilationTarget;
    const targets = Object.keys(compilationTarget);
    const contractPath = targets[0];
    const encodedArgs = encodedConstructorArgs ? encodedConstructorArgs : await fetchConstructorParams(explorerAPIUrl, explorerAPIKey, contractAddress, compilerMetadata.abi, provider, storage);
    const requestBody = {
      apikey: explorerAPIKey,
      module: "contract",
      action: "verifysourcecode",
      contractaddress: contractAddress,
      sourceCode: JSON.stringify(compilerInput),
      codeformat: "solidity-standard-json-input",
      contractname: `${contractPath}:${compilerMetadata.name}`,
      compilerversion: `v${compilerVersion}`,
      constructorArguements: encodedArgs
    };
    const parameters = new URLSearchParams({
      ...requestBody
    });
    const result = await (0, import_cross_fetch.default)(explorerAPIUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body: parameters.toString()
    });
    const data = await result.json();
    if (data.status === RequestStatus.OK) {
      return data.result;
    } else {
      throw new Error(`${data.result}`);
    }
  } catch (e) {
    throw new Error(e.toString());
  }
}
async function checkVerificationStatus(explorerAPIUrl, explorerAPIKey, guid) {
  const endpoint = `${explorerAPIUrl}?module=contract&action=checkverifystatus&guid=${guid}&apikey=${explorerAPIKey}"`;
  return new Promise((resolve, reject) => {
    const intervalId = setInterval(async () => {
      try {
        const result = await (0, import_cross_fetch.default)(endpoint, {
          method: "GET"
        });
        const data = await result.json();
        if ((data == null ? void 0 : data.result) !== VerificationStatus.PENDING) {
          clearInterval(intervalId);
          resolve(data);
        }
      } catch (e) {
        clearInterval(intervalId);
        reject(e);
      }
    }, 3e3);
  });
}
async function isVerifiedOnEtherscan(contractAddress, chainId, explorerAPIUrl, explorerAPIKey) {
  const provider = getChainProvider(chainId, {
    thirdwebApiKey: DEFAULT_API_KEY
  });
  invariant(await isContractDeployed(contractAddress, provider), "Contract not deployed yet.");
  const endpoint = `${explorerAPIUrl}?module=contract&action=getsourcecode&address=${contractAddress}&apikey=${explorerAPIKey}"`;
  try {
    const result = await (0, import_cross_fetch.default)(endpoint, {
      method: "GET",
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json;charset=UTF-8"
      }
    });
    const data = await result.json();
    const etherscanResult = data.result[0];
    if (etherscanResult.ABI === "Contract source code not verified") {
      return false;
    }
    return true;
  } catch (e) {
    throw new Error(`Error checking verification for contract ${contractAddress}: ${e}`);
  }
}
async function fetchConstructorParams(explorerAPIUrl, explorerAPIKey, contractAddress, abi, provider, storage) {
  const constructorParamTypes = extractConstructorParamsFromAbi(abi);
  if (constructorParamTypes.length === 0) {
    return "";
  }
  const requestBody = {
    apiKey: explorerAPIKey,
    module: "account",
    action: "txlist",
    address: contractAddress,
    page: "1",
    sort: "asc",
    offset: "1"
  };
  const parameters = new URLSearchParams({
    ...requestBody
  });
  const result = await (0, import_cross_fetch.default)(explorerAPIUrl, {
    method: "POST",
    headers: {
      "Content-Type": "application/x-www-form-urlencoded"
    },
    body: parameters.toString()
  });
  const data = await result.json();
  if (data && data.status === RequestStatus.OK && data.result[0] !== void 0) {
    const contract = new utils_exports.Interface(abi);
    const txDeployBytecode = data.result[0].input;
    let constructorArgs = "";
    if (contract.deploy.inputs.length === 0) {
      return "";
    }
    try {
      const bytecode = await fetchDeployBytecodeFromPublishedContractMetadata(contractAddress, provider, storage);
      if (bytecode) {
        const bytecodeHex = bytecode.startsWith("0x") ? bytecode : `0x${bytecode}`;
        constructorArgs = txDeployBytecode.substring(bytecodeHex.length);
      }
    } catch (e) {
    }
    if (!constructorArgs) {
      const matches = [...txDeployBytecode.matchAll(/(64736f6c6343[\w]{6}[\w]{4})(?!.*\1)(.*)$/g)];
      if (matches.length > 0) {
        constructorArgs = matches[0][2];
      }
    }
    if (!constructorArgs) {
      const constructorParamByteLength = constructorParamTypes.length * 64;
      constructorArgs = txDeployBytecode.substring(txDeployBytecode.length - constructorParamByteLength);
    }
    try {
      utils_exports.defaultAbiCoder.decode(contract.deploy.inputs, `0x${constructorArgs}`);
    } catch (e) {
      throw new Error("Verifying this contract requires it to be published. Run `npx thirdweb publish` to publish this contract, then try again.");
    }
    return constructorArgs;
  } else {
    return "";
  }
}
async function fetchDeployBytecodeFromPublishedContractMetadata(contractAddress, provider, storage) {
  const compilerMetaUri = await resolveContractUriFromAddress(contractAddress, provider);
  if (compilerMetaUri) {
    const contract = new Contract(getContractPublisherAddress(), ContractPublisher_default, getChainProvider("polygon", {}));
    const publishedMetadataUri = await contract.getPublishedUriFromCompilerUri(compilerMetaUri);
    if (publishedMetadataUri.length === 0) {
      throw Error(`Could not resolve published metadata URI from ${compilerMetaUri}`);
    }
    const pubmeta = await Promise.all(publishedMetadataUri.filter((uri) => uri.length > 0).map((uri) => fetchExtendedReleaseMetadata(uri, storage)));
    return pubmeta.length > 0 ? await (await storage.download(pubmeta[0].bytecodeUri)).text() : void 0;
  }
  return void 0;
}
var ContractVerifier = class extends RPCConnectionHandler {
  constructor(network, options, storage) {
    super(network, options);
    _defineProperty(this, "storage", void 0);
    this.storage = storage;
  }
  updateSignerOrProvider(network) {
    super.updateSignerOrProvider(network);
  }
  async verifyThirdwebContract(contractName, explorerAPIUrl, explorerAPIKey, constructorArgs) {
    const chainId = (await this.getProvider().getNetwork()).chainId;
    const guid = await verifyThirdwebPrebuiltImplementation(contractName, chainId, explorerAPIUrl, explorerAPIKey, this.storage, constructorArgs);
    console.info("Checking verification status...");
    const verificationStatus = await checkVerificationStatus(explorerAPIUrl, explorerAPIKey, guid);
    console.info(verificationStatus);
  }
  async verifyContract(contractAddress, explorerAPIUrl, explorerAPIKey, constructorArgs) {
    const chainId = (await this.getProvider().getNetwork()).chainId;
    let encodedArgs;
    if (constructorArgs) {
      const paramTypes = Object.values(constructorArgs).map((arg) => {
        invariant(arg.type, "Param type is required");
        return arg.type;
      });
      const paramValues = Object.values(constructorArgs).map((arg) => {
        return arg.value;
      });
      encodedArgs = ethers_exports.utils.defaultAbiCoder.encode(paramTypes, paramValues);
    }
    const guid = await verify(contractAddress, chainId, explorerAPIUrl, explorerAPIKey, this.storage, encodedArgs);
    console.info("Checking verification status...");
    const verificationStatus = await checkVerificationStatus(explorerAPIUrl, explorerAPIKey, guid);
    console.info(verificationStatus);
  }
};
function extractFunctionParamsFromAbi(abi, functionName) {
  const parsedAbi = AbiSchema.parse(abi || []);
  for (const input of parsedAbi) {
    if (input.type === "function" && input.name === functionName) {
      return input.inputs || [];
    }
  }
  return [];
}
async function computeCloneFactoryAddress(provider, storage, create2Factory) {
  if (!create2Factory) {
    create2Factory = await getCreate2FactoryAddress(provider);
  }
  return (await computeDeploymentInfo("infra", provider, storage, create2Factory, {
    contractName: "TWCloneFactory"
  })).transaction.predictedAddress;
}
function convertParamValues(constructorParamTypes, constructorParamValues) {
  if (constructorParamTypes.length !== constructorParamValues.length) {
    throw Error(`Passed the wrong number of constructor arguments: ${constructorParamValues.length}, expected ${constructorParamTypes.length}`);
  }
  return constructorParamTypes.map((p, index) => {
    if (p === "tuple" || p.endsWith("[]")) {
      if (typeof constructorParamValues[index] === "string") {
        return JSON.parse(constructorParamValues[index]);
      } else {
        return constructorParamValues[index];
      }
    }
    if (p === "bytes32") {
      invariant(ethers_exports.utils.isHexString(constructorParamValues[index]), `Could not parse bytes32 value. Expected valid hex string but got "${constructorParamValues[index]}".`);
      return ethers_exports.utils.hexZeroPad(constructorParamValues[index], 32);
    }
    if (p.startsWith("bytes")) {
      invariant(ethers_exports.utils.isHexString(constructorParamValues[index]), `Could not parse bytes value. Expected valid hex string but got "${constructorParamValues[index]}".`);
      return constructorParamValues[index];
    }
    if (p.startsWith("uint") || p.startsWith("int")) {
      return BigNumber.from(constructorParamValues[index].toString());
    }
    return constructorParamValues[index];
  });
}
function estimateGasForDeploy(initCode) {
  let gasLimit = ethers_exports.utils.arrayify(initCode).map((x) => x === 0 ? 4 : 16).reduce((sum, x) => sum + x) + 200 * initCode.length / 2 + 6 * Math.ceil(initCode.length / 64) + 32e3 + 21e3;
  gasLimit = Math.floor(gasLimit * 64 / 63);
  return gasLimit;
}
function createTransactionBatches(transactions) {
  let upperGasLimit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : GAS_LIMIT_FOR_DEPLOYER;
  transactions = transactions.filter((tx) => {
    return tx.data.length > 0;
  });
  if (transactions.length === 0) {
    return [];
  }
  let transactionBatches = [];
  let sum = 0;
  let batch = [];
  transactions.forEach((tx) => {
    const gas = estimateGasForDeploy(tx.data);
    if (sum + gas > upperGasLimit) {
      if (batch.length === 0) {
        transactionBatches.push([tx]);
      } else {
        transactionBatches.push(batch);
        sum = gas;
        batch = [tx];
      }
    } else {
      sum += gas;
      batch.push(tx);
    }
  });
  if (batch.length > 0) {
    transactionBatches.push(batch);
  }
  return transactionBatches;
}
async function deployContractDeterministic(signer, transaction, options) {
  var _a, _b;
  let gasLimit = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 7e6;
  invariant(signer.provider, "Provider required");
  const contractDeployed = await isContractDeployed(transaction.predictedAddress, signer.provider);
  if (!contractDeployed) {
    console.debug(`deploying contract via create2 factory at: ${transaction.predictedAddress}`);
    let tx = {
      to: transaction.to,
      data: transaction.data
    };
    try {
      await signer.estimateGas(tx);
    } catch (e) {
      console.debug("error estimating gas while deploying prebuilt: ", e);
      tx.gasLimit = BigNumber.from(gasLimit);
    }
    (_a = options == null ? void 0 : options.notifier) == null ? void 0 : _a.call(options, "deploying", "preset");
    await (await signer.sendTransaction(tx)).wait();
    (_b = options == null ? void 0 : options.notifier) == null ? void 0 : _b.call(options, "deployed", "preset");
  }
}
function toWei(amount) {
  return utils_exports.parseEther(AmountSchema.parse(amount));
}
async function deployCreate2Factory(signer, options) {
  var _a, _b;
  invariant(signer.provider, "No provider");
  const commonFactoryExists = await isContractDeployed(COMMON_FACTORY, signer.provider);
  if (commonFactoryExists) {
    return COMMON_FACTORY;
  }
  const enforceEip155 = await isEIP155Enforced(signer.provider);
  const networkId = (await signer.provider.getNetwork()).chainId;
  const chainId = enforceEip155 ? networkId : 0;
  console.debug(`ChainId ${networkId} enforces EIP155: ${enforceEip155}`);
  const deploymentInfo = CUSTOM_GAS_FOR_CHAIN[networkId] ? getCreate2FactoryDeploymentInfo(chainId, CUSTOM_GAS_FOR_CHAIN[networkId].gasPrice) : getCreate2FactoryDeploymentInfo(chainId);
  const factoryExists = await isContractDeployed(deploymentInfo.deployment, signer.provider);
  if (!factoryExists) {
    const valueToSend = CUSTOM_GAS_FOR_CHAIN[networkId] ? BigNumber.from(CUSTOM_GAS_FOR_CHAIN[networkId].gasPrice).mul(1e5) : toWei("0.01");
    if ((await signer.provider.getBalance(deploymentInfo.signer)).lt(valueToSend)) {
      await (await signer.sendTransaction({
        to: deploymentInfo.signer,
        value: valueToSend
      })).wait();
    }
    try {
      console.debug(`deploying CREATE2 factory at: ${deploymentInfo.deployment}`);
      (_a = options == null ? void 0 : options.notifier) == null ? void 0 : _a.call(options, "deploying", "create2Factory");
      await (await signer.provider.sendTransaction(deploymentInfo.transaction)).wait();
      (_b = options == null ? void 0 : options.notifier) == null ? void 0 : _b.call(options, "deployed", "create2Factory");
    } catch (err) {
      throw new Error(`Couldn't deploy CREATE2 factory: ${JSON.stringify(err)}`);
    }
  }
  return deploymentInfo.deployment;
}
async function deployWithThrowawayDeployer(signer, transactions, options) {
  var _a, _b;
  let transactionBatches = createTransactionBatches(transactions);
  if (transactionBatches.length === 0) {
    return;
  }
  (_a = options == null ? void 0 : options.notifier) == null ? void 0 : _a.call(options, "deploying", "infra");
  const deployTxns = await Promise.all(transactionBatches.map((txBatch) => {
    const deployer = new ethers_exports.ContractFactory(DEPLOYER_ABI, DEPLOYER_BYTECODE).connect(signer).deploy(txBatch);
    return deployer;
  }));
  await Promise.all(deployTxns.map((tx) => {
    return tx.deployed();
  }));
  (_b = options == null ? void 0 : options.notifier) == null ? void 0 : _b.call(options, "deployed", "infra");
}
var SUPPORTED_CHAIN_IDS = [ChainId.Mainnet, ChainId.Goerli, ChainId.Polygon, ChainId.Mumbai, ChainId.Fantom, ChainId.FantomTestnet, ChainId.Avalanche, ChainId.AvalancheFujiTestnet, ChainId.Optimism, ChainId.OptimismGoerli, ChainId.Arbitrum, ChainId.ArbitrumGoerli, ChainId.BinanceSmartChainMainnet, ChainId.BinanceSmartChainTestnet, ChainId.Hardhat, ChainId.Localhost];
function getDefaultTrustedForwarders(chainId) {
  const chainEnum = SUPPORTED_CHAIN_IDS.find((c) => c === chainId);
  const biconomyForwarder = chainEnum ? CONTRACT_ADDRESSES[chainEnum].biconomyForwarder : AddressZero;
  const openzeppelinForwarder = chainEnum ? CONTRACT_ADDRESSES[chainEnum].openzeppelinForwarder : AddressZero;
  return [openzeppelinForwarder, biconomyForwarder].filter((a) => a !== AddressZero);
}
async function getDeployArguments(contractType, metadata, contractURI, signer, storage) {
  const chainId = await signer.getChainId();
  const signerAddress = await signer.getAddress();
  const chainEnum = SUPPORTED_CHAIN_IDS.find((c) => c === chainId);
  let trustedForwarders = [];
  if (!chainEnum) {
    const forwarder = await computeForwarderAddress(signer.provider, storage);
    trustedForwarders = [forwarder];
  } else {
    trustedForwarders = contractType === PackInitializer.contractType ? [] : getDefaultTrustedForwarders(chainId);
  }
  if (metadata.trusted_forwarders && metadata.trusted_forwarders.length > 0) {
    trustedForwarders.push(...metadata.trusted_forwarders);
  }
  switch (contractType) {
    case NFTDropInitializer.contractType:
    case NFTCollectionInitializer.contractType:
      const erc721metadata = await NFTDropInitializer.schema.deploy.parseAsync(metadata);
      return [signerAddress, erc721metadata.name, erc721metadata.symbol, contractURI, trustedForwarders, erc721metadata.primary_sale_recipient, erc721metadata.fee_recipient, erc721metadata.seller_fee_basis_points, erc721metadata.platform_fee_basis_points, erc721metadata.platform_fee_recipient];
    case SignatureDropInitializer.contractType:
      const signatureDropmetadata = await SignatureDropInitializer.schema.deploy.parseAsync(metadata);
      return [signerAddress, signatureDropmetadata.name, signatureDropmetadata.symbol, contractURI, trustedForwarders, signatureDropmetadata.primary_sale_recipient, signatureDropmetadata.fee_recipient, signatureDropmetadata.seller_fee_basis_points, signatureDropmetadata.platform_fee_basis_points, signatureDropmetadata.platform_fee_recipient];
    case MultiwrapInitializer.contractType:
      const multiwrapMetadata = await MultiwrapInitializer.schema.deploy.parseAsync(metadata);
      return [signerAddress, multiwrapMetadata.name, multiwrapMetadata.symbol, contractURI, trustedForwarders, multiwrapMetadata.fee_recipient, multiwrapMetadata.seller_fee_basis_points];
    case EditionDropInitializer.contractType:
    case EditionInitializer.contractType:
      const erc1155metadata = await EditionDropInitializer.schema.deploy.parseAsync(metadata);
      return [signerAddress, erc1155metadata.name, erc1155metadata.symbol, contractURI, trustedForwarders, erc1155metadata.primary_sale_recipient, erc1155metadata.fee_recipient, erc1155metadata.seller_fee_basis_points, erc1155metadata.platform_fee_basis_points, erc1155metadata.platform_fee_recipient];
    case TokenDropInitializer.contractType:
    case TokenInitializer.contractType:
      const erc20metadata = await TokenInitializer.schema.deploy.parseAsync(metadata);
      return [signerAddress, erc20metadata.name, erc20metadata.symbol, contractURI, trustedForwarders, erc20metadata.primary_sale_recipient, erc20metadata.platform_fee_recipient, erc20metadata.platform_fee_basis_points];
    case VoteInitializer.contractType:
      const voteMetadata = await VoteInitializer.schema.deploy.parseAsync(metadata);
      return [voteMetadata.name, contractURI, trustedForwarders, voteMetadata.voting_token_address, voteMetadata.voting_delay_in_blocks, voteMetadata.voting_period_in_blocks, BigNumber.from(voteMetadata.proposal_token_threshold), voteMetadata.voting_quorum_fraction];
    case SplitInitializer.contractType:
      const splitsMetadata = await SplitInitializer.schema.deploy.parseAsync(metadata);
      return [signerAddress, contractURI, trustedForwarders, splitsMetadata.recipients.map((s) => s.address), splitsMetadata.recipients.map((s) => BigNumber.from(s.sharesBps))];
    case MarketplaceInitializer.contractType:
    case MarketplaceV3Initializer.contractType:
      const marketplaceMetadata = await MarketplaceInitializer.schema.deploy.parseAsync(metadata);
      return [signerAddress, contractURI, trustedForwarders, marketplaceMetadata.platform_fee_recipient, marketplaceMetadata.platform_fee_basis_points];
    case PackInitializer.contractType:
      const packsMetadata = await PackInitializer.schema.deploy.parseAsync(metadata);
      return [signerAddress, packsMetadata.name, packsMetadata.symbol, contractURI, trustedForwarders, packsMetadata.fee_recipient, packsMetadata.seller_fee_basis_points];
    default:
      return [];
  }
}
async function getTrustedForwarders(provider, storage, contractName) {
  const chainId = (await provider.getNetwork()).chainId;
  const chainEnum = SUPPORTED_CHAIN_IDS.find((c) => c === chainId);
  let trustedForwarders = contractName && contractName === PackInitializer.name ? [] : chainEnum ? getDefaultTrustedForwarders(chainId) : [await computeForwarderAddress(provider, storage)];
  return trustedForwarders;
}
var APPROVED_IMPLEMENTATIONS = {
  [ChainId.Mainnet]: {
    "nft-drop": "0x60fF9952e0084A6DEac44203838cDC91ABeC8736",
    "edition-drop": "0x74af262d0671F378F97a1EDC3d0970Dbe8A1C550",
    "token-drop": "0xE1eE43D23f247b6A9aF81fcE2766E76709482728",
    "signature-drop": "0x6fD690EB509BdE4C50028C5D9C0dE3750C2Fad6A"
  },
  [ChainId.Polygon]: {
    "nft-drop": "0xB96508050Ba0925256184103560EBADA912Fcc69",
    "edition-drop": "0x74af262d0671F378F97a1EDC3d0970Dbe8A1C550",
    "token-drop": "0x5A8eA4Adad8289746D073947BA06D69A62499aaf",
    "signature-drop": "0xBE2fDc35410E268e41Bec62DBb01AEb43245c7d5"
  },
  [ChainId.Fantom]: {
    "nft-drop": "0x2A396b2D90BAcEF19cDa973586B2633d22710fC2",
    "edition-drop": "0x06395FCF9AC6ED827f9dD6e776809cEF1Be0d21B",
    "token-drop": "0x0148b28a38efaaC31b6aa0a6D9FEb70FE7C91FFa",
    "signature-drop": "0xe135Ef65C2B2213C3fD56d0Bd6500A2cA147aC10"
  },
  [ChainId.Avalanche]: {
    "nft-drop": "0x9cF91118C8ee2913F0588e0F10e36B3d63F68bF6",
    "edition-drop": "0x135fC9D26E5eC51260ece1DF4ED424E2f55c7766",
    "token-drop": "0xca0B071899E575BA86495D46c5066971b6f3A901",
    "signature-drop": "0x1d47526C3292B0130ef0afD5F02c1DA052A017B3"
  },
  [ChainId.Optimism]: {
    "nft-drop": "0xFBd7D24d80ee005671E731a7287DEB6073264dD1",
    "edition-drop": "0xe135Ef65C2B2213C3fD56d0Bd6500A2cA147aC10",
    "token-drop": "0x902Dd246e66d8C3CE652375a723F2a52b43b9AAE",
    "signature-drop": "0x8a4cd3549e548bbEEb38C16E041FFf040a5acabD"
  },
  [ChainId.Arbitrum]: {
    "nft-drop": "0xC4903c1Ff5367b9ac2c349B63DC2409421AaEE2a",
    "edition-drop": "0xCcddcec1831646Beff2753249f1B9C580327E89F",
    "token-drop": "0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9",
    "signature-drop": "0x2dF9851af45dd41C8584ac55D983C604da985Bc7"
  },
  [ChainId.BinanceSmartChainMainnet]: {
    "nft-drop": "0x902Dd246e66d8C3CE652375a723F2a52b43b9AAE",
    "edition-drop": "0x2A396b2D90BAcEF19cDa973586B2633d22710fC2",
    "token-drop": "0xe135Ef65C2B2213C3fD56d0Bd6500A2cA147aC10",
    "signature-drop": "0xFBd7D24d80ee005671E731a7287DEB6073264dD1"
  },
  [ChainId.Goerli]: {
    "nft-drop": "0xD11c97DD5F5546B5bBd630D7D1d7327481B0b92C",
    "edition-drop": "0x5A8eA4Adad8289746D073947BA06D69A62499aaf",
    "token-drop": "0x5680933221B752EB443654a014f88B101F868d50",
    "signature-drop": "0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9"
  },
  [ChainId.Mumbai]: {
    "nft-drop": "0xC4903c1Ff5367b9ac2c349B63DC2409421AaEE2a",
    "edition-drop": "0xCcddcec1831646Beff2753249f1B9C580327E89F",
    "token-drop": "0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9",
    "signature-drop": "0x2dF9851af45dd41C8584ac55D983C604da985Bc7"
  },
  [ChainId.FantomTestnet]: {
    "nft-drop": "0x8a4cd3549e548bbEEb38C16E041FFf040a5acabD",
    "edition-drop": "0x902Dd246e66d8C3CE652375a723F2a52b43b9AAE",
    "token-drop": "0xFBd7D24d80ee005671E731a7287DEB6073264dD1",
    "signature-drop": "0x5A8eA4Adad8289746D073947BA06D69A62499aaf"
  },
  [ChainId.AvalancheFujiTestnet]: {
    "nft-drop": "0xD11c97DD5F5546B5bBd630D7D1d7327481B0b92C",
    "edition-drop": "0xE1eE43D23f247b6A9aF81fcE2766E76709482728",
    "token-drop": "0x6fD690EB509BdE4C50028C5D9C0dE3750C2Fad6A",
    "signature-drop": "0xCcddcec1831646Beff2753249f1B9C580327E89F"
  },
  [ChainId.OptimismGoerli]: {
    "nft-drop": "0xCcddcec1831646Beff2753249f1B9C580327E89F",
    "edition-drop": "0x6fD690EB509BdE4C50028C5D9C0dE3750C2Fad6A",
    "token-drop": "0xD11c97DD5F5546B5bBd630D7D1d7327481B0b92C",
    "signature-drop": "0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9"
  },
  [ChainId.ArbitrumGoerli]: {
    "nft-drop": "0x9CfE807a5b124b962064Fa8F7FD823Cc701255b6",
    "edition-drop": "0x9cF91118C8ee2913F0588e0F10e36B3d63F68bF6",
    "token-drop": "0x1d47526C3292B0130ef0afD5F02c1DA052A017B3",
    "signature-drop": "0xE1eE43D23f247b6A9aF81fcE2766E76709482728"
  },
  [ChainId.BinanceSmartChainTestnet]: {
    "nft-drop": "",
    "edition-drop": "",
    "token-drop": "",
    "signature-drop": ""
  },
  [ChainId.Hardhat]: {
    "nft-drop": "",
    "edition-drop": "",
    "token-drop": "",
    "signature-drop": ""
  },
  [ChainId.Localhost]: {
    "nft-drop": "",
    "edition-drop": "",
    "token-drop": "",
    "signature-drop": ""
  }
};
function getApprovedImplementation(chainId, contractType) {
  if (chainId in APPROVED_IMPLEMENTATIONS) {
    const approvedImpls = APPROVED_IMPLEMENTATIONS[chainId];
    if (contractType in approvedImpls) {
      return approvedImpls[contractType];
    }
  }
  return null;
}
var ContractFactory = class extends ContractWrapper {
  constructor(factoryAddr, network, storage, _options) {
    super(network, factoryAddr, TWFactory_default, _options);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "DEFAULT_VERSION_MAP", {
      [NFTDropInitializer.contractType]: 3,
      [NFTCollectionInitializer.contractType]: 1,
      [SignatureDropInitializer.contractType]: 4,
      [MultiwrapInitializer.contractType]: 1,
      [EditionDropInitializer.contractType]: 2,
      [EditionInitializer.contractType]: 1,
      [TokenDropInitializer.contractType]: 2,
      [TokenInitializer.contractType]: 1,
      [VoteInitializer.contractType]: 1,
      [SplitInitializer.contractType]: 1,
      [MarketplaceInitializer.contractType]: 2,
      [MarketplaceV3Initializer.contractType]: 1,
      [PackInitializer.contractType]: 2
    });
    _defineProperty(this, "deploy", buildTransactionFunction(async (contractType, contractMetadata, eventEmitter, version, options, onExecute) => {
      const contract = PREBUILT_CONTRACTS_MAP[contractType];
      const metadata = await contract.schema.deploy.parseAsync(contractMetadata);
      const contractURI = await this.storage.upload(metadata);
      const implementationAddress = await this.getImplementation(contract, version) || void 0;
      if (!implementationAddress || implementationAddress === lib_exports.AddressZero) {
        throw new Error(`No implementation found for ${contractType}`);
      }
      const ABI = await contract.getAbi(implementationAddress, this.getProvider(), this.storage);
      const signer = this.getSigner();
      invariant(signer, "A signer is required to deploy contracts");
      const args = await getDeployArguments(contractType, metadata, contractURI, signer, this.storage);
      const encodedFunc = Contract.getInterface(ABI).encodeFunctionData("initialize", args);
      const blockNumber = await this.getProvider().getBlockNumber();
      const salt = (options == null ? void 0 : options.saltForProxyDeploy) ? ethers_exports.utils.id(options.saltForProxyDeploy) : ethers_exports.utils.formatBytes32String(blockNumber.toString());
      return Transaction.fromContractWrapper({
        contractWrapper: this,
        method: "deployProxyByImplementation",
        args: [implementationAddress, encodedFunc, salt],
        parse: (receipt) => {
          if (onExecute) {
            onExecute();
          }
          const events = this.parseLogs("ProxyDeployed", receipt.logs);
          if (events.length < 1) {
            throw new Error("No ProxyDeployed event found");
          }
          const contractAddress = events[0].args.proxy;
          eventEmitter.emit("contractDeployed", {
            status: "completed",
            contractAddress,
            transactionHash: receipt.transactionHash
          });
          return contractAddress;
        }
      });
    }));
    _defineProperty(this, "deployProxyByImplementation", buildTransactionFunction(async (implementationAddress, implementationAbi, initializerFunction, initializerArgs, eventEmitter, saltForProxyDeploy, onExecute) => {
      const encodedFunc = Contract.getInterface(implementationAbi).encodeFunctionData(initializerFunction, initializerArgs);
      const blockNumber = await this.getProvider().getBlockNumber();
      const salt = saltForProxyDeploy ? ethers_exports.utils.id(saltForProxyDeploy) : ethers_exports.utils.formatBytes32String(blockNumber.toString());
      return Transaction.fromContractWrapper({
        contractWrapper: this,
        method: "deployProxyByImplementation",
        args: [implementationAddress, encodedFunc, salt],
        parse: (receipt) => {
          if (onExecute) {
            onExecute();
          }
          const events = this.parseLogs("ProxyDeployed", receipt.logs);
          if (events.length < 1) {
            throw new Error("No ProxyDeployed event found");
          }
          const contractAddress = events[0].args.proxy;
          eventEmitter.emit("contractDeployed", {
            status: "completed",
            contractAddress,
            transactionHash: receipt.transactionHash
          });
          return contractAddress;
        }
      });
    }));
    this.storage = storage;
  }
  async getDeployArguments(contractType, metadata, contractURI) {
    let trustedForwarders = contractType === PackInitializer.contractType ? [] : await this.getDefaultTrustedForwarders();
    if (metadata.trusted_forwarders && metadata.trusted_forwarders.length > 0) {
      trustedForwarders = metadata.trusted_forwarders;
    }
    switch (contractType) {
      case NFTDropInitializer.contractType:
      case NFTCollectionInitializer.contractType:
        const erc721metadata = await NFTDropInitializer.schema.deploy.parseAsync(metadata);
        return [await this.getSignerAddress(), erc721metadata.name, erc721metadata.symbol, contractURI, trustedForwarders, erc721metadata.primary_sale_recipient, erc721metadata.fee_recipient, erc721metadata.seller_fee_basis_points, erc721metadata.platform_fee_basis_points, erc721metadata.platform_fee_recipient];
      case SignatureDropInitializer.contractType:
        const signatureDropmetadata = await SignatureDropInitializer.schema.deploy.parseAsync(metadata);
        return [await this.getSignerAddress(), signatureDropmetadata.name, signatureDropmetadata.symbol, contractURI, trustedForwarders, signatureDropmetadata.primary_sale_recipient, signatureDropmetadata.fee_recipient, signatureDropmetadata.seller_fee_basis_points, signatureDropmetadata.platform_fee_basis_points, signatureDropmetadata.platform_fee_recipient];
      case MultiwrapInitializer.contractType:
        const multiwrapMetadata = await MultiwrapInitializer.schema.deploy.parseAsync(metadata);
        return [await this.getSignerAddress(), multiwrapMetadata.name, multiwrapMetadata.symbol, contractURI, trustedForwarders, multiwrapMetadata.fee_recipient, multiwrapMetadata.seller_fee_basis_points];
      case EditionDropInitializer.contractType:
      case EditionInitializer.contractType:
        const erc1155metadata = await EditionDropInitializer.schema.deploy.parseAsync(metadata);
        return [await this.getSignerAddress(), erc1155metadata.name, erc1155metadata.symbol, contractURI, trustedForwarders, erc1155metadata.primary_sale_recipient, erc1155metadata.fee_recipient, erc1155metadata.seller_fee_basis_points, erc1155metadata.platform_fee_basis_points, erc1155metadata.platform_fee_recipient];
      case TokenDropInitializer.contractType:
      case TokenInitializer.contractType:
        const erc20metadata = await TokenInitializer.schema.deploy.parseAsync(metadata);
        return [await this.getSignerAddress(), erc20metadata.name, erc20metadata.symbol, contractURI, trustedForwarders, erc20metadata.primary_sale_recipient, erc20metadata.platform_fee_recipient, erc20metadata.platform_fee_basis_points];
      case VoteInitializer.contractType:
        const voteMetadata = await VoteInitializer.schema.deploy.parseAsync(metadata);
        return [voteMetadata.name, contractURI, trustedForwarders, voteMetadata.voting_token_address, voteMetadata.voting_delay_in_blocks, voteMetadata.voting_period_in_blocks, BigNumber.from(voteMetadata.proposal_token_threshold), voteMetadata.voting_quorum_fraction];
      case SplitInitializer.contractType:
        const splitsMetadata = await SplitInitializer.schema.deploy.parseAsync(metadata);
        return [await this.getSignerAddress(), contractURI, trustedForwarders, splitsMetadata.recipients.map((s) => s.address), splitsMetadata.recipients.map((s) => BigNumber.from(s.sharesBps))];
      case MarketplaceInitializer.contractType:
        const marketplaceMetadata = await MarketplaceInitializer.schema.deploy.parseAsync(metadata);
        return [await this.getSignerAddress(), contractURI, trustedForwarders, marketplaceMetadata.platform_fee_recipient, marketplaceMetadata.platform_fee_basis_points];
      case MarketplaceV3Initializer.contractType:
        const marketplaceV3Metadata = await MarketplaceV3Initializer.schema.deploy.parseAsync(metadata);
        return [await this.getSignerAddress(), contractURI, trustedForwarders, marketplaceV3Metadata.platform_fee_recipient, marketplaceV3Metadata.platform_fee_basis_points];
      case PackInitializer.contractType:
        const packsMetadata = await PackInitializer.schema.deploy.parseAsync(metadata);
        return [await this.getSignerAddress(), packsMetadata.name, packsMetadata.symbol, contractURI, trustedForwarders, packsMetadata.fee_recipient, packsMetadata.seller_fee_basis_points];
      default:
        return [];
    }
  }
  async getDefaultTrustedForwarders() {
    const chainId = await this.getChainID();
    return getDefaultTrustedForwarders(chainId);
  }
  async getImplementation(contract, version) {
    const encodedType = ethers_exports.utils.formatBytes32String(contract.name);
    const chainId = await this.getChainID();
    const approvedImplementation = getApprovedImplementation(chainId, contract.contractType);
    if (approvedImplementation && approvedImplementation.length > 0 && version === void 0) {
      return approvedImplementation;
    }
    return this.readContract.getImplementation(encodedType, version !== void 0 ? version : this.DEFAULT_VERSION_MAP[contract.contractType]);
  }
  async getLatestVersion(contractType) {
    const name = getContractName(contractType);
    if (!name) {
      throw new Error(`Invalid contract type ${contractType}`);
    }
    const encodedType = ethers_exports.utils.formatBytes32String(name);
    return this.readContract.currentVersion(encodedType);
  }
};
var ContractRegistry = class extends ContractWrapper {
  constructor(registryAddress, network, options) {
    super(network, registryAddress, TWRegistry_default, options);
    _defineProperty(this, "addContract", buildTransactionFunction(async (contractAddress) => {
      return await this.addContracts.prepare([contractAddress]);
    }));
    _defineProperty(this, "addContracts", buildTransactionFunction(async (contractAddresses) => {
      const deployerAddress = await this.getSignerAddress();
      const encoded = await Promise.all(contractAddresses.map(async (address) => this.readContract.interface.encodeFunctionData("add", [deployerAddress, await resolveAddress(address)])));
      return Transaction.fromContractWrapper({
        contractWrapper: this,
        method: "multicall",
        args: [encoded]
      });
    }));
    _defineProperty(this, "removeContract", buildTransactionFunction(async (contractAddress) => {
      return await this.removeContracts.prepare([contractAddress]);
    }));
    _defineProperty(this, "removeContracts", buildTransactionFunction(async (contractAddresses) => {
      const deployerAddress = await this.getSignerAddress();
      const encoded = await Promise.all(contractAddresses.map(async (address) => this.readContract.interface.encodeFunctionData("remove", [deployerAddress, await resolveAddress(address)])));
      return Transaction.fromContractWrapper({
        contractWrapper: this,
        method: "multicall",
        args: [encoded]
      });
    }));
  }
  async getContractAddresses(walletAddress) {
    return (await this.readContract.getAll(await resolveAddress(walletAddress))).filter((adr) => utils_exports.isAddress(adr) && adr.toLowerCase() !== lib_exports.AddressZero);
  }
};
var ThirdwebSDK = class extends RPCConnectionHandler {
  static async fromWallet(wallet, network) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let storage = arguments.length > 3 ? arguments[3] : void 0;
    const signer = await wallet.getSigner();
    return ThirdwebSDK.fromSigner(signer, network, options, storage);
  }
  static fromSigner(signer, network) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let storage = arguments.length > 3 ? arguments[3] : void 0;
    let signerWithProvider = signer;
    if (network && !signer.provider) {
      const provider = getChainProvider(network, options);
      signerWithProvider = signer.connect(provider);
    }
    const sdk = new ThirdwebSDK(network || signerWithProvider, options, storage);
    sdk.updateSignerOrProvider(signerWithProvider);
    return sdk;
  }
  static fromPrivateKey(privateKey, network) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let storage = arguments.length > 3 ? arguments[3] : void 0;
    const provider = getChainProvider(network, options);
    const signer = new Wallet(privateKey, provider);
    return new ThirdwebSDK(signer, options, storage);
  }
  constructor(network) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let storage = arguments.length > 2 ? arguments[2] : void 0;
    if (isChainConfig(network)) {
      options = {
        ...options,
        supportedChains: [network, ...options.supportedChains || []]
      };
    }
    super(network, options);
    _defineProperty(this, "contractCache", /* @__PURE__ */ new Map());
    _defineProperty(this, "_publisher", void 0);
    _defineProperty(this, "storageHandler", void 0);
    _defineProperty(this, "deployer", void 0);
    _defineProperty(this, "verifier", void 0);
    _defineProperty(this, "multiChainRegistry", void 0);
    _defineProperty(this, "wallet", void 0);
    _defineProperty(this, "storage", void 0);
    setSupportedChains(options == null ? void 0 : options.supportedChains);
    const configuredStorage = createStorage(storage, options);
    this.storage = configuredStorage;
    this.storageHandler = configuredStorage;
    this.wallet = new UserWallet(network, options);
    this.deployer = new ContractDeployer(network, options, configuredStorage);
    this.verifier = new ContractVerifier(network, options, configuredStorage);
    this.multiChainRegistry = new MultichainRegistry(network, this.storageHandler, this.options);
    this._publisher = new ContractPublisher(network, this.options, this.storageHandler);
  }
  get auth() {
    throw new Error(`The sdk.auth namespace has been moved to the @thirdweb-dev/auth package and is no longer available after @thirdweb-dev/sdk >= 3.7.0.
      Please visit https://portal.thirdweb.com/auth for instructions on how to switch to using the new auth package (@thirdweb-dev/auth@3.0.0).

      If you still want to use the old @thirdweb-dev/auth@2.0.0 package, you can downgrade the SDK to version 3.6.0.`);
  }
  async getNFTDrop(contractAddress) {
    return await this.getContract(contractAddress, "nft-drop");
  }
  async getSignatureDrop(contractAddress) {
    return await this.getContract(contractAddress, "signature-drop");
  }
  async getNFTCollection(contractAddress) {
    return await this.getContract(contractAddress, "nft-collection");
  }
  async getEditionDrop(contractAddress) {
    return await this.getContract(contractAddress, "edition-drop");
  }
  async getEdition(contractAddress) {
    return await this.getContract(contractAddress, "edition");
  }
  async getTokenDrop(contractAddress) {
    return await this.getContract(contractAddress, "token-drop");
  }
  async getToken(contractAddress) {
    return await this.getContract(contractAddress, "token");
  }
  async getVote(contractAddress) {
    return await this.getContract(contractAddress, "vote");
  }
  async getSplit(contractAddress) {
    return await this.getContract(contractAddress, "split");
  }
  async getMarketplace(contractAddress) {
    return await this.getContract(contractAddress, "marketplace");
  }
  async getMarketplaceV3(contractAddress) {
    return await this.getContract(contractAddress, "marketplace-v3");
  }
  async getPack(contractAddress) {
    return await this.getContract(contractAddress, "pack");
  }
  async getMultiwrap(contractAddress) {
    return await this.getContract(contractAddress, "multiwrap");
  }
  async getContract(address, contractTypeOrABI) {
    const resolvedAddress = await resolveAddress(address);
    if (this.contractCache.has(resolvedAddress)) {
      return this.contractCache.get(resolvedAddress);
    }
    if (resolvedAddress in GENERATED_ABI) {
      return await this.getContractFromAbi(resolvedAddress, GENERATED_ABI[resolvedAddress]);
    }
    let newContract;
    if (!contractTypeOrABI || contractTypeOrABI === "custom") {
      try {
        const metadata = await this.getPublisher().fetchCompilerMetadataFromAddress(resolvedAddress);
        newContract = await this.getContractFromAbi(resolvedAddress, metadata.abi);
      } catch (e) {
        const resolvedContractType = await this.resolveContractType(address);
        if (resolvedContractType && resolvedContractType !== "custom") {
          const contractAbi = await PREBUILT_CONTRACTS_MAP[resolvedContractType].getAbi(address, this.getProvider(), this.storage);
          newContract = await this.getContractFromAbi(address, contractAbi);
        } else {
          const chainId = (await this.getProvider().getNetwork()).chainId;
          throw new Error(`No ABI found for this contract. Try importing it by visiting: https://thirdweb.com/${chainId}/${resolvedAddress}`);
        }
      }
    } else if (typeof contractTypeOrABI === "string" && contractTypeOrABI in PREBUILT_CONTRACTS_MAP) {
      newContract = await PREBUILT_CONTRACTS_MAP[contractTypeOrABI].initialize(this.getSignerOrProvider(), resolvedAddress, this.storage, this.options);
    } else {
      newContract = await this.getContractFromAbi(resolvedAddress, contractTypeOrABI);
    }
    this.contractCache.set(resolvedAddress, newContract);
    return newContract;
  }
  async getBuiltInContract(address, contractType) {
    return await this.getContract(address, contractType);
  }
  async resolveContractType(contractAddress) {
    try {
      const contract = new Contract(
        await resolveAddress(contractAddress),
        IThirdwebContract_default,
        this.getProvider()
      );
      const remoteContractType = utils_exports.toUtf8String(await contract.contractType()).replace(/\x00/g, "");
      return getContractTypeForRemoteName(remoteContractType);
    } catch (err) {
      return "custom";
    }
  }
  async getContractList(walletAddress) {
    var _a;
    const addresses = await ((_a = await this.deployer.getRegistry()) == null ? void 0 : _a.getContractAddresses(await resolveAddress(walletAddress))) || [];
    const chainId = (await this.getProvider().getNetwork()).chainId;
    return await Promise.all(addresses.map(async (address) => {
      return {
        address,
        chainId,
        contractType: () => this.resolveContractType(address),
        metadata: async () => (await this.getContract(address)).metadata.get(),
        extensions: async () => getAllDetectedFeatureNames((await this.getContract(address)).abi)
      };
    }));
  }
  async getMultichainContractList(walletAddress) {
    let chains = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultChains;
    const contracts = await this.multiChainRegistry.getContractAddresses(walletAddress);
    const chainMap = chains.reduce((acc, chain) => {
      acc[chain.chainId] = chain;
      return acc;
    }, {});
    const sdkMap = {};
    return contracts.map((_ref) => {
      let {
        address,
        chainId
      } = _ref;
      if (!chainMap[chainId]) {
        return {
          address,
          chainId,
          contractType: async () => "custom",
          metadata: async () => ({}),
          extensions: async () => []
        };
      }
      try {
        let chainSDK = sdkMap[chainId];
        if (!chainSDK) {
          chainSDK = new ThirdwebSDK(chainId, {
            ...this.options,
            readonlySettings: void 0,
            supportedChains: chains
          });
          sdkMap[chainId] = chainSDK;
        }
        return {
          address,
          chainId,
          contractType: () => chainSDK.resolveContractType(address),
          metadata: async () => (await chainSDK.getContract(address)).metadata.get(),
          extensions: async () => getAllDetectedFeatureNames((await chainSDK.getContract(address)).abi)
        };
      } catch (e) {
        return {
          address,
          chainId,
          contractType: async () => "custom",
          metadata: async () => ({}),
          extensions: async () => []
        };
      }
    });
  }
  updateSignerOrProvider(network) {
    super.updateSignerOrProvider(network);
    this.updateContractSignerOrProvider();
  }
  updateContractSignerOrProvider() {
    this.wallet.connect(this.getSignerOrProvider());
    this.deployer.updateSignerOrProvider(this.getSignerOrProvider());
    this._publisher.updateSignerOrProvider(this.getSignerOrProvider());
    this.multiChainRegistry.updateSigner(this.getSignerOrProvider());
    this.verifier.updateSignerOrProvider(this.getSignerOrProvider());
    for (const [, contract] of this.contractCache) {
      contract.onNetworkUpdated(this.getSignerOrProvider());
    }
  }
  async getContractFromAbi(address, abi) {
    const resolvedAddress = await resolveAddress(address);
    if (this.contractCache.has(resolvedAddress)) {
      return this.contractCache.get(resolvedAddress);
    }
    const [, provider] = getSignerAndProvider(this.getSignerOrProvider(), this.options);
    const parsedABI = typeof abi === "string" ? JSON.parse(abi) : abi;
    const contract = new SmartContract(this.getSignerOrProvider(), resolvedAddress, await getCompositePluginABI(resolvedAddress, AbiSchema.parse(parsedABI), provider, this.options, this.storage), this.storageHandler, this.options, (await provider.getNetwork()).chainId);
    this.contractCache.set(resolvedAddress, contract);
    return contract;
  }
  async getBalance(address) {
    return fetchCurrencyValue(this.getProvider(), NATIVE_TOKEN_ADDRESS, await this.getProvider().getBalance(await resolveAddress(address)));
  }
  getPublisher() {
    return this._publisher;
  }
};
var THIRDWEB_DEPLOYER = "0xdd99b75f095d0c4d5112aCe938e4e6ed962fb024";
var ContractDeployer = class extends RPCConnectionHandler {
  constructor(network, _options, storage) {
    var _this;
    super(network, _options);
    _this = this;
    _defineProperty(this, "_factory", void 0);
    _defineProperty(this, "_registry", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "events", void 0);
    _defineProperty(this, "transactionListener", (event) => {
      if (event.status === "submitted") {
        this.events.emit("contractDeployed", {
          status: "submitted",
          transactionHash: event.transactionHash
        });
      }
    });
    _defineProperty(this, "deployNFTCollection", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(NFTCollectionInitializer.contractType, metadata, "latest", options);
    }));
    _defineProperty(this, "deployNFTDrop", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(NFTDropInitializer.contractType, metadata, "latest", options);
    }));
    _defineProperty(this, "deploySignatureDrop", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(SignatureDropInitializer.contractType, metadata, "latest", options);
    }));
    _defineProperty(this, "deployMultiwrap", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(MultiwrapInitializer.contractType, metadata, "latest", options);
    }));
    _defineProperty(this, "deployEdition", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(EditionInitializer.contractType, metadata, "latest", options);
    }));
    _defineProperty(this, "deployEditionDrop", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(EditionDropInitializer.contractType, metadata, "latest", options);
    }));
    _defineProperty(this, "deployToken", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(TokenInitializer.contractType, metadata, "latest", options);
    }));
    _defineProperty(this, "deployTokenDrop", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(TokenDropInitializer.contractType, metadata, "latest", options);
    }));
    _defineProperty(this, "deployMarketplace", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(MarketplaceInitializer.contractType, metadata, "latest", options);
    }));
    _defineProperty(this, "deployMarketplaceV3", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(MarketplaceV3Initializer.contractType, metadata, "latest", options);
    }));
    _defineProperty(this, "deployPack", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(PackInitializer.contractType, metadata, "latest", options);
    }));
    _defineProperty(this, "deploySplit", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(SplitInitializer.contractType, metadata, "latest", options);
    }));
    _defineProperty(this, "deployVote", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(VoteInitializer.contractType, metadata, "latest", options);
    }));
    _defineProperty(this, "deployBuiltInContract", buildDeployTransactionFunction(async function(contractType, contractMetadata) {
      let version = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "latest";
      let options = arguments.length > 3 ? arguments[3] : void 0;
      const signer = _this.getSigner();
      invariant(signer, "A signer is required to deploy contracts");
      const parsedMetadata = {
        app_uri: PREBUILT_CONTRACTS_APPURI_MAP[contractType],
        ...await PREBUILT_CONTRACTS_MAP[contractType].schema.deploy.parseAsync(contractMetadata)
      };
      if (_this.hasLocalFactory()) {
        let parsedVersion = void 0;
        try {
          parsedVersion = parseInt(version);
          if (isNaN(parsedVersion)) {
            parsedVersion = void 0;
          }
        } catch (e) {
          parsedVersion = void 0;
        }
        const factory = await _this.getFactory();
        if (!factory) {
          throw new Error("Factory not found");
        }
        factory.on(EventType.Transaction, _this.transactionListener);
        return factory.deploy.prepare(contractType, parsedMetadata, _this.events, parsedVersion, options, () => {
          factory.off(EventType.Transaction, _this.transactionListener);
        });
      }
      const contractName = getContractName(contractType);
      invariant(contractName, "Contract name not found");
      const contractURI = await _this.storage.upload(parsedMetadata);
      const constructorParams = await getDeployArguments(contractType, parsedMetadata, contractURI, signer, _this.storage);
      const publishedContract = await _this.fetchPublishedContractFromPolygon(THIRDWEB_DEPLOYER, contractName, version);
      return _this.deployContractFromUri.prepare(publishedContract.metadataUri, constructorParams, options);
    }));
    _defineProperty(this, "deployReleasedContract", buildDeployTransactionFunction(async function(publisherAddress, contractName, constructorParams) {
      let version = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "latest";
      let options = arguments.length > 4 ? arguments[4] : void 0;
      const publishedContract = await _this.fetchPublishedContractFromPolygon(publisherAddress, contractName, version);
      return await _this.deployContractFromUri.prepare(publishedContract.metadataUri, constructorParams, options);
    }));
    _defineProperty(this, "deployViaFactory", buildTransactionFunction(async (factoryAddress, implementationAddress, implementationAbi, initializerFunction, initializerArgs, saltForProxyDeploy) => {
      const resolvedFactoryAddress = await resolveAddress(factoryAddress);
      const resolvedImplementationAddress = await resolveAddress(implementationAddress);
      const signer = this.getSigner();
      invariant(signer, "signer is required");
      const proxyFactory = new ContractFactory(resolvedFactoryAddress, this.getSignerOrProvider(), this.storage, this.options);
      proxyFactory.on(EventType.Transaction, this.transactionListener);
      return await proxyFactory.deployProxyByImplementation.prepare(resolvedImplementationAddress, implementationAbi, initializerFunction, initializerArgs, this.events, saltForProxyDeploy, () => {
        proxyFactory.off(EventType.Transaction, this.transactionListener);
      });
    }));
    _defineProperty(this, "deployProxy", buildDeployTransactionFunction(async (implementationAddress, implementationAbi, initializerFunction, initializerArgs) => {
      const resolvedAddress = await resolveAddress(implementationAddress);
      const encodedInitializer = Contract.getInterface(implementationAbi).encodeFunctionData(initializerFunction, initializerArgs);
      const {
        TWProxy__factory
      } = await import("./thirdweb-dev-contracts-js-factories-TWProxy__factory.browser.esm-23PPHWOK.js");
      return this.deployContractWithAbi.prepare(TWProxy__factory.abi, TWProxy__factory.bytecode, [resolvedAddress, encodedInitializer]);
    }));
    _defineProperty(this, "deployViaAutoFactory", buildDeployTransactionFunction(async (publishMetadataUri, deployMetadata, signer, initializerFunction, paramValues, options) => {
      var _a, _b, _c;
      const create2Factory = await deployCreate2Factory(signer, options);
      const deploymentInfo = await getDeploymentInfo(publishMetadataUri, this.storage, this.getProvider(), create2Factory);
      const implementationAddress = (_a = deploymentInfo.find((i) => i.type === "implementation")) == null ? void 0 : _a.transaction.predictedAddress;
      const transactionsToSend = deploymentInfo.filter((i) => i.transaction.data && i.transaction.data.length > 0);
      const transactionsforDirectDeploy = transactionsToSend.filter((i) => {
        return i.type !== "infra";
      }).map((i) => i.transaction);
      const transactionsForThrowawayDeployer = transactionsToSend.filter((i) => {
        return i.type === "infra";
      }).map((i) => i.transaction);
      await deployWithThrowawayDeployer(signer, transactionsForThrowawayDeployer, options);
      await Promise.all(transactionsforDirectDeploy.map((tx) => {
        return deployContractDeterministic(signer, tx, options);
      }));
      const resolvedImplementationAddress = await resolveAddress(implementationAddress);
      const cloneFactory = await computeCloneFactoryAddress(this.getProvider(), this.storage, create2Factory);
      (_b = options == null ? void 0 : options.notifier) == null ? void 0 : _b.call(options, "deploying", "proxy");
      const proxyDeployTransaction = await this.deployViaFactory.prepare(cloneFactory, resolvedImplementationAddress, deployMetadata.compilerMetadata.abi, initializerFunction, paramValues, options == null ? void 0 : options.saltForProxyDeploy);
      (_c = options == null ? void 0 : options.notifier) == null ? void 0 : _c.call(options, "deployed", "proxy");
      return proxyDeployTransaction;
    }));
    _defineProperty(this, "deployViaCustomFactory", buildDeployTransactionFunction(async (constructorParamValues, deployMetadata, signer, chainId) => {
      var _a, _b, _c, _d, _e, _f;
      let customFactoryAddress = (_c = (_b = (_a = deployMetadata.extendedMetadata) == null ? void 0 : _a.factoryDeploymentData) == null ? void 0 : _b.customFactoryInput) == null ? void 0 : _c.customFactoryAddresses[chainId];
      const resolvedCustomFactoryAddress = await resolveAddress(customFactoryAddress);
      invariant(resolvedCustomFactoryAddress, `customFactoryAddress not found for chainId '${chainId}'`);
      invariant((_f = (_e = (_d = deployMetadata.extendedMetadata) == null ? void 0 : _d.factoryDeploymentData) == null ? void 0 : _e.customFactoryInput) == null ? void 0 : _f.factoryFunction, `customFactoryFunction not set'`);
      const customFactoryMetadata = await fetchContractMetadataFromAddress(resolvedCustomFactoryAddress, this.getProvider(), this.storage);
      const factoryFunctionParamTypes = extractFunctionParamsFromAbi(customFactoryMetadata.abi, deployMetadata.extendedMetadata.factoryDeploymentData.customFactoryInput.factoryFunction).map((p) => p.type);
      const factoryFunctionparamValues = convertParamValues(factoryFunctionParamTypes, constructorParamValues);
      let deployedImplementationAddress;
      const deployTransaction = await Transaction.fromContractInfo({
        contractAddress: resolvedCustomFactoryAddress,
        contractAbi: customFactoryMetadata.abi,
        provider: this.getProvider(),
        signer,
        method: deployMetadata.extendedMetadata.factoryDeploymentData.customFactoryInput.factoryFunction,
        args: factoryFunctionparamValues,
        parse: () => {
          return deployedImplementationAddress;
        }
      });
      deployedImplementationAddress = await deployTransaction.simulate();
      return deployTransaction;
    }));
    _defineProperty(this, "deployContractFromUri", buildDeployTransactionFunction(async (publishMetadataUri, constructorParamValues, options) => {
      var _a, _b;
      const signer = this.getSigner();
      invariant(signer, "A signer is required");
      const {
        compilerMetadata,
        extendedMetadata
      } = await fetchAndCacheDeployMetadata(publishMetadataUri, this.storage);
      const forceDirectDeploy = (options == null ? void 0 : options.forceDirectDeploy) || false;
      const chainId = (await this.getProvider().getNetwork()).chainId;
      const isNetworkEnabled = ((_a = extendedMetadata == null ? void 0 : extendedMetadata.networksForDeployment) == null ? void 0 : _a.networksEnabled.includes(chainId)) || ((_b = extendedMetadata == null ? void 0 : extendedMetadata.networksForDeployment) == null ? void 0 : _b.allNetworks);
      if ((extendedMetadata == null ? void 0 : extendedMetadata.networksForDeployment) && !isNetworkEnabled) {
        throw new Error(`Deployments disabled on this network, with chainId: ${chainId}`);
      }
      if (extendedMetadata && extendedMetadata.factoryDeploymentData && (extendedMetadata.isDeployableViaProxy || extendedMetadata.isDeployableViaFactory || extendedMetadata.deployType && extendedMetadata.deployType !== "standard") && !forceDirectDeploy) {
        if (extendedMetadata.deployType === "customFactory") {
          return await this.deployViaCustomFactory.prepare(constructorParamValues, {
            compilerMetadata,
            extendedMetadata
          }, signer, chainId);
        } else {
          invariant(extendedMetadata.factoryDeploymentData.implementationInitializerFunction, `implementationInitializerFunction not set'`);
          const initializerParamTypes = extractFunctionParamsFromAbi(compilerMetadata.abi, extendedMetadata.factoryDeploymentData.implementationInitializerFunction).map((p) => p.type);
          const paramValues2 = convertParamValues(initializerParamTypes, constructorParamValues);
          let implementationAddress = extendedMetadata.factoryDeploymentData.implementationAddresses[chainId];
          if (!implementationAddress || extendedMetadata.deployType === "autoFactory") {
            return await this.deployViaAutoFactory.prepare(publishMetadataUri, {
              compilerMetadata,
              extendedMetadata
            }, signer, extendedMetadata.factoryDeploymentData.implementationInitializerFunction, paramValues2, options);
          }
          const resolvedImplementationAddress = await resolveAddress(implementationAddress);
          invariant(resolvedImplementationAddress, `implementationAddress not found for chainId '${chainId}'`);
          if (extendedMetadata.isDeployableViaFactory) {
            invariant(extendedMetadata.factoryDeploymentData.factoryAddresses, "isDeployableViaFactory is true so factoryAddresses is required");
            const factoryAddress = extendedMetadata.factoryDeploymentData.factoryAddresses[chainId];
            invariant(factoryAddress, `isDeployableViaFactory is true and factoryAddress not found for chainId '${chainId}'`);
            const resolvedFactoryAddress = await resolveAddress(factoryAddress);
            return await this.deployViaFactory.prepare(resolvedFactoryAddress, resolvedImplementationAddress, compilerMetadata.abi, extendedMetadata.factoryDeploymentData.implementationInitializerFunction, paramValues2, options == null ? void 0 : options.saltForProxyDeploy);
          } else if (extendedMetadata.isDeployableViaProxy) {
            return await this.deployProxy.prepare(resolvedImplementationAddress, compilerMetadata.abi, extendedMetadata.factoryDeploymentData.implementationInitializerFunction, paramValues2);
          }
        }
      }
      const bytecode = compilerMetadata.bytecode.startsWith("0x") ? compilerMetadata.bytecode : `0x${compilerMetadata.bytecode}`;
      if (!ethers_exports.utils.isHexString(bytecode)) {
        throw new Error(`Contract bytecode is invalid.

${bytecode}`);
      }
      const constructorParamTypes = extractConstructorParamsFromAbi(compilerMetadata.abi).map((p) => p.type);
      const paramValues = convertParamValues(constructorParamTypes, constructorParamValues);
      return this.deployContractWithAbi.prepare(compilerMetadata.abi, bytecode, paramValues);
    }));
    _defineProperty(this, "deployContractWithAbi", buildDeployTransactionFunction(async (abi, bytecode, constructorParams) => {
      const signer = this.getSigner();
      const provider = this.getProvider();
      invariant(signer, "Signer is required to deploy contracts");
      const factory = new ethers_exports.ContractFactory(abi, bytecode).connect(signer);
      return new DeployTransaction({
        args: constructorParams,
        provider,
        signer,
        factory,
        storage: this.storage,
        events: this.events
      });
    }));
    this.storage = storage;
    this.events = new import_index.default();
    this.getFactory();
    this.getRegistry();
  }
  async getLatestBuiltInContractVersion(contractType) {
    const factory = await this.getFactory();
    if (!factory) {
      throw new Error("Factory not found");
    }
    return await factory.getLatestVersion(contractType);
  }
  async getRegistry() {
    if (this._registry) {
      return this._registry;
    }
    return this._registry = this.getProvider().getNetwork().then(async (_ref2) => {
      let {
        chainId
      } = _ref2;
      const registryAddress = getContractAddressByChainId(chainId, "twRegistry");
      if (!registryAddress) {
        return void 0;
      }
      return new ContractRegistry(registryAddress, this.getSignerOrProvider(), this.options);
    });
  }
  async getFactory() {
    if (this._factory) {
      return this._factory;
    }
    return this._factory = this.getProvider().getNetwork().then(async (_ref3) => {
      let {
        chainId
      } = _ref3;
      const factoryAddress = getContractAddressByChainId(chainId, "twFactory");
      if (!factoryAddress) {
        return void 0;
      }
      const factory = new ContractFactory(factoryAddress, this.getSignerOrProvider(), this.storage, this.options);
      return factory;
    });
  }
  updateSignerOrProvider(network) {
    super.updateSignerOrProvider(network);
    this.updateContractSignerOrProvider();
  }
  updateContractSignerOrProvider() {
    var _a, _b;
    (_a = this._factory) == null ? void 0 : _a.then((factory) => {
      factory == null ? void 0 : factory.updateSignerOrProvider(this.getSignerOrProvider());
    }).catch(() => {
    });
    (_b = this._registry) == null ? void 0 : _b.then((registry) => {
      registry == null ? void 0 : registry.updateSignerOrProvider(this.getSignerOrProvider());
    }).catch(() => {
    });
  }
  async getTransactionsForDeploy(publishMetadataUri, options) {
    let transactions = [];
    const provider = this.getProvider();
    invariant(provider, "A provider is required");
    const {
      extendedMetadata
    } = await fetchAndCacheDeployMetadata(publishMetadataUri, this.storage);
    const forceDirectDeploy = (options == null ? void 0 : options.forceDirectDeploy) || false;
    if (extendedMetadata && extendedMetadata.factoryDeploymentData && (extendedMetadata.isDeployableViaProxy || extendedMetadata.isDeployableViaFactory || extendedMetadata.deployType === "autoFactory") && !forceDirectDeploy) {
      const chainId = (await this.getProvider().getNetwork()).chainId;
      let implementationAddress = extendedMetadata.factoryDeploymentData.implementationAddresses[chainId];
      if (!implementationAddress || extendedMetadata.deployType === "autoFactory") {
        const create2FactoryAddress = await getCreate2FactoryAddress(this.getProvider());
        transactions.push({
          contractType: "create2Factory",
          addresses: [create2FactoryAddress]
        });
        const deploymentInfo = await getDeploymentInfo(publishMetadataUri, this.storage, this.getProvider(), create2FactoryAddress);
        const transactionsToSend = deploymentInfo.filter((i) => i.transaction.data && i.transaction.data.length > 0);
        const transactionsforDirectDeploy = transactionsToSend.filter((i) => {
          return i.type !== "infra";
        }).map((i) => i.transaction);
        transactionsforDirectDeploy.forEach((tx) => {
          transactions.push({
            contractType: "preset",
            addresses: [tx.predictedAddress]
          });
        });
        const transactionsForThrowawayDeployer = transactionsToSend.filter((i) => {
          return i.type === "infra";
        }).map((i) => i.transaction);
        const transactionBatches = createTransactionBatches(transactionsForThrowawayDeployer);
        transactionBatches.forEach((batch) => {
          const addresses = batch.map((tx) => tx.predictedAddress);
          transactions.push({
            contractType: "infra",
            addresses
          });
        });
      }
      transactions = (await Promise.all(transactions.map(async (tx) => {
        const addresses = (await Promise.all(tx.addresses.map(async (address) => {
          const isDeployed = await isContractDeployed(address, provider);
          return isDeployed ? null : address;
        }))).filter(Boolean);
        return addresses.length > 0 ? tx : null;
      }))).filter(Boolean);
      transactions.push({
        contractType: "proxy",
        addresses: []
      });
    } else {
      transactions.push({
        contractType: "custom",
        addresses: []
      });
    }
    return transactions;
  }
  addDeployListener(listener) {
    this.events.on("contractDeployed", listener);
  }
  removeDeployListener(listener) {
    this.events.off("contractDeployed", listener);
  }
  removeAllDeployListeners() {
    this.events.removeAllListeners("contractDeployed");
  }
  async fetchPublishedContractFromPolygon(publisherAddress, contractName, version) {
    const address = await resolveAddress(publisherAddress);
    const publishedContract = await new ThirdwebSDK("polygon").getPublisher().getVersion(address, contractName, version);
    if (!publishedContract) {
      throw new Error(`No published contract found for '${contractName}' at version '${version}' by '${address}'`);
    }
    return publishedContract;
  }
  hasLocalFactory() {
    return import_process.default.env.factoryAddress !== void 0;
  }
};

// node_modules/@thirdweb-dev/sdk/dist/abi-197c81ef.browser.esm.js
init_lib();
var PropertiesInput = z.object({}).catchall(z.union([BigNumberTransformSchema, z.unknown()]));
var OptionalPropertiesInput = z.union([z.array(PropertiesInput), PropertiesInput]).optional();
var TokenMintInputSchema = z.object({
  toAddress: AddressOrEnsSchema,
  amount: AmountSchema
});
var EditionMetadataOutputSchema = z.object({
  supply: BigNumberSchema,
  metadata: CommonNFTOutput
});
var EditionMetadataWithOwnerOutputSchema = EditionMetadataOutputSchema.extend({
  owner: z.string(),
  quantityOwned: BigNumberSchema
});
var EditionMetadataInputSchema = z.object({
  supply: BigNumberishSchema,
  metadata: CommonNFTInput
});
var EditionMetadataInputOrUriSchema = z.object({
  supply: BigNumberishSchema,
  metadata: NFTInputOrUriSchema
});
var ProposalState = function(ProposalState2) {
  ProposalState2[ProposalState2["Pending"] = 0] = "Pending";
  ProposalState2[ProposalState2["Active"] = 1] = "Active";
  ProposalState2[ProposalState2["Canceled"] = 2] = "Canceled";
  ProposalState2[ProposalState2["Defeated"] = 3] = "Defeated";
  ProposalState2[ProposalState2["Succeeded"] = 4] = "Succeeded";
  ProposalState2[ProposalState2["Queued"] = 5] = "Queued";
  ProposalState2[ProposalState2["Expired"] = 6] = "Expired";
  ProposalState2[ProposalState2["Executed"] = 7] = "Executed";
  return ProposalState2;
}({});
function matchesPrebuiltAbi(contractWrapper, abi) {
  return hasMatchingAbi(AbiSchema.parse(contractWrapper.abi || []), [abi]);
}
function getAllDetectedFeatures(abi) {
  const features = [];
  extractFeatures(detectFeatures(abi), features);
  return features;
}
function getAllDetectedExtensions(abi) {
  return getAllDetectedFeatures(abi).map((f) => ({
    ...f,
    extensions: f.features
  }));
}
async function normalizeAmount(contractWrapper, amount) {
  const decimals = await contractWrapper.readContract.decimals();
  return utils_exports.parseUnits(AmountSchema.parse(amount), decimals);
}
function toEther(amount) {
  return utils_exports.formatEther(amount);
}
function toUnits(amount, decimals) {
  return utils_exports.parseUnits(AmountSchema.parse(amount), decimals);
}
function toDisplayValue(amount, decimals) {
  return utils_exports.formatUnits(amount, decimals);
}
async function computeNativeTokenAddress(provider, storage, create2Factory) {
  if (!create2Factory) {
    create2Factory = await getCreate2FactoryAddress(provider);
  }
  return (await computeDeploymentInfo("infra", provider, storage, create2Factory, {
    contractName: "WETH9"
  })).transaction.predictedAddress;
}
async function directDeployDeterministic(bytecode, abi, signer, constructorArgs, saltForCreate2) {
  let gasLimit = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 7e6;
  invariant(signer.provider, "Provider is required");
  const bytecodePrefixed = bytecode.startsWith("0x") ? bytecode : `0x${bytecode}`;
  const create2Factory = await deployCreate2Factory(signer);
  const constructorParamTypes = extractConstructorParamsFromAbi(abi).map((p) => {
    return p.type;
  });
  const paramValues = convertParamValues(constructorParamTypes, constructorArgs);
  const encodedArgs = ethers_exports.utils.defaultAbiCoder.encode(constructorParamTypes, paramValues);
  const address = computeDeploymentAddress(bytecodePrefixed, encodedArgs, create2Factory, saltForCreate2);
  const contractDeployed = await isContractDeployed(address, signer.provider);
  let initBytecodeWithSalt = "";
  if (!contractDeployed) {
    console.debug(`deploying contract via create2 factory at: ${address}`);
    initBytecodeWithSalt = getInitBytecodeWithSalt(bytecodePrefixed, encodedArgs, saltForCreate2);
    let tx = {
      to: create2Factory,
      data: initBytecodeWithSalt
    };
    try {
      await signer.estimateGas(tx);
    } catch (e) {
      console.debug("error estimating gas while deploying prebuilt: ", e);
      tx.gasLimit = BigNumber.from(gasLimit);
    }
    await (await signer.sendTransaction(tx)).wait();
  } else {
    throw new Error(`Contract already deployed at ${address}`);
  }
}
async function directDeployDeterministicWithUri(publishMetadataUri, signer, storage, constructorArgs, saltForCreate2) {
  let gasLimit = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 7e6;
  const {
    compilerMetadata
  } = await fetchAndCacheDeployMetadata(publishMetadataUri, storage);
  await directDeployDeterministic(compilerMetadata.bytecode, compilerMetadata.abi, signer, constructorArgs, saltForCreate2, gasLimit);
}
async function predictAddressDeterministic(bytecode, abi, provider, constructorArgs, saltForCreate2) {
  const bytecodePrefixed = bytecode.startsWith("0x") ? bytecode : `0x${bytecode}`;
  const create2Factory = await getCreate2FactoryAddress(provider);
  const constructorParamTypes = extractConstructorParamsFromAbi(abi).map((p) => {
    return p.type;
  });
  const paramValues = convertParamValues(constructorParamTypes, constructorArgs);
  const encodedArgs = ethers_exports.utils.defaultAbiCoder.encode(constructorParamTypes, paramValues);
  const address = computeDeploymentAddress(bytecodePrefixed, encodedArgs, create2Factory, saltForCreate2);
  return address;
}
async function predictAddressDeterministicWithUri(publishMetadataUri, provider, storage, constructorArgs, saltForCreate2) {
  const {
    compilerMetadata
  } = await fetchAndCacheDeployMetadata(publishMetadataUri, storage);
  return await predictAddressDeterministic(compilerMetadata.bytecode, compilerMetadata.abi, provider, constructorArgs, saltForCreate2);
}
async function deployContractDeterministicRaw(signer, bytecode, encodedArgs, create2FactoryAddress, options, predictedAddress) {
  let gasLimit = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 7e6;
  invariant(signer.provider, "Provider required");
  const contractDeployed = predictedAddress ? await isContractDeployed(predictedAddress, signer.provider) : false;
  if (!contractDeployed) {
    console.debug(`deploying contract via create2 factory at: ${predictedAddress}`);
    const initBytecodeWithSalt = getInitBytecodeWithSalt(bytecode, encodedArgs);
    let tx = {
      to: create2FactoryAddress,
      data: initBytecodeWithSalt
    };
    try {
      await signer.estimateGas(tx);
    } catch (e) {
      console.debug("error estimating gas while deploying prebuilt: ", e);
      tx.gasLimit = BigNumber.from(gasLimit);
    }
    await (await signer.sendTransaction(tx)).wait();
  }
}
function getCachedAbiForContract(address) {
  if (address in GENERATED_ABI) {
    return GENERATED_ABI[address];
  }
  return void 0;
}

// node_modules/@thirdweb-dev/sdk/dist/watchTransactions-8b228c8c.browser.esm.js
init_shim();
init_lib();
var STORAGE_CACHE = new ThirdwebStorage();
var CONTRACT_CACHE = /* @__PURE__ */ new Map();
function getContractCacheKey(address, chainId) {
  return `${address}-${chainId}`;
}
function inContractCache(address, chainId) {
  const cacheKey = getContractCacheKey(address, chainId);
  return CONTRACT_CACHE.has(cacheKey);
}
function getCachedContract(address, chainId) {
  if (!inContractCache(address, chainId)) {
    throw new Error(`Contract ${address} was not found in cache`);
  }
  const cacheKey = getContractCacheKey(address, chainId);
  return CONTRACT_CACHE.get(cacheKey);
}
function cacheContract(contract, address, chainId) {
  const cacheKey = getContractCacheKey(address, chainId);
  CONTRACT_CACHE.set(cacheKey, contract);
}
function getCachedStorage(storage) {
  return storage || STORAGE_CACHE;
}
async function getContractFromAbi(params) {
  const resolvedAddress = await resolveAddress(params.address);
  const [signer, provider] = getSignerAndProvider(params.network, params.sdkOptions);
  const chainId = (await provider.getNetwork()).chainId;
  if (inContractCache(resolvedAddress, chainId)) {
    return getCachedContract(resolvedAddress, chainId);
  }
  const parsedAbi = typeof params.abi === "string" ? JSON.parse(params.abi) : params.abi;
  const contract = new SmartContract(signer || provider, resolvedAddress, await getCompositePluginABI(resolvedAddress, AbiSchema.parse(parsedAbi), provider, params.sdkOptions, getCachedStorage(params.storage)), getCachedStorage(params.storage), params.sdkOptions, chainId);
  cacheContract(contract, resolvedAddress, chainId);
  return contract;
}
async function resolveContractType(params) {
  try {
    const contract = new Contract(params.address, IThirdwebContract_default, params.provider);
    const remoteContractType = ethers_exports.utils.toUtf8String(await contract.contractType()).replace(/\x00/g, "");
    return getContractTypeForRemoteName(remoteContractType);
  } catch (err) {
    return "custom";
  }
}
async function getContract(params) {
  const resolvedAddress = await resolveAddress(params.address);
  const [signer, provider] = getSignerAndProvider(params.network, params.sdkOptions);
  const chainId = (await provider.getNetwork()).chainId;
  if (inContractCache(resolvedAddress, chainId)) {
    return getCachedContract(resolvedAddress, chainId);
  }
  if (!params.contractTypeOrAbi || params.contractTypeOrAbi === "custom") {
    const contractType = await resolveContractType({
      address: resolvedAddress,
      provider
    });
    if (contractType === "custom") {
      const publisher = new ContractPublisher(params.network, params.sdkOptions, getCachedStorage(params.storage));
      try {
        const metadata = await publisher.fetchCompilerMetadataFromAddress(resolvedAddress);
        return getContractFromAbi({
          ...params,
          address: resolvedAddress,
          abi: metadata.abi
        });
      } catch {
        throw new Error(`No ABI found for this contract. Try importing it by visiting: https://thirdweb.com/${chainId}/${resolvedAddress}`);
      }
    } else {
      const abi = await PREBUILT_CONTRACTS_MAP[contractType].getAbi(resolvedAddress, provider, getCachedStorage(params.storage));
      return getContractFromAbi({
        ...params,
        address: resolvedAddress,
        abi
      });
    }
  } else if (typeof params.contractTypeOrAbi === "string" && params.contractTypeOrAbi in PREBUILT_CONTRACTS_MAP) {
    const contract = await PREBUILT_CONTRACTS_MAP[params.contractTypeOrAbi].initialize(signer || provider, resolvedAddress, getCachedStorage(params.storage), params.sdkOptions);
    cacheContract(contract, resolvedAddress, chainId);
    return contract;
  } else {
    return getContractFromAbi({
      ...params,
      address: resolvedAddress,
      abi: params.contractTypeOrAbi
    });
  }
}
var CHAIN_ID_CACHE = /* @__PURE__ */ new WeakMap();
async function getChainId(params) {
  const [, provider] = getSignerAndProvider(params.network, params.sdkOptions);
  let chainIdPromise;
  if (CHAIN_ID_CACHE.has(provider)) {
    chainIdPromise = CHAIN_ID_CACHE.get(provider);
  } else {
    chainIdPromise = provider.getNetwork().then((network) => network.chainId).catch((err) => {
      CHAIN_ID_CACHE.delete(provider);
      throw err;
    });
    CHAIN_ID_CACHE.set(provider, chainIdPromise);
  }
  return await chainIdPromise;
}
async function getBlockNumber(params) {
  const [, provider] = getSignerAndProvider(params.network, params.sdkOptions);
  return provider.getBlockNumber();
}
var BLOCK_PROMISE_CACHE = /* @__PURE__ */ new Map();
async function getBlock(params) {
  const chainId = await getChainId(params);
  const blockTag = params.block;
  const cacheKey = `${chainId}_${blockTag}`;
  let blockPromise;
  if (BLOCK_PROMISE_CACHE.has(cacheKey)) {
    blockPromise = BLOCK_PROMISE_CACHE.get(cacheKey);
  } else {
    const [, provider] = getSignerAndProvider(params.network, params.sdkOptions);
    blockPromise = provider.getBlock(blockTag).catch((err) => {
      BLOCK_PROMISE_CACHE.delete(cacheKey);
      throw err;
    });
    BLOCK_PROMISE_CACHE.set(cacheKey, blockPromise);
  }
  return await blockPromise;
}
var BLOCK_WITH_TRANSACTIONS_PROMISE_CACHE = /* @__PURE__ */ new Map();
async function getBlockWithTransactions(params) {
  const chainId = await getChainId(params);
  const blockTag = params.block;
  const cacheKey = `${chainId}_${blockTag}`;
  let blockPromise;
  if (BLOCK_PROMISE_CACHE.has(cacheKey)) {
    blockPromise = BLOCK_WITH_TRANSACTIONS_PROMISE_CACHE.get(cacheKey);
  } else {
    const [, provider] = getSignerAndProvider(params.network, params.sdkOptions);
    blockPromise = provider.getBlockWithTransactions(blockTag).catch((err) => {
      BLOCK_WITH_TRANSACTIONS_PROMISE_CACHE.delete(cacheKey);
      throw err;
    });
    BLOCK_WITH_TRANSACTIONS_PROMISE_CACHE.set(cacheKey, blockPromise);
  }
  return await blockPromise;
}
function watchBlockNumber(params) {
  const [, provider] = getSignerAndProvider(params.network, params.sdkOptions);
  provider.on("block", params.onBlockNumber);
  return () => {
    provider.off("block", params.onBlockNumber);
  };
}
function watchBlock(_ref) {
  let {
    onBlock,
    ...sharedBlockParams
  } = _ref;
  async function onBlockNumber(blockNumber) {
    try {
      onBlock(await getBlock({
        block: blockNumber,
        ...sharedBlockParams
      }));
    } catch (err) {
    }
  }
  return watchBlockNumber({
    ...sharedBlockParams,
    onBlockNumber
  });
}
function watchBlockWithTransactions(_ref2) {
  let {
    onBlock,
    ...sharedBlockParams
  } = _ref2;
  async function onBlockNumber(blockNumber) {
    try {
      onBlock(await getBlockWithTransactions({
        block: blockNumber,
        ...sharedBlockParams
      }));
    } catch (err) {
    }
  }
  return watchBlockNumber({
    ...sharedBlockParams,
    onBlockNumber
  });
}
function watchTransactions(_ref) {
  let {
    address,
    onTransactions,
    ...sharedBlockParams
  } = _ref;
  const lcAddress = address.toLowerCase();
  function onBlock(block) {
    const transactions = block.transactions.filter((tx) => {
      var _a;
      if (tx.from.toLowerCase() === lcAddress) {
        return true;
      }
      return ((_a = tx.to) == null ? void 0 : _a.toLowerCase()) === lcAddress;
    });
    if (transactions.length > 0) {
      onTransactions(transactions);
    }
  }
  return watchBlockWithTransactions({
    ...sharedBlockParams,
    onBlock
  });
}

// node_modules/@thirdweb-dev/sdk/dist/thirdweb-dev-sdk.browser.esm.js
var import_bn = __toESM(require_bn());
init_lib();
var import_merkletreejs = __toESM(require_dist());
var import_fast_deep_equal = __toESM(require_fast_deep_equal());
var import_utils = __toESM(require_utils());
var import_bs58 = __toESM(require_bs58());
var import_cross_fetch2 = __toESM(require_browser_ponyfill());
var import_utils2 = __toESM(require_utils());
globalThis.global = globalThis;

export {
  LOCAL_NODE_PKEY,
  UserWallet,
  getAllDetectedFeatureNames,
  getAllDetectedExtensionNames,
  getDeploymentInfo,
  getEncodedConstructorParamsForThirdwebContract,
  predictThirdwebContractAddress,
  getThirdwebContractAddress,
  verifyThirdwebPrebuiltImplementation,
  verify,
  checkVerificationStatus,
  isVerifiedOnEtherscan,
  extractFunctionParamsFromAbi,
  computeCloneFactoryAddress,
  convertParamValues,
  estimateGasForDeploy,
  createTransactionBatches,
  deployContractDeterministic,
  toWei,
  deployCreate2Factory,
  deployWithThrowawayDeployer,
  SUPPORTED_CHAIN_IDS,
  getDefaultTrustedForwarders,
  getDeployArguments,
  getTrustedForwarders,
  APPROVED_IMPLEMENTATIONS,
  getApprovedImplementation,
  ThirdwebSDK,
  ContractDeployer,
  OptionalPropertiesInput,
  TokenMintInputSchema,
  EditionMetadataOutputSchema,
  EditionMetadataWithOwnerOutputSchema,
  EditionMetadataInputSchema,
  EditionMetadataInputOrUriSchema,
  ProposalState,
  matchesPrebuiltAbi,
  getAllDetectedFeatures,
  getAllDetectedExtensions,
  normalizeAmount,
  toEther,
  toUnits,
  toDisplayValue,
  computeNativeTokenAddress,
  directDeployDeterministic,
  directDeployDeterministicWithUri,
  predictAddressDeterministic,
  predictAddressDeterministicWithUri,
  deployContractDeterministicRaw,
  getCachedAbiForContract,
  getContractFromAbi,
  getContract,
  getChainId,
  getBlockNumber,
  getBlock,
  getBlockWithTransactions,
  watchBlockNumber,
  watchBlock,
  watchBlockWithTransactions,
  watchTransactions
};
//# sourceMappingURL=chunk-ORAGSJLL.js.map
